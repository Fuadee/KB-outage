"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/docxtemplater";
exports.ids = ["vendor-chunks/docxtemplater"];
exports.modules = {

/***/ "(rsc)/./node_modules/docxtemplater/js/content-types.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/content-types.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n\nvar coreContentType = \"application/vnd.openxmlformats-package.core-properties+xml\";\nvar appContentType = \"application/vnd.openxmlformats-officedocument.extended-properties+xml\";\nvar customContentType = \"application/vnd.openxmlformats-officedocument.custom-properties+xml\";\nvar settingsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\";\nvar diagramDataContentType = \"application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml\";\nvar diagramDrawingContentType = \"application/vnd.ms-office.drawingml.diagramDrawing+xml\";\nmodule.exports = {\n  settingsContentType: settingsContentType,\n  coreContentType: coreContentType,\n  appContentType: appContentType,\n  customContentType: customContentType,\n  diagramDataContentType: diagramDataContentType,\n  diagramDrawingContentType: diagramDrawingContentType\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb250ZW50LXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2NvbnRlbnQtdHlwZXMuanM/MGRlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNvcmVDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLXBhY2thZ2UuY29yZS1wcm9wZXJ0aWVzK3htbFwiO1xudmFyIGFwcENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZXh0ZW5kZWQtcHJvcGVydGllcyt4bWxcIjtcbnZhciBjdXN0b21Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmN1c3RvbS1wcm9wZXJ0aWVzK3htbFwiO1xudmFyIHNldHRpbmdzQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnNldHRpbmdzK3htbFwiO1xudmFyIGRpYWdyYW1EYXRhQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nbWwuZGlhZ3JhbURhdGEreG1sXCI7XG52YXIgZGlhZ3JhbURyYXdpbmdDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLW9mZmljZS5kcmF3aW5nbWwuZGlhZ3JhbURyYXdpbmcreG1sXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0dGluZ3NDb250ZW50VHlwZTogc2V0dGluZ3NDb250ZW50VHlwZSxcbiAgY29yZUNvbnRlbnRUeXBlOiBjb3JlQ29udGVudFR5cGUsXG4gIGFwcENvbnRlbnRUeXBlOiBhcHBDb250ZW50VHlwZSxcbiAgY3VzdG9tQ29udGVudFR5cGU6IGN1c3RvbUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRGF0YUNvbnRlbnRUeXBlOiBkaWFncmFtRGF0YUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlOiBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/content-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/doc-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/docxtemplater/js/doc-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nvar _require = __webpack_require__(/*! @xmldom/xmldom */ \"(rsc)/./node_modules/@xmldom/xmldom/lib/index.js\"),\n  DOMParser = _require.DOMParser,\n  XMLSerializer = _require.XMLSerializer;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  throwXmlTagNotFound = _require2.throwXmlTagNotFound;\nvar _require3 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/docxtemplater/js/utils.js\"),\n  last = _require3.last,\n  first = _require3.first;\nfunction isWhiteSpace(value) {\n  return /^[ \\n\\r\\t]+$/.test(value);\n}\nfunction parser(tag) {\n  return {\n    get: function get(scope) {\n      if (tag === \".\") {\n        return scope;\n      }\n      if (scope) {\n        return scope[tag];\n      }\n      return scope;\n    }\n  };\n}\nfunction defaultWarnFn(errors) {\n  for (var _i2 = 0; _i2 < errors.length; _i2++) {\n    var error = errors[_i2];\n    if (error.message) {\n      /* eslint-disable-next-line no-console */\n      console.warn(\"Warning : \" + error.message);\n    }\n  }\n}\nvar attrToRegex = {};\nfunction setSingleAttribute(partValue, attr, attrValue) {\n  var regex;\n  // Stryker disable next-line all : because this is an optimisation\n  if (attrToRegex[attr]) {\n    regex = attrToRegex[attr];\n  } else {\n    regex = new RegExp(\"(<.* \".concat(attr, \"=\\\")([^\\\"]*)(\\\".*)$\"));\n    attrToRegex[attr] = regex;\n  }\n  if (regex.test(partValue)) {\n    return partValue.replace(regex, \"$1\".concat(attrValue, \"$3\"));\n  }\n  var end = partValue.lastIndexOf(\"/>\");\n  if (end === -1) {\n    end = partValue.lastIndexOf(\">\");\n  }\n  return partValue.substr(0, end) + \" \".concat(attr, \"=\\\"\").concat(attrValue, \"\\\"\") + partValue.substr(end);\n}\nfunction getSingleAttribute(value, attributeName) {\n  var index = value.indexOf(\" \".concat(attributeName, \"=\\\"\"));\n  if (index === -1) {\n    return null;\n  }\n  var startIndex = value.substr(index).search(/[\"']/) + index;\n  var endIndex = value.substr(startIndex + 1).search(/[\"']/) + startIndex;\n  return value.substr(startIndex + 1, endIndex - startIndex);\n}\nfunction endsWith(str, suffix) {\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\nfunction startsWith(str, prefix) {\n  return str.substring(0, prefix.length) === prefix;\n}\nfunction getDuplicates(arr) {\n  var duplicates = [];\n  var hash = {},\n    result = [];\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    } else {\n      duplicates.push(arr[i]);\n    }\n  }\n  return duplicates;\n}\nfunction uniq(arr) {\n  var hash = {},\n    result = [];\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\nfunction chunkBy(parsed, f) {\n  var chunks = [[]];\n  for (var _i4 = 0; _i4 < parsed.length; _i4++) {\n    var p = parsed[_i4];\n    var currentChunk = chunks[chunks.length - 1];\n    var res = f(p);\n    if (res === \"start\") {\n      chunks.push([p]);\n    } else if (res === \"end\") {\n      currentChunk.push(p);\n      chunks.push([]);\n    } else {\n      currentChunk.push(p);\n    }\n  } // Remove empty chunks\n  var result = [];\n  for (var _i6 = 0; _i6 < chunks.length; _i6++) {\n    var chunk = chunks[_i6];\n    if (chunk.length > 0) {\n      result.push(chunk);\n    }\n  }\n  return result;\n}\nfunction getDefaults() {\n  return {\n    errorLogging: \"json\",\n    stripInvalidXMLChars: false,\n    paragraphLoop: false,\n    nullGetter: function nullGetter(part) {\n      return part.module ? \"\" : \"undefined\";\n    },\n    xmlFileNames: [\"[Content_Types].xml\"],\n    parser: parser,\n    warnFn: defaultWarnFn,\n    linebreaks: false,\n    fileTypeConfig: null,\n    delimiters: {\n      start: \"{\",\n      end: \"}\"\n    },\n    syntax: {\n      changeDelimiterPrefix: \"=\"\n    }\n  };\n}\nfunction xml2str(xmlNode) {\n  return new XMLSerializer().serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\n}\nfunction str2xml(str) {\n  if (str.charCodeAt(0) === 65279) {\n    // BOM sequence\n    str = str.substr(1);\n  }\n  return new DOMParser().parseFromString(str, \"text/xml\");\n}\nvar charMap = [[\"&\", \"&amp;\"], [\"<\", \"&lt;\"], [\">\", \"&gt;\"], ['\"', \"&quot;\"], [\"'\", \"&apos;\"]];\nvar charMapRegexes = charMap.map(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    endChar = _ref2[0],\n    startChar = _ref2[1];\n  return {\n    rstart: new RegExp(startChar, \"g\"),\n    rend: new RegExp(endChar, \"g\"),\n    start: startChar,\n    end: endChar\n  };\n});\nfunction wordToUtf8(string) {\n  for (var i = charMapRegexes.length - 1; i >= 0; i--) {\n    var r = charMapRegexes[i];\n    string = string.replace(r.rstart, r.end);\n  }\n  return string;\n}\nfunction utf8ToWord(string) {\n  var _string;\n  if ((_string = string) !== null && _string !== void 0 && _string.toString) {\n    // To make sure that the object given is a string (this is a noop for strings).\n    string = string.toString();\n  } else {\n    string = \"\";\n  }\n  var r;\n  for (var i = 0, l = charMapRegexes.length; i < l; i++) {\n    r = charMapRegexes[i];\n    string = string.replace(r.rend, r.start);\n  }\n  return string;\n}\n\n// This function is written with for loops for performance\nfunction concatArrays(arrays) {\n  var result = [];\n  for (var _i8 = 0; _i8 < arrays.length; _i8++) {\n    var array = arrays[_i8];\n    for (var _i0 = 0; _i0 < array.length; _i0++) {\n      var el = array[_i0];\n      result.push(el);\n    }\n  }\n  return result;\n}\nfunction pushArray(array1, array2) {\n  if (!array2) {\n    return array1;\n  }\n  for (var i = 0, len = array2.length; i < len; i++) {\n    array1.push(array2[i]);\n  }\n  return array1;\n}\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\nfunction convertSpaces(s) {\n  return s.replace(spaceRegexp, \" \");\n}\nfunction pregMatchAll(regex, content) {\n  /*\n   * Regex is a string, content is the content. It returns an array of all\n   * matches with their offset, for example:\n   *\n   * regex=la\n   * content=lolalolilala\n   *\n   * Returns:\n   *\n   * [\n   *    {array: {0: 'la'}, offset: 2},\n   *    {array: {0: 'la'}, offset: 8},\n   *    {array: {0: 'la'}, offset: 10}\n   * ]\n   */\n  var matchArray = [];\n  var match;\n  while ((match = regex.exec(content)) != null) {\n    matchArray.push({\n      array: match,\n      offset: match.index\n    });\n  }\n  return matchArray;\n}\nfunction isEnding(value, element) {\n  return value === \"</\" + element + \">\";\n}\nfunction isStarting(value, element) {\n  return value.indexOf(\"<\" + element) === 0 && [\">\", \" \", \"/\"].indexOf(value[element.length + 1]) !== -1;\n}\nfunction getRight(parsed, element, index) {\n  var val = getRightOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"right\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getRightOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n    for (var _i10 = 0, _elements2 = elements; _i10 < _elements2.length; _i10++) {\n      var element = _elements2[_i10];\n      if (isEnding(part.value, element)) {\n        level--;\n      }\n      if (isStarting(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\nfunction getLeft(parsed, element, index) {\n  var val = getLeftOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"left\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getLeftOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index; i >= 0; i--) {\n    var part = parsed[i];\n    for (var _i12 = 0, _elements4 = elements; _i12 < _elements4.length; _i12++) {\n      var element = _elements4[_i12];\n      if (isStarting(part.value, element)) {\n        level--;\n      }\n      if (isEnding(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\n\n/*\n * Stryker disable all : because those are functions that depend on the parsed\n * structure based and we don't want minimal code here, but rather code that\n * makes things clear.\n */\nfunction isTagStart(tagType, _ref3) {\n  var type = _ref3.type,\n    tag = _ref3.tag,\n    position = _ref3.position;\n  return type === \"tag\" && tag === tagType && (position === \"start\" || position === \"selfclosing\");\n}\nfunction isTagEnd(tagType, _ref4) {\n  var type = _ref4.type,\n    tag = _ref4.tag,\n    position = _ref4.position;\n  return type === \"tag\" && tag === tagType && position === \"end\";\n}\nfunction isParagraphStart(_ref5) {\n  var type = _ref5.type,\n    tag = _ref5.tag,\n    position = _ref5.position;\n  return [\"w:p\", \"a:p\", \"text:p\"].indexOf(tag) !== -1 && type === \"tag\" && position === \"start\";\n}\nfunction isParagraphEnd(_ref6) {\n  var type = _ref6.type,\n    tag = _ref6.tag,\n    position = _ref6.position;\n  return [\"w:p\", \"a:p\", \"text:p\"].indexOf(tag) !== -1 && type === \"tag\" && position === \"end\";\n}\nfunction isTextStart(_ref7) {\n  var type = _ref7.type,\n    position = _ref7.position,\n    text = _ref7.text;\n  return text && type === \"tag\" && position === \"start\";\n}\nfunction isTextEnd(_ref8) {\n  var type = _ref8.type,\n    position = _ref8.position,\n    text = _ref8.text;\n  return text && type === \"tag\" && position === \"end\";\n}\nfunction isContent(_ref9) {\n  var type = _ref9.type,\n    position = _ref9.position;\n  return type === \"placeholder\" || type === \"content\" && position === \"insidetag\";\n}\nfunction isModule(_ref0, modules) {\n  var module = _ref0.module,\n    type = _ref0.type;\n  if (!(modules instanceof Array)) {\n    modules = [modules];\n  }\n  return type === \"placeholder\" && modules.indexOf(module) !== -1;\n}\n// Stryker restore all\n\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/g;\n/*\n * 00    NUL '\\0' (null character)\n * 01    SOH (start of heading)\n * 02    STX (start of text)\n * 03    ETX (end of text)\n * 04    EOT (end of transmission)\n * 05    ENQ (enquiry)\n * 06    ACK (acknowledge)\n * 07    BEL '\\a' (bell)\n * 08    BS  '\\b' (backspace)\n * 0B    VT  '\\v' (vertical tab)\n * 0C    FF  '\\f' (form feed)\n * 0E    SO  (shift out)\n * 0F    SI  (shift in)\n * 10    DLE (data link escape)\n * 11    DC1 (device control 1)\n * 12    DC2 (device control 2)\n * 13    DC3 (device control 3)\n * 14    DC4 (device control 4)\n * 15    NAK (negative ack.)\n * 16    SYN (synchronous idle)\n * 17    ETB (end of trans. blk)\n * 18    CAN (cancel)\n * 19    EM  (end of medium)\n * 1A    SUB (substitute)\n * 1B    ESC (escape)\n * 1C    FS  (file separator)\n * 1D    GS  (group separator)\n * 1E    RS  (record separator)\n * 1F    US  (unit separator)\n */\nfunction hasCorruptCharacters(string) {\n  corruptCharacters.lastIndex = 0;\n  return corruptCharacters.test(string);\n}\nfunction removeCorruptCharacters(string) {\n  if (typeof string !== \"string\") {\n    string = String(string);\n  }\n  return string.replace(corruptCharacters, \"\");\n}\nfunction invertMap(map) {\n  var invertedMap = {};\n  for (var key in map) {\n    var value = map[key];\n    invertedMap[value] || (invertedMap[value] = []);\n    invertedMap[value].push(key);\n  }\n  return invertedMap;\n}\n/*\n * This ensures that the sort is stable. The default Array.sort of the browser\n * is not stable in firefox, as the JS spec does not enforce the sort to be\n * stable.\n */\nfunction stableSort(arr, compare) {\n  // Stryker disable all : in previous versions of Chrome, sort was not stable by itself, so we had to add this. This is to support older versions of JS runners.\n  return arr.map(function (item, index) {\n    return {\n      item: item,\n      index: index\n    };\n  }).sort(function (a, b) {\n    return compare(a.item, b.item) || a.index - b.index;\n  }).map(function (_ref1) {\n    var item = _ref1.item;\n    return item;\n  });\n  // Stryker restore all\n}\nmodule.exports = {\n  endsWith: endsWith,\n  startsWith: startsWith,\n  isContent: isContent,\n  isParagraphStart: isParagraphStart,\n  isParagraphEnd: isParagraphEnd,\n  isTagStart: isTagStart,\n  isTagEnd: isTagEnd,\n  isTextStart: isTextStart,\n  isTextEnd: isTextEnd,\n  isStarting: isStarting,\n  isEnding: isEnding,\n  isModule: isModule,\n  uniq: uniq,\n  getDuplicates: getDuplicates,\n  chunkBy: chunkBy,\n  last: last,\n  first: first,\n  xml2str: xml2str,\n  str2xml: str2xml,\n  getRightOrNull: getRightOrNull,\n  getRight: getRight,\n  getLeftOrNull: getLeftOrNull,\n  getLeft: getLeft,\n  pregMatchAll: pregMatchAll,\n  convertSpaces: convertSpaces,\n  charMapRegexes: charMapRegexes,\n  hasCorruptCharacters: hasCorruptCharacters,\n  removeCorruptCharacters: removeCorruptCharacters,\n  getDefaults: getDefaults,\n  wordToUtf8: wordToUtf8,\n  utf8ToWord: utf8ToWord,\n  concatArrays: concatArrays,\n  pushArray: pushArray,\n  invertMap: invertMap,\n  charMap: charMap,\n  getSingleAttribute: getSingleAttribute,\n  setSingleAttribute: setSingleAttribute,\n  isWhiteSpace: isWhiteSpace,\n  stableSort: stableSort\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2MtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw2Q0FBNkMsU0FBUywwREFBMEQsVUFBVSxnQ0FBZ0M7QUFDMUosbUNBQW1DLCtDQUErQyw4QkFBOEIsT0FBTyxrQkFBa0I7QUFDekksdUNBQXVDLGtHQUFrRyxpQkFBaUIsd0NBQXdDLE1BQU0seUNBQXlDLDZCQUE2QixVQUFVLFlBQVksa0VBQWtFLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxNQUFNLGlGQUFpRixVQUFVLG9CQUFvQjtBQUM3Z0IsOEJBQThCO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDdkM7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFhO0FBQ3JDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZSxlQUFlLGlCQUFpQixpQkFBaUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVEsUUFBUSxZQUFZO0FBQ3JDLFNBQVMsUUFBUSxRQUFRLFlBQVk7QUFDckMsU0FBUyxRQUFRLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBLDhDQUE4QywwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0EsOENBQThDLDBCQUEwQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2MtdXRpbHMuanM/ZmQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIkB4bWxkb20veG1sZG9tXCIpLFxuICBET01QYXJzZXIgPSBfcmVxdWlyZS5ET01QYXJzZXIsXG4gIFhNTFNlcmlhbGl6ZXIgPSBfcmVxdWlyZS5YTUxTZXJpYWxpemVyO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgdGhyb3dYbWxUYWdOb3RGb3VuZCA9IF9yZXF1aXJlMi50aHJvd1htbFRhZ05vdEZvdW5kO1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLFxuICBsYXN0ID0gX3JlcXVpcmUzLmxhc3QsXG4gIGZpcnN0ID0gX3JlcXVpcmUzLmZpcnN0O1xuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKHZhbHVlKSB7XG4gIHJldHVybiAvXlsgXFxuXFxyXFx0XSskLy50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlcih0YWcpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChzY29wZSkge1xuICAgICAgaWYgKHRhZyA9PT0gXCIuXCIpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgfVxuICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBzY29wZVt0YWddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRXYXJuRm4oZXJyb3JzKSB7XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVycm9ycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIGVycm9yID0gZXJyb3JzW19pMl07XG4gICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nIDogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbn1cbnZhciBhdHRyVG9SZWdleCA9IHt9O1xuZnVuY3Rpb24gc2V0U2luZ2xlQXR0cmlidXRlKHBhcnRWYWx1ZSwgYXR0ciwgYXR0clZhbHVlKSB7XG4gIHZhciByZWdleDtcbiAgLy8gU3RyeWtlciBkaXNhYmxlIG5leHQtbGluZSBhbGwgOiBiZWNhdXNlIHRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uXG4gIGlmIChhdHRyVG9SZWdleFthdHRyXSkge1xuICAgIHJlZ2V4ID0gYXR0clRvUmVnZXhbYXR0cl07XG4gIH0gZWxzZSB7XG4gICAgcmVnZXggPSBuZXcgUmVnRXhwKFwiKDwuKiBcIi5jb25jYXQoYXR0ciwgXCI9XFxcIikoW15cXFwiXSopKFxcXCIuKikkXCIpKTtcbiAgICBhdHRyVG9SZWdleFthdHRyXSA9IHJlZ2V4O1xuICB9XG4gIGlmIChyZWdleC50ZXN0KHBhcnRWYWx1ZSkpIHtcbiAgICByZXR1cm4gcGFydFZhbHVlLnJlcGxhY2UocmVnZXgsIFwiJDFcIi5jb25jYXQoYXR0clZhbHVlLCBcIiQzXCIpKTtcbiAgfVxuICB2YXIgZW5kID0gcGFydFZhbHVlLmxhc3RJbmRleE9mKFwiLz5cIik7XG4gIGlmIChlbmQgPT09IC0xKSB7XG4gICAgZW5kID0gcGFydFZhbHVlLmxhc3RJbmRleE9mKFwiPlwiKTtcbiAgfVxuICByZXR1cm4gcGFydFZhbHVlLnN1YnN0cigwLCBlbmQpICsgXCIgXCIuY29uY2F0KGF0dHIsIFwiPVxcXCJcIikuY29uY2F0KGF0dHJWYWx1ZSwgXCJcXFwiXCIpICsgcGFydFZhbHVlLnN1YnN0cihlbmQpO1xufVxuZnVuY3Rpb24gZ2V0U2luZ2xlQXR0cmlidXRlKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBpbmRleCA9IHZhbHVlLmluZGV4T2YoXCIgXCIuY29uY2F0KGF0dHJpYnV0ZU5hbWUsIFwiPVxcXCJcIikpO1xuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHN0YXJ0SW5kZXggPSB2YWx1ZS5zdWJzdHIoaW5kZXgpLnNlYXJjaCgvW1wiJ10vKSArIGluZGV4O1xuICB2YXIgZW5kSW5kZXggPSB2YWx1ZS5zdWJzdHIoc3RhcnRJbmRleCArIDEpLnNlYXJjaCgvW1wiJ10vKSArIHN0YXJ0SW5kZXg7XG4gIHJldHVybiB2YWx1ZS5zdWJzdHIoc3RhcnRJbmRleCArIDEsIGVuZEluZGV4IC0gc3RhcnRJbmRleCk7XG59XG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHN1ZmZpeCkge1xuICByZXR1cm4gc3RyLmluZGV4T2Yoc3VmZml4LCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgIT09IC0xO1xufVxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHByZWZpeCkge1xuICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSA9PT0gcHJlZml4O1xufVxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlcyhhcnIpIHtcbiAgdmFyIGR1cGxpY2F0ZXMgPSBbXTtcbiAgdmFyIGhhc2ggPSB7fSxcbiAgICByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKCFoYXNoW2FycltpXV0pIHtcbiAgICAgIGhhc2hbYXJyW2ldXSA9IHRydWU7XG4gICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXBsaWNhdGVzLnB1c2goYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR1cGxpY2F0ZXM7XG59XG5mdW5jdGlvbiB1bmlxKGFycikge1xuICB2YXIgaGFzaCA9IHt9LFxuICAgIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoIWhhc2hbYXJyW2ldXSkge1xuICAgICAgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaHVua0J5KHBhcnNlZCwgZikge1xuICB2YXIgY2h1bmtzID0gW1tdXTtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgcGFyc2VkLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgcCA9IHBhcnNlZFtfaTRdO1xuICAgIHZhciBjdXJyZW50Q2h1bmsgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgIHZhciByZXMgPSBmKHApO1xuICAgIGlmIChyZXMgPT09IFwic3RhcnRcIikge1xuICAgICAgY2h1bmtzLnB1c2goW3BdKTtcbiAgICB9IGVsc2UgaWYgKHJlcyA9PT0gXCJlbmRcIikge1xuICAgICAgY3VycmVudENodW5rLnB1c2gocCk7XG4gICAgICBjaHVua3MucHVzaChbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDaHVuay5wdXNoKHApO1xuICAgIH1cbiAgfSAvLyBSZW1vdmUgZW1wdHkgY2h1bmtzXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgY2h1bmtzLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgY2h1bmsgPSBjaHVua3NbX2k2XTtcbiAgICBpZiAoY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2goY2h1bmspO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gIHJldHVybiB7XG4gICAgZXJyb3JMb2dnaW5nOiBcImpzb25cIixcbiAgICBzdHJpcEludmFsaWRYTUxDaGFyczogZmFsc2UsXG4gICAgcGFyYWdyYXBoTG9vcDogZmFsc2UsXG4gICAgbnVsbEdldHRlcjogZnVuY3Rpb24gbnVsbEdldHRlcihwYXJ0KSB7XG4gICAgICByZXR1cm4gcGFydC5tb2R1bGUgPyBcIlwiIDogXCJ1bmRlZmluZWRcIjtcbiAgICB9LFxuICAgIHhtbEZpbGVOYW1lczogW1wiW0NvbnRlbnRfVHlwZXNdLnhtbFwiXSxcbiAgICBwYXJzZXI6IHBhcnNlcixcbiAgICB3YXJuRm46IGRlZmF1bHRXYXJuRm4sXG4gICAgbGluZWJyZWFrczogZmFsc2UsXG4gICAgZmlsZVR5cGVDb25maWc6IG51bGwsXG4gICAgZGVsaW1pdGVyczoge1xuICAgICAgc3RhcnQ6IFwie1wiLFxuICAgICAgZW5kOiBcIn1cIlxuICAgIH0sXG4gICAgc3ludGF4OiB7XG4gICAgICBjaGFuZ2VEZWxpbWl0ZXJQcmVmaXg6IFwiPVwiXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24geG1sMnN0cih4bWxOb2RlKSB7XG4gIHJldHVybiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHhtbE5vZGUpLnJlcGxhY2UoL3htbG5zKDpbYS16MC05XSspPz1cIlwiID8vZywgXCJcIik7XG59XG5mdW5jdGlvbiBzdHIyeG1sKHN0cikge1xuICBpZiAoc3RyLmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5KSB7XG4gICAgLy8gQk9NIHNlcXVlbmNlXG4gICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgfVxuICByZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsIFwidGV4dC94bWxcIik7XG59XG52YXIgY2hhck1hcCA9IFtbXCImXCIsIFwiJmFtcDtcIl0sIFtcIjxcIiwgXCImbHQ7XCJdLCBbXCI+XCIsIFwiJmd0O1wiXSwgWydcIicsIFwiJnF1b3Q7XCJdLCBbXCInXCIsIFwiJmFwb3M7XCJdXTtcbnZhciBjaGFyTWFwUmVnZXhlcyA9IGNoYXJNYXAubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgIGVuZENoYXIgPSBfcmVmMlswXSxcbiAgICBzdGFydENoYXIgPSBfcmVmMlsxXTtcbiAgcmV0dXJuIHtcbiAgICByc3RhcnQ6IG5ldyBSZWdFeHAoc3RhcnRDaGFyLCBcImdcIiksXG4gICAgcmVuZDogbmV3IFJlZ0V4cChlbmRDaGFyLCBcImdcIiksXG4gICAgc3RhcnQ6IHN0YXJ0Q2hhcixcbiAgICBlbmQ6IGVuZENoYXJcbiAgfTtcbn0pO1xuZnVuY3Rpb24gd29yZFRvVXRmOChzdHJpbmcpIHtcbiAgZm9yICh2YXIgaSA9IGNoYXJNYXBSZWdleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHIgPSBjaGFyTWFwUmVnZXhlc1tpXTtcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyLnJzdGFydCwgci5lbmQpO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59XG5mdW5jdGlvbiB1dGY4VG9Xb3JkKHN0cmluZykge1xuICB2YXIgX3N0cmluZztcbiAgaWYgKChfc3RyaW5nID0gc3RyaW5nKSAhPT0gbnVsbCAmJiBfc3RyaW5nICE9PSB2b2lkIDAgJiYgX3N0cmluZy50b1N0cmluZykge1xuICAgIC8vIFRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBvYmplY3QgZ2l2ZW4gaXMgYSBzdHJpbmcgKHRoaXMgaXMgYSBub29wIGZvciBzdHJpbmdzKS5cbiAgICBzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJpbmcgPSBcIlwiO1xuICB9XG4gIHZhciByO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoYXJNYXBSZWdleGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHIgPSBjaGFyTWFwUmVnZXhlc1tpXTtcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyLnJlbmQsIHIuc3RhcnQpO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgd3JpdHRlbiB3aXRoIGZvciBsb29wcyBmb3IgcGVyZm9ybWFuY2VcbmZ1bmN0aW9uIGNvbmNhdEFycmF5cyhhcnJheXMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBhcnJheXMubGVuZ3RoOyBfaTgrKykge1xuICAgIHZhciBhcnJheSA9IGFycmF5c1tfaThdO1xuICAgIGZvciAodmFyIF9pMCA9IDA7IF9pMCA8IGFycmF5Lmxlbmd0aDsgX2kwKyspIHtcbiAgICAgIHZhciBlbCA9IGFycmF5W19pMF07XG4gICAgICByZXN1bHQucHVzaChlbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwdXNoQXJyYXkoYXJyYXkxLCBhcnJheTIpIHtcbiAgaWYgKCFhcnJheTIpIHtcbiAgICByZXR1cm4gYXJyYXkxO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheTIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnJheTEucHVzaChhcnJheTJbaV0pO1xuICB9XG4gIHJldHVybiBhcnJheTE7XG59XG52YXIgc3BhY2VSZWdleHAgPSBuZXcgUmVnRXhwKFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSwgXCJnXCIpO1xuZnVuY3Rpb24gY29udmVydFNwYWNlcyhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2Uoc3BhY2VSZWdleHAsIFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHByZWdNYXRjaEFsbChyZWdleCwgY29udGVudCkge1xuICAvKlxuICAgKiBSZWdleCBpcyBhIHN0cmluZywgY29udGVudCBpcyB0aGUgY29udGVudC4gSXQgcmV0dXJucyBhbiBhcnJheSBvZiBhbGxcbiAgICogbWF0Y2hlcyB3aXRoIHRoZWlyIG9mZnNldCwgZm9yIGV4YW1wbGU6XG4gICAqXG4gICAqIHJlZ2V4PWxhXG4gICAqIGNvbnRlbnQ9bG9sYWxvbGlsYWxhXG4gICAqXG4gICAqIFJldHVybnM6XG4gICAqXG4gICAqIFtcbiAgICogICAge2FycmF5OiB7MDogJ2xhJ30sIG9mZnNldDogMn0sXG4gICAqICAgIHthcnJheTogezA6ICdsYSd9LCBvZmZzZXQ6IDh9LFxuICAgKiAgICB7YXJyYXk6IHswOiAnbGEnfSwgb2Zmc2V0OiAxMH1cbiAgICogXVxuICAgKi9cbiAgdmFyIG1hdGNoQXJyYXkgPSBbXTtcbiAgdmFyIG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhjb250ZW50KSkgIT0gbnVsbCkge1xuICAgIG1hdGNoQXJyYXkucHVzaCh7XG4gICAgICBhcnJheTogbWF0Y2gsXG4gICAgICBvZmZzZXQ6IG1hdGNoLmluZGV4XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoQXJyYXk7XG59XG5mdW5jdGlvbiBpc0VuZGluZyh2YWx1ZSwgZWxlbWVudCkge1xuICByZXR1cm4gdmFsdWUgPT09IFwiPC9cIiArIGVsZW1lbnQgKyBcIj5cIjtcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpbmcodmFsdWUsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIHZhbHVlLmluZGV4T2YoXCI8XCIgKyBlbGVtZW50KSA9PT0gMCAmJiBbXCI+XCIsIFwiIFwiLCBcIi9cIl0uaW5kZXhPZih2YWx1ZVtlbGVtZW50Lmxlbmd0aCArIDFdKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBnZXRSaWdodChwYXJzZWQsIGVsZW1lbnQsIGluZGV4KSB7XG4gIHZhciB2YWwgPSBnZXRSaWdodE9yTnVsbChwYXJzZWQsIGVsZW1lbnQsIGluZGV4KTtcbiAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdGhyb3dYbWxUYWdOb3RGb3VuZCh7XG4gICAgcG9zaXRpb246IFwicmlnaHRcIixcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIHBhcnNlZDogcGFyc2VkLFxuICAgIGluZGV4OiBpbmRleFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJpZ2h0T3JOdWxsKHBhcnNlZCwgZWxlbWVudHMsIGluZGV4KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gIH1cbiAgdmFyIGxldmVsID0gMTtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBsID0gcGFyc2VkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcGFyc2VkW2ldO1xuICAgIGZvciAodmFyIF9pMTAgPSAwLCBfZWxlbWVudHMyID0gZWxlbWVudHM7IF9pMTAgPCBfZWxlbWVudHMyLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IF9lbGVtZW50czJbX2kxMF07XG4gICAgICBpZiAoaXNFbmRpbmcocGFydC52YWx1ZSwgZWxlbWVudCkpIHtcbiAgICAgICAgbGV2ZWwtLTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N0YXJ0aW5nKHBhcnQudmFsdWUsIGVsZW1lbnQpKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TGVmdChwYXJzZWQsIGVsZW1lbnQsIGluZGV4KSB7XG4gIHZhciB2YWwgPSBnZXRMZWZ0T3JOdWxsKHBhcnNlZCwgZWxlbWVudCwgaW5kZXgpO1xuICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB0aHJvd1htbFRhZ05vdEZvdW5kKHtcbiAgICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICBpbmRleDogaW5kZXhcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRMZWZ0T3JOdWxsKHBhcnNlZCwgZWxlbWVudHMsIGluZGV4KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gIH1cbiAgdmFyIGxldmVsID0gMTtcbiAgZm9yICh2YXIgaSA9IGluZGV4OyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJ0ID0gcGFyc2VkW2ldO1xuICAgIGZvciAodmFyIF9pMTIgPSAwLCBfZWxlbWVudHM0ID0gZWxlbWVudHM7IF9pMTIgPCBfZWxlbWVudHM0Lmxlbmd0aDsgX2kxMisrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IF9lbGVtZW50czRbX2kxMl07XG4gICAgICBpZiAoaXNTdGFydGluZyhwYXJ0LnZhbHVlLCBlbGVtZW50KSkge1xuICAgICAgICBsZXZlbC0tO1xuICAgICAgfVxuICAgICAgaWYgKGlzRW5kaW5nKHBhcnQudmFsdWUsIGVsZW1lbnQpKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKlxuICogU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhvc2UgYXJlIGZ1bmN0aW9ucyB0aGF0IGRlcGVuZCBvbiB0aGUgcGFyc2VkXG4gKiBzdHJ1Y3R1cmUgYmFzZWQgYW5kIHdlIGRvbid0IHdhbnQgbWluaW1hbCBjb2RlIGhlcmUsIGJ1dCByYXRoZXIgY29kZSB0aGF0XG4gKiBtYWtlcyB0aGluZ3MgY2xlYXIuXG4gKi9cbmZ1bmN0aW9uIGlzVGFnU3RhcnQodGFnVHlwZSwgX3JlZjMpIHtcbiAgdmFyIHR5cGUgPSBfcmVmMy50eXBlLFxuICAgIHRhZyA9IF9yZWYzLnRhZyxcbiAgICBwb3NpdGlvbiA9IF9yZWYzLnBvc2l0aW9uO1xuICByZXR1cm4gdHlwZSA9PT0gXCJ0YWdcIiAmJiB0YWcgPT09IHRhZ1R5cGUgJiYgKHBvc2l0aW9uID09PSBcInN0YXJ0XCIgfHwgcG9zaXRpb24gPT09IFwic2VsZmNsb3NpbmdcIik7XG59XG5mdW5jdGlvbiBpc1RhZ0VuZCh0YWdUeXBlLCBfcmVmNCkge1xuICB2YXIgdHlwZSA9IF9yZWY0LnR5cGUsXG4gICAgdGFnID0gX3JlZjQudGFnLFxuICAgIHBvc2l0aW9uID0gX3JlZjQucG9zaXRpb247XG4gIHJldHVybiB0eXBlID09PSBcInRhZ1wiICYmIHRhZyA9PT0gdGFnVHlwZSAmJiBwb3NpdGlvbiA9PT0gXCJlbmRcIjtcbn1cbmZ1bmN0aW9uIGlzUGFyYWdyYXBoU3RhcnQoX3JlZjUpIHtcbiAgdmFyIHR5cGUgPSBfcmVmNS50eXBlLFxuICAgIHRhZyA9IF9yZWY1LnRhZyxcbiAgICBwb3NpdGlvbiA9IF9yZWY1LnBvc2l0aW9uO1xuICByZXR1cm4gW1widzpwXCIsIFwiYTpwXCIsIFwidGV4dDpwXCJdLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdHlwZSA9PT0gXCJ0YWdcIiAmJiBwb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xufVxuZnVuY3Rpb24gaXNQYXJhZ3JhcGhFbmQoX3JlZjYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmNi50eXBlLFxuICAgIHRhZyA9IF9yZWY2LnRhZyxcbiAgICBwb3NpdGlvbiA9IF9yZWY2LnBvc2l0aW9uO1xuICByZXR1cm4gW1widzpwXCIsIFwiYTpwXCIsIFwidGV4dDpwXCJdLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdHlwZSA9PT0gXCJ0YWdcIiAmJiBwb3NpdGlvbiA9PT0gXCJlbmRcIjtcbn1cbmZ1bmN0aW9uIGlzVGV4dFN0YXJ0KF9yZWY3KSB7XG4gIHZhciB0eXBlID0gX3JlZjcudHlwZSxcbiAgICBwb3NpdGlvbiA9IF9yZWY3LnBvc2l0aW9uLFxuICAgIHRleHQgPSBfcmVmNy50ZXh0O1xuICByZXR1cm4gdGV4dCAmJiB0eXBlID09PSBcInRhZ1wiICYmIHBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG59XG5mdW5jdGlvbiBpc1RleHRFbmQoX3JlZjgpIHtcbiAgdmFyIHR5cGUgPSBfcmVmOC50eXBlLFxuICAgIHBvc2l0aW9uID0gX3JlZjgucG9zaXRpb24sXG4gICAgdGV4dCA9IF9yZWY4LnRleHQ7XG4gIHJldHVybiB0ZXh0ICYmIHR5cGUgPT09IFwidGFnXCIgJiYgcG9zaXRpb24gPT09IFwiZW5kXCI7XG59XG5mdW5jdGlvbiBpc0NvbnRlbnQoX3JlZjkpIHtcbiAgdmFyIHR5cGUgPSBfcmVmOS50eXBlLFxuICAgIHBvc2l0aW9uID0gX3JlZjkucG9zaXRpb247XG4gIHJldHVybiB0eXBlID09PSBcInBsYWNlaG9sZGVyXCIgfHwgdHlwZSA9PT0gXCJjb250ZW50XCIgJiYgcG9zaXRpb24gPT09IFwiaW5zaWRldGFnXCI7XG59XG5mdW5jdGlvbiBpc01vZHVsZShfcmVmMCwgbW9kdWxlcykge1xuICB2YXIgbW9kdWxlID0gX3JlZjAubW9kdWxlLFxuICAgIHR5cGUgPSBfcmVmMC50eXBlO1xuICBpZiAoIShtb2R1bGVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgbW9kdWxlcyA9IFttb2R1bGVzXTtcbiAgfVxuICByZXR1cm4gdHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiICYmIG1vZHVsZXMuaW5kZXhPZihtb2R1bGUpICE9PSAtMTtcbn1cbi8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcblxudmFyIGNvcnJ1cHRDaGFyYWN0ZXJzID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRl0vZztcbi8qXG4gKiAwMCAgICBOVUwgJ1xcMCcgKG51bGwgY2hhcmFjdGVyKVxuICogMDEgICAgU09IIChzdGFydCBvZiBoZWFkaW5nKVxuICogMDIgICAgU1RYIChzdGFydCBvZiB0ZXh0KVxuICogMDMgICAgRVRYIChlbmQgb2YgdGV4dClcbiAqIDA0ICAgIEVPVCAoZW5kIG9mIHRyYW5zbWlzc2lvbilcbiAqIDA1ICAgIEVOUSAoZW5xdWlyeSlcbiAqIDA2ICAgIEFDSyAoYWNrbm93bGVkZ2UpXG4gKiAwNyAgICBCRUwgJ1xcYScgKGJlbGwpXG4gKiAwOCAgICBCUyAgJ1xcYicgKGJhY2tzcGFjZSlcbiAqIDBCICAgIFZUICAnXFx2JyAodmVydGljYWwgdGFiKVxuICogMEMgICAgRkYgICdcXGYnIChmb3JtIGZlZWQpXG4gKiAwRSAgICBTTyAgKHNoaWZ0IG91dClcbiAqIDBGICAgIFNJICAoc2hpZnQgaW4pXG4gKiAxMCAgICBETEUgKGRhdGEgbGluayBlc2NhcGUpXG4gKiAxMSAgICBEQzEgKGRldmljZSBjb250cm9sIDEpXG4gKiAxMiAgICBEQzIgKGRldmljZSBjb250cm9sIDIpXG4gKiAxMyAgICBEQzMgKGRldmljZSBjb250cm9sIDMpXG4gKiAxNCAgICBEQzQgKGRldmljZSBjb250cm9sIDQpXG4gKiAxNSAgICBOQUsgKG5lZ2F0aXZlIGFjay4pXG4gKiAxNiAgICBTWU4gKHN5bmNocm9ub3VzIGlkbGUpXG4gKiAxNyAgICBFVEIgKGVuZCBvZiB0cmFucy4gYmxrKVxuICogMTggICAgQ0FOIChjYW5jZWwpXG4gKiAxOSAgICBFTSAgKGVuZCBvZiBtZWRpdW0pXG4gKiAxQSAgICBTVUIgKHN1YnN0aXR1dGUpXG4gKiAxQiAgICBFU0MgKGVzY2FwZSlcbiAqIDFDICAgIEZTICAoZmlsZSBzZXBhcmF0b3IpXG4gKiAxRCAgICBHUyAgKGdyb3VwIHNlcGFyYXRvcilcbiAqIDFFICAgIFJTICAocmVjb3JkIHNlcGFyYXRvcilcbiAqIDFGICAgIFVTICAodW5pdCBzZXBhcmF0b3IpXG4gKi9cbmZ1bmN0aW9uIGhhc0NvcnJ1cHRDaGFyYWN0ZXJzKHN0cmluZykge1xuICBjb3JydXB0Q2hhcmFjdGVycy5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gY29ycnVwdENoYXJhY3RlcnMudGVzdChzdHJpbmcpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnMoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgc3RyaW5nID0gU3RyaW5nKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGNvcnJ1cHRDaGFyYWN0ZXJzLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGludmVydE1hcChtYXApIHtcbiAgdmFyIGludmVydGVkTWFwID0ge307XG4gIGZvciAodmFyIGtleSBpbiBtYXApIHtcbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICBpbnZlcnRlZE1hcFt2YWx1ZV0gfHwgKGludmVydGVkTWFwW3ZhbHVlXSA9IFtdKTtcbiAgICBpbnZlcnRlZE1hcFt2YWx1ZV0ucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBpbnZlcnRlZE1hcDtcbn1cbi8qXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgc29ydCBpcyBzdGFibGUuIFRoZSBkZWZhdWx0IEFycmF5LnNvcnQgb2YgdGhlIGJyb3dzZXJcbiAqIGlzIG5vdCBzdGFibGUgaW4gZmlyZWZveCwgYXMgdGhlIEpTIHNwZWMgZG9lcyBub3QgZW5mb3JjZSB0aGUgc29ydCB0byBiZVxuICogc3RhYmxlLlxuICovXG5mdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgY29tcGFyZSkge1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogaW4gcHJldmlvdXMgdmVyc2lvbnMgb2YgQ2hyb21lLCBzb3J0IHdhcyBub3Qgc3RhYmxlIGJ5IGl0c2VsZiwgc28gd2UgaGFkIHRvIGFkZCB0aGlzLiBUaGlzIGlzIHRvIHN1cHBvcnQgb2xkZXIgdmVyc2lvbnMgb2YgSlMgcnVubmVycy5cbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9O1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYS5pdGVtLCBiLml0ZW0pIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICB9KS5tYXAoZnVuY3Rpb24gKF9yZWYxKSB7XG4gICAgdmFyIGl0ZW0gPSBfcmVmMS5pdGVtO1xuICAgIHJldHVybiBpdGVtO1xuICB9KTtcbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgc3RhcnRzV2l0aDogc3RhcnRzV2l0aCxcbiAgaXNDb250ZW50OiBpc0NvbnRlbnQsXG4gIGlzUGFyYWdyYXBoU3RhcnQ6IGlzUGFyYWdyYXBoU3RhcnQsXG4gIGlzUGFyYWdyYXBoRW5kOiBpc1BhcmFncmFwaEVuZCxcbiAgaXNUYWdTdGFydDogaXNUYWdTdGFydCxcbiAgaXNUYWdFbmQ6IGlzVGFnRW5kLFxuICBpc1RleHRTdGFydDogaXNUZXh0U3RhcnQsXG4gIGlzVGV4dEVuZDogaXNUZXh0RW5kLFxuICBpc1N0YXJ0aW5nOiBpc1N0YXJ0aW5nLFxuICBpc0VuZGluZzogaXNFbmRpbmcsXG4gIGlzTW9kdWxlOiBpc01vZHVsZSxcbiAgdW5pcTogdW5pcSxcbiAgZ2V0RHVwbGljYXRlczogZ2V0RHVwbGljYXRlcyxcbiAgY2h1bmtCeTogY2h1bmtCeSxcbiAgbGFzdDogbGFzdCxcbiAgZmlyc3Q6IGZpcnN0LFxuICB4bWwyc3RyOiB4bWwyc3RyLFxuICBzdHIyeG1sOiBzdHIyeG1sLFxuICBnZXRSaWdodE9yTnVsbDogZ2V0UmlnaHRPck51bGwsXG4gIGdldFJpZ2h0OiBnZXRSaWdodCxcbiAgZ2V0TGVmdE9yTnVsbDogZ2V0TGVmdE9yTnVsbCxcbiAgZ2V0TGVmdDogZ2V0TGVmdCxcbiAgcHJlZ01hdGNoQWxsOiBwcmVnTWF0Y2hBbGwsXG4gIGNvbnZlcnRTcGFjZXM6IGNvbnZlcnRTcGFjZXMsXG4gIGNoYXJNYXBSZWdleGVzOiBjaGFyTWFwUmVnZXhlcyxcbiAgaGFzQ29ycnVwdENoYXJhY3RlcnM6IGhhc0NvcnJ1cHRDaGFyYWN0ZXJzLFxuICByZW1vdmVDb3JydXB0Q2hhcmFjdGVyczogcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnMsXG4gIGdldERlZmF1bHRzOiBnZXREZWZhdWx0cyxcbiAgd29yZFRvVXRmODogd29yZFRvVXRmOCxcbiAgdXRmOFRvV29yZDogdXRmOFRvV29yZCxcbiAgY29uY2F0QXJyYXlzOiBjb25jYXRBcnJheXMsXG4gIHB1c2hBcnJheTogcHVzaEFycmF5LFxuICBpbnZlcnRNYXA6IGludmVydE1hcCxcbiAgY2hhck1hcDogY2hhck1hcCxcbiAgZ2V0U2luZ2xlQXR0cmlidXRlOiBnZXRTaW5nbGVBdHRyaWJ1dGUsXG4gIHNldFNpbmdsZUF0dHJpYnV0ZTogc2V0U2luZ2xlQXR0cmlidXRlLFxuICBpc1doaXRlU3BhY2U6IGlzV2hpdGVTcGFjZSxcbiAgc3RhYmxlU29ydDogc3RhYmxlU29ydFxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/doc-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/docxtemplater.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/docxtemplater.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _excluded = [\"modules\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar DocUtils = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\");\nvar z = __webpack_require__(/*! ./minizod.js */ \"(rsc)/./node_modules/docxtemplater/js/minizod.js\");\n\n// Schema definitions for DXT.ConstructorOptions\nvar dxtSyntaxSchema = z.object({\n  allowUnopenedTag: z[\"boolean\"]().optional(),\n  allowUnclosedTag: z[\"boolean\"]().optional(),\n  allowUnbalancedLoops: z[\"boolean\"]().optional(),\n  changeDelimiterPrefix: z.string().optional().nullable()\n});\nvar dxtOptionsSchema = z.object({\n  delimiters: z.object({\n    start: z.string().nullable(),\n    end: z.string().nullable()\n  }).strict().optional(),\n  fileTypeConfig: z.object({}).optional(),\n  paragraphLoop: z[\"boolean\"]().optional(),\n  parser: z[\"function\"]().optional(),\n  errorLogging: z.union([z[\"boolean\"](), z.string()]).optional(),\n  linebreaks: z[\"boolean\"]().optional(),\n  nullGetter: z[\"function\"]().optional(),\n  syntax: dxtSyntaxSchema.optional(),\n  stripInvalidXMLChars: z[\"boolean\"]().optional(),\n  warnFn: z[\"function\"]().optional()\n}).strict();\nvar _require = __webpack_require__(/*! ./get-relation-types.js */ \"(rsc)/./node_modules/docxtemplater/js/get-relation-types.js\"),\n  getRelsTypes = _require.getRelsTypes;\nvar _require2 = __webpack_require__(/*! ./get-content-types.js */ \"(rsc)/./node_modules/docxtemplater/js/get-content-types.js\"),\n  collectContentTypes = _require2.collectContentTypes,\n  getContentTypes = _require2.getContentTypes;\nvar moduleWrapper = __webpack_require__(/*! ./module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar traits = __webpack_require__(/*! ./traits.js */ \"(rsc)/./node_modules/docxtemplater/js/traits.js\");\nvar commonModule = __webpack_require__(/*! ./modules/common.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/common.js\");\nvar createScope = __webpack_require__(/*! ./scope-manager.js */ \"(rsc)/./node_modules/docxtemplater/js/scope-manager.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(rsc)/./node_modules/docxtemplater/js/lexer.js\");\nvar _require3 = __webpack_require__(/*! ./get-tags.js */ \"(rsc)/./node_modules/docxtemplater/js/get-tags.js\"),\n  _getTags = _require3.getTags;\nvar logErrors = __webpack_require__(/*! ./error-logger.js */ \"(rsc)/./node_modules/docxtemplater/js/error-logger.js\");\nvar _require4 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  throwMultiError = _require4.throwMultiError,\n  throwResolveBeforeCompile = _require4.throwResolveBeforeCompile,\n  throwRenderInvalidTemplate = _require4.throwRenderInvalidTemplate,\n  throwRenderTwice = _require4.throwRenderTwice,\n  XTInternalError = _require4.XTInternalError,\n  XTTemplateError = _require4.XTTemplateError,\n  throwFileTypeNotIdentified = _require4.throwFileTypeNotIdentified,\n  throwFileTypeNotHandled = _require4.throwFileTypeNotHandled,\n  throwApiVersionError = _require4.throwApiVersionError;\nDocUtils.getRelsTypes = getRelsTypes;\nDocUtils.traits = traits;\nDocUtils.moduleWrapper = moduleWrapper;\nDocUtils.collectContentTypes = collectContentTypes;\nDocUtils.getContentTypes = getContentTypes;\nvar getDefaults = DocUtils.getDefaults,\n  str2xml = DocUtils.str2xml,\n  xml2str = DocUtils.xml2str,\n  concatArrays = DocUtils.concatArrays,\n  uniq = DocUtils.uniq,\n  getDuplicates = DocUtils.getDuplicates,\n  stableSort = DocUtils.stableSort,\n  pushArray = DocUtils.pushArray,\n  utf8ToWord = DocUtils.utf8ToWord,\n  invertMap = DocUtils.invertMap;\nvar ctXML = \"[Content_Types].xml\";\nvar relsFile = \"_rels/.rels\";\nvar currentModuleApiVersion = [3, 47, 2];\nfunction throwIfDuplicateModules(modules) {\n  var duplicates = getDuplicates(modules.map(function (_ref) {\n    var name = _ref.name;\n    return name;\n  }));\n  if (duplicates.length > 0) {\n    throw new XTInternalError(\"Detected duplicate module \\\"\".concat(duplicates[0], \"\\\"\"));\n  }\n}\nfunction addXmlFileNamesFromXmlContentType(doc) {\n  for (var _i2 = 0, _doc$modules2 = doc.modules; _i2 < _doc$modules2.length; _i2++) {\n    var _module = _doc$modules2[_i2];\n    for (var _i4 = 0, _ref3 = _module.xmlContentTypes || []; _i4 < _ref3.length; _i4++) {\n      var contentType = _ref3[_i4];\n      var candidates = doc.invertedContentTypes[contentType] || [];\n      for (var _i6 = 0; _i6 < candidates.length; _i6++) {\n        var candidate = candidates[_i6];\n        if (doc.zip.files[candidate]) {\n          doc.options.xmlFileNames.push(candidate);\n        }\n      }\n    }\n  }\n}\nfunction reorderModules(modules) {\n  /**\n   * Modules will be sorted according to priority.\n   *\n   * Input example:\n   * [\n   *   { priority: 1, name: \"FooMod\" },\n   *   { priority: -1, name: \"XMod\" },\n   *   { priority: 4, name: \"OtherMod\" }\n   * ]\n   *\n   * Output example (sorted by priority in descending order):\n   * [\n   *   { priority: 4, name: \"OtherMod\" },\n   *   { priority: 1, name: \"FooMod\" },\n   *   { priority: -1, name: \"XMod\" }\n   * ]\n   * Tested in #test-reorder-modules\n   */\n  return stableSort(modules, function (m1, m2) {\n    return (m2.priority || 0) - (m1.priority || 0);\n  });\n}\nfunction zipFileOrder(files) {\n  var allFiles = [];\n  for (var name in files) {\n    allFiles.push(name);\n  }\n  /*\n   * The first files that need to be put in the zip file are :\n   * [Content_Types].xml and _rels/.rels\n   */\n  var resultFiles = [ctXML, relsFile];\n\n  /*\n   * The next files that should be in the zip file are :\n   *\n   * - word/* (ie word/document.xml, word/header1.xml, ...)\n   * - xl/* (ie xl/worksheets/sheet1.xml)\n   * - ppt/* (ie ppt/slides/slide1.xml)\n   */\n  var prefixes = [\"word/\", \"xl/\", \"ppt/\"];\n  for (var _i8 = 0; _i8 < allFiles.length; _i8++) {\n    var _name = allFiles[_i8];\n    for (var _i0 = 0; _i0 < prefixes.length; _i0++) {\n      var prefix = prefixes[_i0];\n      if (_name.indexOf(\"\".concat(prefix)) === 0) {\n        resultFiles.push(_name);\n      }\n    }\n  }\n  /*\n   * Push the rest of files, such as docProps/core.xml and docProps/app.xml\n   */\n  for (var _i10 = 0; _i10 < allFiles.length; _i10++) {\n    var _name2 = allFiles[_i10];\n    if (resultFiles.indexOf(_name2) === -1) {\n      resultFiles.push(_name2);\n    }\n  }\n  return resultFiles;\n}\nfunction deprecatedMessage(obj, message) {\n  if (obj.hideDeprecations === true) {\n    return;\n  }\n  // eslint-disable-next-line no-console\n  console.warn(message);\n}\nfunction deprecatedMethod(obj, method) {\n  if (obj.hideDeprecations === true) {\n    return;\n  }\n  return deprecatedMessage(obj, \"Deprecated method \\\".\".concat(method, \"\\\", view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : \").concat(new Error().stack));\n}\nfunction dropUnsupportedFileTypesModules(doc) {\n  doc.modules = doc.modules.filter(function (module) {\n    if (!module.supportedFileTypes) {\n      return true;\n    }\n    if (!Array.isArray(module.supportedFileTypes)) {\n      throw new Error(\"The supportedFileTypes field of the module must be an array\");\n    }\n    var isSupportedModule = module.supportedFileTypes.includes(doc.fileType);\n    if (!isSupportedModule) {\n      module.on(\"detached\");\n    }\n    return isSupportedModule;\n  });\n}\nfunction verifyErrors(doc) {\n  var compiled = doc.compiled;\n  doc.errors = concatArrays(Object.keys(compiled).map(function (name) {\n    return compiled[name].allErrors;\n  }));\n  if (doc.errors.length !== 0) {\n    if (doc.options.errorLogging) {\n      logErrors(doc.errors, doc.options.errorLogging);\n    }\n    throwMultiError(doc.errors);\n  }\n}\nfunction isBuffer(v) {\n  return typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer === \"function\" && Buffer.isBuffer(v);\n}\nvar Docxtemplater = /*#__PURE__*/function () {\n  function Docxtemplater(zip) {\n    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref4$modules = _ref4.modules,\n      modules = _ref4$modules === void 0 ? [] : _ref4$modules,\n      options = _objectWithoutProperties(_ref4, _excluded);\n    _classCallCheck(this, Docxtemplater);\n    this.targets = [];\n    this.rendered = false;\n    this.scopeManagers = {};\n    this.compiled = {};\n    this.modules = [commonModule()];\n    this.xmlDocuments = {};\n    if (arguments.length === 0) {\n      deprecatedMessage(this, \"Deprecated docxtemplater constructor with no arguments, view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : \".concat(new Error().stack));\n      this.hideDeprecations = true;\n      this.setOptions(options);\n    } else {\n      this.hideDeprecations = true;\n      this.setOptions(options);\n      if (isBuffer(zip)) {\n        throw new Error(\"You passed a Buffer to the Docxtemplater constructor. The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n      }\n      if (!zip || !zip.files || typeof zip.file !== \"function\") {\n        throw new Error(\"The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n      }\n      if (!Array.isArray(modules)) {\n        throw new Error(\"The modules argument of docxtemplater's constructor must be an array\");\n      }\n      for (var _i12 = 0; _i12 < modules.length; _i12++) {\n        var _module2 = modules[_i12];\n        this.attachModule(_module2);\n      }\n      this.loadZip(zip);\n      this.compile();\n      this.v4Constructor = true;\n    }\n    this.hideDeprecations = false;\n  }\n  return _createClass(Docxtemplater, [{\n    key: \"verifyApiVersion\",\n    value: function verifyApiVersion(neededVersion) {\n      neededVersion = neededVersion.split(\".\").map(function (i) {\n        return parseInt(i, 10);\n      });\n      if (neededVersion.length !== 3) {\n        throwApiVersionError(\"neededVersion is not a valid version\", {\n          neededVersion: neededVersion,\n          explanation: \"the neededVersion must be an array of length 3\"\n        });\n      }\n      if (neededVersion[0] !== currentModuleApiVersion[0]) {\n        throwApiVersionError(\"The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] > currentModuleApiVersion[1]) {\n        throwApiVersionError(\"The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {\n        throwApiVersionError(\"The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      return true;\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      for (var _i14 = 0, _this$modules2 = this.modules; _i14 < _this$modules2.length; _i14++) {\n        var _module3 = _this$modules2[_i14];\n        _module3.set(obj);\n      }\n    }\n  }, {\n    key: \"sendEvent\",\n    value: function sendEvent(eventName) {\n      for (var _i16 = 0, _this$modules4 = this.modules; _i16 < _this$modules4.length; _i16++) {\n        var _module4 = _this$modules4[_i16];\n        _module4.on(eventName);\n      }\n    }\n  }, {\n    key: \"attachModule\",\n    value: function attachModule(module) {\n      if (this.v4Constructor) {\n        throw new XTInternalError(\"attachModule() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"attachModule\");\n      var moduleType = _typeof(module);\n      if (moduleType === \"function\") {\n        throw new XTInternalError(\"Cannot attach a class/function as a module. Most probably you forgot to instantiate the module by using `new` on the module.\");\n      }\n      if (!module || moduleType !== \"object\") {\n        throw new XTInternalError(\"Cannot attachModule with a falsy value\");\n      }\n      if (module.requiredAPIVersion) {\n        this.verifyApiVersion(module.requiredAPIVersion);\n      }\n      if (module.attached === true) {\n        if (typeof module.clone === \"function\") {\n          module = module.clone();\n        } else {\n          throw new Error(\"Cannot attach a module that was already attached : \\\"\".concat(module.name, \"\\\". The most likely cause is that you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater\"));\n        }\n      }\n      module.attached = true;\n      var wrappedModule = moduleWrapper(module);\n      this.modules.push(wrappedModule);\n      wrappedModule.on(\"attached\");\n      if (this.fileType) {\n        dropUnsupportedFileTypesModules(this);\n      }\n      return this;\n    }\n  }, {\n    key: \"findModule\",\n    value: function findModule(name) {\n      for (var _i18 = 0, _this$modules6 = this.modules; _i18 < _this$modules6.length; _i18++) {\n        var _module5 = _this$modules6[_i18];\n        if (_module5.name === name) {\n          return _module5;\n        }\n      }\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this$delimiters, _this$delimiters2;\n      if (this.v4Constructor) {\n        throw new Error(\"setOptions() should not be called manually when using the v4 constructor\");\n      }\n      if (!options) {\n        throw new Error(\"setOptions should be called with an object as first parameter\");\n      }\n      var result = dxtOptionsSchema.validate(options);\n      if (result.success === false) {\n        throw new Error(result.error);\n      }\n      deprecatedMethod(this, \"setOptions\");\n      this.options = {};\n      var defaults = getDefaults();\n      for (var key in defaults) {\n        var defaultValue = defaults[key];\n        this.options[key] = options[key] != null ? options[key] : this[key] || defaultValue;\n        this[key] = this.options[key];\n      }\n      (_this$delimiters = this.delimiters).start && (_this$delimiters.start = utf8ToWord(this.delimiters.start));\n      (_this$delimiters2 = this.delimiters).end && (_this$delimiters2.end = utf8ToWord(this.delimiters.end));\n      return this;\n    }\n  }, {\n    key: \"loadZip\",\n    value: function loadZip(zip) {\n      if (this.v4Constructor) {\n        throw new Error(\"loadZip() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"loadZip\");\n      if (zip.loadAsync) {\n        throw new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, please use pizzip\");\n      }\n      if (zip.xtRendered) {\n        this.options.warnFn([new Error(\"This zip file appears to be the outcome of a previous docxtemplater generation. This typically indicates that docxtemplater was integrated by reusing the same zip file. It is recommended to create a new Pizzip instance for each docxtemplater generation.\")]);\n      }\n      this.zip = zip;\n      this.updateFileTypeConfig();\n      this.modules = concatArrays([this.fileTypeConfig.baseModules.map(function (moduleFunction) {\n        return moduleFunction();\n      }), this.modules]);\n      for (var _i20 = 0, _this$modules8 = this.modules; _i20 < _this$modules8.length; _i20++) {\n        var _module6 = _this$modules8[_i20];\n        _module6.zip = this.zip;\n        _module6.docxtemplater = this;\n        _module6.fileTypeConfig = this.fileTypeConfig;\n        _module6.fileType = this.fileType;\n        _module6.xtOptions = this.options;\n        _module6.modules = this.modules;\n      }\n      dropUnsupportedFileTypesModules(this);\n      return this;\n    }\n  }, {\n    key: \"precompileFile\",\n    value: function precompileFile(fileName) {\n      var currentFile = this.createTemplateClass(fileName);\n      currentFile.preparse();\n      this.compiled[fileName] = currentFile;\n    }\n  }, {\n    key: \"compileFile\",\n    value: function compileFile(fileName) {\n      this.compiled[fileName].parse();\n    }\n  }, {\n    key: \"getScopeManager\",\n    value: function getScopeManager(to, currentFile, tags) {\n      var _this$scopeManagers;\n      (_this$scopeManagers = this.scopeManagers)[to] || (_this$scopeManagers[to] = createScope({\n        tags: tags,\n        parser: this.parser,\n        cachedParsers: currentFile.cachedParsers\n      }));\n      return this.scopeManagers[to];\n    }\n  }, {\n    key: \"resolveData\",\n    value: function resolveData(data) {\n      var _this = this;\n      deprecatedMethod(this, \"resolveData\");\n      var errors = [];\n      if (!Object.keys(this.compiled).length) {\n        throwResolveBeforeCompile();\n      }\n      return Promise.resolve(data).then(function (data) {\n        _this.data = data;\n        _this.setModules({\n          data: _this.data,\n          Lexer: Lexer\n        });\n        _this.mapper = _this.modules.reduce(function (value, module) {\n          return module.getRenderedMap(value);\n        }, {});\n        return Promise.all(Object.keys(_this.mapper).map(function (to) {\n          var _this$mapper$to = _this.mapper[to],\n            from = _this$mapper$to.from,\n            data = _this$mapper$to.data;\n          return Promise.resolve(data).then(function (data) {\n            var currentFile = _this.compiled[from];\n            currentFile.filePath = to;\n            currentFile.scopeManager = _this.getScopeManager(to, currentFile, data);\n            return currentFile.resolveTags(data).then(function (result) {\n              currentFile.scopeManager.finishedResolving = true;\n              return result;\n            }, function (errs) {\n              pushArray(errors, errs);\n            });\n          });\n        })).then(function (resolved) {\n          if (errors.length !== 0) {\n            if (_this.options.errorLogging) {\n              logErrors(errors, _this.options.errorLogging);\n            }\n            throwMultiError(errors);\n          }\n          return concatArrays(resolved);\n        });\n      });\n    }\n  }, {\n    key: \"compile\",\n    value: function compile() {\n      deprecatedMethod(this, \"compile\");\n      this.updateFileTypeConfig();\n      throwIfDuplicateModules(this.modules);\n      this.modules = reorderModules(this.modules);\n      if (Object.keys(this.compiled).length) {\n        return this;\n      }\n      var options = this.options;\n      for (var _i22 = 0, _this$modules0 = this.modules; _i22 < _this$modules0.length; _i22++) {\n        var _module7 = _this$modules0[_i22];\n        options = _module7.optionsTransformer(options, this);\n      }\n      this.options = options;\n      this.options.xmlFileNames = uniq(this.options.xmlFileNames);\n      for (var _i24 = 0, _this$options$xmlFile2 = this.options.xmlFileNames; _i24 < _this$options$xmlFile2.length; _i24++) {\n        var fileName = _this$options$xmlFile2[_i24];\n        var content = this.zip.files[fileName].asText();\n        this.xmlDocuments[fileName] = str2xml(content);\n      }\n      this.setModules({\n        zip: this.zip,\n        xmlDocuments: this.xmlDocuments\n      });\n      for (var _i26 = 0, _this$modules10 = this.modules; _i26 < _this$modules10.length; _i26++) {\n        var _module8 = _this$modules10[_i26];\n        _module8.xmlDocuments = this.xmlDocuments;\n      }\n      this.getTemplatedFiles();\n      /*\n       * Loop inside all templatedFiles (ie xml files with content).\n       * Sometimes they don't exist (footer.xml for example)\n       */\n      this.sendEvent(\"before-preparse\");\n      for (var _i28 = 0, _this$templatedFiles2 = this.templatedFiles; _i28 < _this$templatedFiles2.length; _i28++) {\n        var _fileName = _this$templatedFiles2[_i28];\n        if (this.zip.files[_fileName] != null) {\n          this.precompileFile(_fileName);\n        }\n      }\n      this.sendEvent(\"after-preparse\");\n      for (var _i30 = 0, _this$templatedFiles4 = this.templatedFiles; _i30 < _this$templatedFiles4.length; _i30++) {\n        var _fileName2 = _this$templatedFiles4[_i30];\n        if (this.zip.files[_fileName2] != null) {\n          this.compiled[_fileName2].parse({\n            noPostParse: true\n          });\n        }\n      }\n      this.sendEvent(\"after-parse\");\n      for (var _i32 = 0, _this$templatedFiles6 = this.templatedFiles; _i32 < _this$templatedFiles6.length; _i32++) {\n        var _fileName3 = _this$templatedFiles6[_i32];\n        if (this.zip.files[_fileName3] != null) {\n          this.compiled[_fileName3].postparse();\n        }\n      }\n      this.sendEvent(\"after-postparse\");\n      this.setModules({\n        compiled: this.compiled\n      });\n      verifyErrors(this);\n      return this;\n    }\n  }, {\n    key: \"updateFileTypeConfig\",\n    value: function updateFileTypeConfig() {\n      this.relsTypes = getRelsTypes(this.zip);\n      var _getContentTypes = getContentTypes(this.zip),\n        overrides = _getContentTypes.overrides,\n        defaults = _getContentTypes.defaults,\n        contentTypes = _getContentTypes.contentTypes,\n        contentTypeXml = _getContentTypes.contentTypeXml;\n      if (contentTypeXml) {\n        this.filesContentTypes = collectContentTypes(overrides, defaults, this.zip);\n        this.invertedContentTypes = invertMap(this.filesContentTypes);\n        this.setModules({\n          contentTypes: this.contentTypes,\n          invertedContentTypes: this.invertedContentTypes\n        });\n      }\n      var fileType;\n      if (this.zip.files.mimetype) {\n        fileType = \"odt\";\n      }\n      for (var _i34 = 0, _this$modules12 = this.modules; _i34 < _this$modules12.length; _i34++) {\n        var _module9 = _this$modules12[_i34];\n        fileType = _module9.getFileType({\n          zip: this.zip,\n          contentTypes: contentTypes,\n          contentTypeXml: contentTypeXml,\n          overrides: overrides,\n          defaults: defaults,\n          doc: this\n        }) || fileType;\n      }\n      this.fileType = fileType;\n      if (fileType === \"odt\") {\n        throwFileTypeNotHandled(fileType);\n      }\n      if (!fileType) {\n        throwFileTypeNotIdentified(this.zip);\n      }\n      addXmlFileNamesFromXmlContentType(this);\n      dropUnsupportedFileTypesModules(this);\n      this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig;\n      if (!this.fileTypeConfig) {\n        if (Docxtemplater.FileTypeConfig[this.fileType]) {\n          this.fileTypeConfig = Docxtemplater.FileTypeConfig[this.fileType]();\n        } else {\n          /*\n           * Error case handled since v3.60.2\n           * Throw specific error when trying to template xlsx file without xlsxmodule\n           */\n          var message = \"Filetype \\\"\".concat(this.fileType, \"\\\" is not supported\");\n          var id = \"filetype_not_supported\";\n          if (this.fileType === \"xlsx\") {\n            message = \"Filetype \\\"\".concat(this.fileType, \"\\\" is supported only with the paid XlsxModule\");\n            id = \"xlsx_filetype_needs_xlsx_module\";\n          }\n          var err = new XTTemplateError(message);\n          err.properties = {\n            id: id,\n            explanation: message\n          };\n          throw err;\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"renderAsync\",\n    value: function renderAsync(data) {\n      var _this2 = this;\n      this.hideDeprecations = true;\n      var promise = this.resolveData(data);\n      this.hideDeprecations = false;\n      this.zip.xtRendered = true;\n      return promise.then(function () {\n        return _this2.render();\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(data) {\n      this.zip.xtRendered = true;\n      if (this.rendered) {\n        throwRenderTwice();\n      }\n      this.rendered = true;\n      if (Object.keys(this.compiled).length === 0) {\n        this.compile();\n      }\n      if (this.errors.length > 0) {\n        throwRenderInvalidTemplate();\n      }\n      if (arguments.length > 0) {\n        this.data = data;\n      }\n      this.setModules({\n        data: this.data,\n        Lexer: Lexer\n      });\n      this.mapper || (this.mapper = this.modules.reduce(function (value, module) {\n        return module.getRenderedMap(value);\n      }, {}));\n      var output = [];\n      for (var to in this.mapper) {\n        var _this$mapper$to2 = this.mapper[to],\n          from = _this$mapper$to2.from,\n          _data = _this$mapper$to2.data;\n        var currentFile = this.compiled[from];\n        currentFile.scopeManager = this.getScopeManager(to, currentFile, _data);\n        currentFile.render(to);\n        output.push([to, currentFile.content, currentFile]);\n        delete currentFile.content;\n      }\n      for (var _i36 = 0; _i36 < output.length; _i36++) {\n        var outputPart = output[_i36];\n        var _outputPart = _slicedToArray(outputPart, 3),\n          content = _outputPart[1],\n          _currentFile = _outputPart[2];\n        for (var _i38 = 0, _this$modules14 = this.modules; _i38 < _this$modules14.length; _i38++) {\n          var _module0 = _this$modules14[_i38];\n          if (_module0.preZip) {\n            var result = _module0.preZip(content, _currentFile);\n            if (typeof result === \"string\") {\n              outputPart[1] = result;\n            }\n          }\n        }\n      }\n      for (var _i40 = 0; _i40 < output.length; _i40++) {\n        var _output$_i = _slicedToArray(output[_i40], 2),\n          _to = _output$_i[0],\n          _content = _output$_i[1];\n        this.zip.file(_to, _content, {\n          createFolders: true\n        });\n      }\n      verifyErrors(this);\n      this.sendEvent(\"syncing-zip\");\n      this.syncZip();\n      // The synced-zip event is used in the subtemplate module for example\n      this.sendEvent(\"synced-zip\");\n      return this;\n    }\n  }, {\n    key: \"syncZip\",\n    value: function syncZip() {\n      for (var fileName in this.xmlDocuments) {\n        this.zip.remove(fileName);\n        var content = xml2str(this.xmlDocuments[fileName]);\n        this.zip.file(fileName, content, {\n          createFolders: true\n        });\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      deprecatedMethod(this, \"setData\");\n      this.data = data;\n      return this;\n    }\n  }, {\n    key: \"getZip\",\n    value: function getZip() {\n      return this.zip;\n    }\n  }, {\n    key: \"createTemplateClass\",\n    value: function createTemplateClass(path) {\n      var content = this.zip.files[path].asText();\n      return this.createTemplateClassFromContent(content, path);\n    }\n  }, {\n    key: \"createTemplateClassFromContent\",\n    value: function createTemplateClassFromContent(content, filePath) {\n      var xmltOptions = {\n        filePath: filePath,\n        contentType: this.filesContentTypes[filePath],\n        relsType: this.relsTypes[filePath]\n      };\n      var defaults = getDefaults();\n      var defaultKeys = pushArray(Object.keys(defaults), [\"filesContentTypes\", \"fileTypeConfig\", \"fileType\", \"modules\"]);\n      for (var _i42 = 0; _i42 < defaultKeys.length; _i42++) {\n        var key = defaultKeys[_i42];\n        xmltOptions[key] = this[key];\n      }\n      return new Docxtemplater.XmlTemplater(content, xmltOptions);\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText(path) {\n      return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();\n    }\n  }, {\n    key: \"getTemplatedFiles\",\n    value: function getTemplatedFiles() {\n      this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n      pushArray(this.templatedFiles, this.targets);\n      var templatedNs = this.fileTypeConfig.templatedNs || [];\n      if (templatedNs.length > 0) {\n        for (var key in this.filesContentTypes) {\n          if (/^customXml\\/item\\d+\\.xml$/.test(key)) {\n            for (var _i44 = 0; _i44 < templatedNs.length; _i44++) {\n              var ns = templatedNs[_i44];\n              var text = this.zip.file(key).asText();\n              if (text.indexOf(\"xmlns=\\\"\".concat(ns, \"\\\"\")) !== -1) {\n                this.templatedFiles.push(key);\n              }\n            }\n          }\n        }\n      }\n      this.templatedFiles = uniq(this.templatedFiles);\n      return this.templatedFiles;\n    }\n  }, {\n    key: \"getTags\",\n    value: function getTags() {\n      var result = {\n        headers: [],\n        footers: []\n      };\n      for (var key in this.compiled) {\n        var contentType = this.filesContentTypes[key];\n        if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\") {\n          result.document = {\n            target: key,\n            tags: _getTags(this.compiled[key].postparsed)\n          };\n        }\n        if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\") {\n          result.headers.push({\n            target: key,\n            tags: _getTags(this.compiled[key].postparsed)\n          });\n        }\n        if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\") {\n          result.footers.push({\n            target: key,\n            tags: _getTags(this.compiled[key].postparsed)\n          });\n        }\n      }\n      return result;\n    }\n\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"nodebuffer\"\n      }));\n    }\n\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toBlob\",\n    value: function toBlob(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"blob\"\n      }));\n    }\n\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toBase64\",\n    value: function toBase64(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"base64\"\n      }));\n    }\n\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"uint8array\"\n      }));\n    }\n\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toArrayBuffer\",\n    value: function toArrayBuffer(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"arraybuffer\"\n      }));\n    }\n  }]);\n}();\nDocxtemplater.DocUtils = DocUtils;\nDocxtemplater.Errors = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\");\nDocxtemplater.XmlTemplater = __webpack_require__(/*! ./xml-templater.js */ \"(rsc)/./node_modules/docxtemplater/js/xml-templater.js\");\nDocxtemplater.FileTypeConfig = __webpack_require__(/*! ./file-type-config.js */ \"(rsc)/./node_modules/docxtemplater/js/file-type-config.js\");\nDocxtemplater.XmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(rsc)/./node_modules/docxtemplater/js/xml-matcher.js\");\nmodule.exports = Docxtemplater;\nmodule.exports[\"default\"] = Docxtemplater;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2N4dGVtcGxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5QixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUywwQ0FBMEMsMEJBQTBCLG1EQUFtRCxvQ0FBb0MseUNBQXlDLFlBQVksY0FBYyx3Q0FBd0MscURBQXFEO0FBQzNULCtDQUErQywwQkFBMEIsWUFBWSx1QkFBdUIsOEJBQThCLG1DQUFtQyxlQUFlO0FBQzVMLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDLFFBQVEsbUJBQU8sQ0FBQyxzRUFBYzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWUsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDaEQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBd0I7QUFDaEQ7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFxQjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsb0VBQWE7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGtGQUFvQjtBQUM5QyxZQUFZLG1CQUFPLENBQUMsa0VBQVk7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQWU7QUFDdkM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw0QkFBNEI7QUFDN0U7QUFDQSw2REFBNkQsb0JBQW9CO0FBQ2pGO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QjtBQUN0QyxTQUFTLDRCQUE0QjtBQUNyQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtCQUErQjtBQUN4QyxTQUFTLDZCQUE2QjtBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3REFBd0QsOEJBQThCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3REFBd0QsOEJBQThCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0RBQXdELDhCQUE4QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0RBQXdELDhCQUE4QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDhCQUE4QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHNDQUFzQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxxQ0FBcUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHFDQUFxQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UscUNBQXFDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwrQkFBK0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwrQkFBK0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGNBQWM7QUFDckI7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sY0FBYztBQUNyQjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxjQUFjO0FBQ3JCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGNBQWM7QUFDckI7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sY0FBYztBQUNyQjtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxvRUFBYTtBQUM1Qyw2QkFBNkIsbUJBQU8sQ0FBQyxrRkFBb0I7QUFDekQsK0JBQStCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQzlELDJCQUEyQixtQkFBTyxDQUFDLDhFQUFrQjtBQUNyRDtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jeHRlbXBsYXRlci5qcz85NGEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wibW9kdWxlc1wiXTtcbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkgeyBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307IHZhciBvLCByLCBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIG8gPSBuW3JdLCAtMSA9PT0gdC5pbmRleE9mKG8pICYmIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgbykgJiYgKGlbb10gPSBlW29dKTsgfSByZXR1cm4gaTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkgeyBpZiAobnVsbCA9PSByKSByZXR1cm4ge307IHZhciB0ID0ge307IGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHsgaWYgKC0xICE9PSBlLmluZGV4T2YobikpIGNvbnRpbnVlOyB0W25dID0gcltuXTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIERvY1V0aWxzID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpO1xudmFyIHogPSByZXF1aXJlKFwiLi9taW5pem9kLmpzXCIpO1xuXG4vLyBTY2hlbWEgZGVmaW5pdGlvbnMgZm9yIERYVC5Db25zdHJ1Y3Rvck9wdGlvbnNcbnZhciBkeHRTeW50YXhTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGFsbG93VW5vcGVuZWRUYWc6IHpbXCJib29sZWFuXCJdKCkub3B0aW9uYWwoKSxcbiAgYWxsb3dVbmNsb3NlZFRhZzogeltcImJvb2xlYW5cIl0oKS5vcHRpb25hbCgpLFxuICBhbGxvd1VuYmFsYW5jZWRMb29wczogeltcImJvb2xlYW5cIl0oKS5vcHRpb25hbCgpLFxuICBjaGFuZ2VEZWxpbWl0ZXJQcmVmaXg6IHouc3RyaW5nKCkub3B0aW9uYWwoKS5udWxsYWJsZSgpXG59KTtcbnZhciBkeHRPcHRpb25zU2NoZW1hID0gei5vYmplY3Qoe1xuICBkZWxpbWl0ZXJzOiB6Lm9iamVjdCh7XG4gICAgc3RhcnQ6IHouc3RyaW5nKCkubnVsbGFibGUoKSxcbiAgICBlbmQ6IHouc3RyaW5nKCkubnVsbGFibGUoKVxuICB9KS5zdHJpY3QoKS5vcHRpb25hbCgpLFxuICBmaWxlVHlwZUNvbmZpZzogei5vYmplY3Qoe30pLm9wdGlvbmFsKCksXG4gIHBhcmFncmFwaExvb3A6IHpbXCJib29sZWFuXCJdKCkub3B0aW9uYWwoKSxcbiAgcGFyc2VyOiB6W1wiZnVuY3Rpb25cIl0oKS5vcHRpb25hbCgpLFxuICBlcnJvckxvZ2dpbmc6IHoudW5pb24oW3pbXCJib29sZWFuXCJdKCksIHouc3RyaW5nKCldKS5vcHRpb25hbCgpLFxuICBsaW5lYnJlYWtzOiB6W1wiYm9vbGVhblwiXSgpLm9wdGlvbmFsKCksXG4gIG51bGxHZXR0ZXI6IHpbXCJmdW5jdGlvblwiXSgpLm9wdGlvbmFsKCksXG4gIHN5bnRheDogZHh0U3ludGF4U2NoZW1hLm9wdGlvbmFsKCksXG4gIHN0cmlwSW52YWxpZFhNTENoYXJzOiB6W1wiYm9vbGVhblwiXSgpLm9wdGlvbmFsKCksXG4gIHdhcm5GbjogeltcImZ1bmN0aW9uXCJdKCkub3B0aW9uYWwoKVxufSkuc3RyaWN0KCk7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9nZXQtcmVsYXRpb24tdHlwZXMuanNcIiksXG4gIGdldFJlbHNUeXBlcyA9IF9yZXF1aXJlLmdldFJlbHNUeXBlcztcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9nZXQtY29udGVudC10eXBlcy5qc1wiKSxcbiAgY29sbGVjdENvbnRlbnRUeXBlcyA9IF9yZXF1aXJlMi5jb2xsZWN0Q29udGVudFR5cGVzLFxuICBnZXRDb250ZW50VHlwZXMgPSBfcmVxdWlyZTIuZ2V0Q29udGVudFR5cGVzO1xudmFyIG1vZHVsZVdyYXBwZXIgPSByZXF1aXJlKFwiLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciB0cmFpdHMgPSByZXF1aXJlKFwiLi90cmFpdHMuanNcIik7XG52YXIgY29tbW9uTW9kdWxlID0gcmVxdWlyZShcIi4vbW9kdWxlcy9jb21tb24uanNcIik7XG52YXIgY3JlYXRlU2NvcGUgPSByZXF1aXJlKFwiLi9zY29wZS1tYW5hZ2VyLmpzXCIpO1xudmFyIExleGVyID0gcmVxdWlyZShcIi4vbGV4ZXIuanNcIik7XG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZShcIi4vZ2V0LXRhZ3MuanNcIiksXG4gIF9nZXRUYWdzID0gX3JlcXVpcmUzLmdldFRhZ3M7XG52YXIgbG9nRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3ItbG9nZ2VyLmpzXCIpO1xudmFyIF9yZXF1aXJlNCA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgdGhyb3dNdWx0aUVycm9yID0gX3JlcXVpcmU0LnRocm93TXVsdGlFcnJvcixcbiAgdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSA9IF9yZXF1aXJlNC50aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlLFxuICB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSA9IF9yZXF1aXJlNC50aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSxcbiAgdGhyb3dSZW5kZXJUd2ljZSA9IF9yZXF1aXJlNC50aHJvd1JlbmRlclR3aWNlLFxuICBYVEludGVybmFsRXJyb3IgPSBfcmVxdWlyZTQuWFRJbnRlcm5hbEVycm9yLFxuICBYVFRlbXBsYXRlRXJyb3IgPSBfcmVxdWlyZTQuWFRUZW1wbGF0ZUVycm9yLFxuICB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCA9IF9yZXF1aXJlNC50aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCxcbiAgdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQgPSBfcmVxdWlyZTQudGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQsXG4gIHRocm93QXBpVmVyc2lvbkVycm9yID0gX3JlcXVpcmU0LnRocm93QXBpVmVyc2lvbkVycm9yO1xuRG9jVXRpbHMuZ2V0UmVsc1R5cGVzID0gZ2V0UmVsc1R5cGVzO1xuRG9jVXRpbHMudHJhaXRzID0gdHJhaXRzO1xuRG9jVXRpbHMubW9kdWxlV3JhcHBlciA9IG1vZHVsZVdyYXBwZXI7XG5Eb2NVdGlscy5jb2xsZWN0Q29udGVudFR5cGVzID0gY29sbGVjdENvbnRlbnRUeXBlcztcbkRvY1V0aWxzLmdldENvbnRlbnRUeXBlcyA9IGdldENvbnRlbnRUeXBlcztcbnZhciBnZXREZWZhdWx0cyA9IERvY1V0aWxzLmdldERlZmF1bHRzLFxuICBzdHIyeG1sID0gRG9jVXRpbHMuc3RyMnhtbCxcbiAgeG1sMnN0ciA9IERvY1V0aWxzLnhtbDJzdHIsXG4gIGNvbmNhdEFycmF5cyA9IERvY1V0aWxzLmNvbmNhdEFycmF5cyxcbiAgdW5pcSA9IERvY1V0aWxzLnVuaXEsXG4gIGdldER1cGxpY2F0ZXMgPSBEb2NVdGlscy5nZXREdXBsaWNhdGVzLFxuICBzdGFibGVTb3J0ID0gRG9jVXRpbHMuc3RhYmxlU29ydCxcbiAgcHVzaEFycmF5ID0gRG9jVXRpbHMucHVzaEFycmF5LFxuICB1dGY4VG9Xb3JkID0gRG9jVXRpbHMudXRmOFRvV29yZCxcbiAgaW52ZXJ0TWFwID0gRG9jVXRpbHMuaW52ZXJ0TWFwO1xudmFyIGN0WE1MID0gXCJbQ29udGVudF9UeXBlc10ueG1sXCI7XG52YXIgcmVsc0ZpbGUgPSBcIl9yZWxzLy5yZWxzXCI7XG52YXIgY3VycmVudE1vZHVsZUFwaVZlcnNpb24gPSBbMywgNDcsIDJdO1xuZnVuY3Rpb24gdGhyb3dJZkR1cGxpY2F0ZU1vZHVsZXMobW9kdWxlcykge1xuICB2YXIgZHVwbGljYXRlcyA9IGdldER1cGxpY2F0ZXMobW9kdWxlcy5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfSkpO1xuICBpZiAoZHVwbGljYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcIkRldGVjdGVkIGR1cGxpY2F0ZSBtb2R1bGUgXFxcIlwiLmNvbmNhdChkdXBsaWNhdGVzWzBdLCBcIlxcXCJcIikpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRYbWxGaWxlTmFtZXNGcm9tWG1sQ29udGVudFR5cGUoZG9jKSB7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9kb2MkbW9kdWxlczIgPSBkb2MubW9kdWxlczsgX2kyIDwgX2RvYyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBfZG9jJG1vZHVsZXMyW19pMl07XG4gICAgZm9yICh2YXIgX2k0ID0gMCwgX3JlZjMgPSBfbW9kdWxlLnhtbENvbnRlbnRUeXBlcyB8fCBbXTsgX2k0IDwgX3JlZjMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gX3JlZjNbX2k0XTtcbiAgICAgIHZhciBjYW5kaWRhdGVzID0gZG9jLmludmVydGVkQ29udGVudFR5cGVzW2NvbnRlbnRUeXBlXSB8fCBbXTtcbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tfaTZdO1xuICAgICAgICBpZiAoZG9jLnppcC5maWxlc1tjYW5kaWRhdGVdKSB7XG4gICAgICAgICAgZG9jLm9wdGlvbnMueG1sRmlsZU5hbWVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVvcmRlck1vZHVsZXMobW9kdWxlcykge1xuICAvKipcbiAgICogTW9kdWxlcyB3aWxsIGJlIHNvcnRlZCBhY2NvcmRpbmcgdG8gcHJpb3JpdHkuXG4gICAqXG4gICAqIElucHV0IGV4YW1wbGU6XG4gICAqIFtcbiAgICogICB7IHByaW9yaXR5OiAxLCBuYW1lOiBcIkZvb01vZFwiIH0sXG4gICAqICAgeyBwcmlvcml0eTogLTEsIG5hbWU6IFwiWE1vZFwiIH0sXG4gICAqICAgeyBwcmlvcml0eTogNCwgbmFtZTogXCJPdGhlck1vZFwiIH1cbiAgICogXVxuICAgKlxuICAgKiBPdXRwdXQgZXhhbXBsZSAoc29ydGVkIGJ5IHByaW9yaXR5IGluIGRlc2NlbmRpbmcgb3JkZXIpOlxuICAgKiBbXG4gICAqICAgeyBwcmlvcml0eTogNCwgbmFtZTogXCJPdGhlck1vZFwiIH0sXG4gICAqICAgeyBwcmlvcml0eTogMSwgbmFtZTogXCJGb29Nb2RcIiB9LFxuICAgKiAgIHsgcHJpb3JpdHk6IC0xLCBuYW1lOiBcIlhNb2RcIiB9XG4gICAqIF1cbiAgICogVGVzdGVkIGluICN0ZXN0LXJlb3JkZXItbW9kdWxlc1xuICAgKi9cbiAgcmV0dXJuIHN0YWJsZVNvcnQobW9kdWxlcywgZnVuY3Rpb24gKG0xLCBtMikge1xuICAgIHJldHVybiAobTIucHJpb3JpdHkgfHwgMCkgLSAobTEucHJpb3JpdHkgfHwgMCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gemlwRmlsZU9yZGVyKGZpbGVzKSB7XG4gIHZhciBhbGxGaWxlcyA9IFtdO1xuICBmb3IgKHZhciBuYW1lIGluIGZpbGVzKSB7XG4gICAgYWxsRmlsZXMucHVzaChuYW1lKTtcbiAgfVxuICAvKlxuICAgKiBUaGUgZmlyc3QgZmlsZXMgdGhhdCBuZWVkIHRvIGJlIHB1dCBpbiB0aGUgemlwIGZpbGUgYXJlIDpcbiAgICogW0NvbnRlbnRfVHlwZXNdLnhtbCBhbmQgX3JlbHMvLnJlbHNcbiAgICovXG4gIHZhciByZXN1bHRGaWxlcyA9IFtjdFhNTCwgcmVsc0ZpbGVdO1xuXG4gIC8qXG4gICAqIFRoZSBuZXh0IGZpbGVzIHRoYXQgc2hvdWxkIGJlIGluIHRoZSB6aXAgZmlsZSBhcmUgOlxuICAgKlxuICAgKiAtIHdvcmQvKiAoaWUgd29yZC9kb2N1bWVudC54bWwsIHdvcmQvaGVhZGVyMS54bWwsIC4uLilcbiAgICogLSB4bC8qIChpZSB4bC93b3Jrc2hlZXRzL3NoZWV0MS54bWwpXG4gICAqIC0gcHB0LyogKGllIHBwdC9zbGlkZXMvc2xpZGUxLnhtbClcbiAgICovXG4gIHZhciBwcmVmaXhlcyA9IFtcIndvcmQvXCIsIFwieGwvXCIsIFwicHB0L1wiXTtcbiAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgYWxsRmlsZXMubGVuZ3RoOyBfaTgrKykge1xuICAgIHZhciBfbmFtZSA9IGFsbEZpbGVzW19pOF07XG4gICAgZm9yICh2YXIgX2kwID0gMDsgX2kwIDwgcHJlZml4ZXMubGVuZ3RoOyBfaTArKykge1xuICAgICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW19pMF07XG4gICAgICBpZiAoX25hbWUuaW5kZXhPZihcIlwiLmNvbmNhdChwcmVmaXgpKSA9PT0gMCkge1xuICAgICAgICByZXN1bHRGaWxlcy5wdXNoKF9uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLypcbiAgICogUHVzaCB0aGUgcmVzdCBvZiBmaWxlcywgc3VjaCBhcyBkb2NQcm9wcy9jb3JlLnhtbCBhbmQgZG9jUHJvcHMvYXBwLnhtbFxuICAgKi9cbiAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBhbGxGaWxlcy5sZW5ndGg7IF9pMTArKykge1xuICAgIHZhciBfbmFtZTIgPSBhbGxGaWxlc1tfaTEwXTtcbiAgICBpZiAocmVzdWx0RmlsZXMuaW5kZXhPZihfbmFtZTIpID09PSAtMSkge1xuICAgICAgcmVzdWx0RmlsZXMucHVzaChfbmFtZTIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0RmlsZXM7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkTWVzc2FnZShvYmosIG1lc3NhZ2UpIHtcbiAgaWYgKG9iai5oaWRlRGVwcmVjYXRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWRNZXRob2Qob2JqLCBtZXRob2QpIHtcbiAgaWYgKG9iai5oaWRlRGVwcmVjYXRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBkZXByZWNhdGVkTWVzc2FnZShvYmosIFwiRGVwcmVjYXRlZCBtZXRob2QgXFxcIi5cIi5jb25jYXQobWV0aG9kLCBcIlxcXCIsIHZpZXcgdXBncmFkZSBndWlkZSA6IGh0dHBzOi8vZG9jeHRlbXBsYXRlci5jb20vZG9jcy9hcGkvI3VwZ3JhZGUtZ3VpZGUsIHN0YWNrIDogXCIpLmNvbmNhdChuZXcgRXJyb3IoKS5zdGFjaykpO1xufVxuZnVuY3Rpb24gZHJvcFVuc3VwcG9ydGVkRmlsZVR5cGVzTW9kdWxlcyhkb2MpIHtcbiAgZG9jLm1vZHVsZXMgPSBkb2MubW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIGlmICghbW9kdWxlLnN1cHBvcnRlZEZpbGVUeXBlcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGUuc3VwcG9ydGVkRmlsZVR5cGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN1cHBvcnRlZEZpbGVUeXBlcyBmaWVsZCBvZiB0aGUgbW9kdWxlIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gICAgfVxuICAgIHZhciBpc1N1cHBvcnRlZE1vZHVsZSA9IG1vZHVsZS5zdXBwb3J0ZWRGaWxlVHlwZXMuaW5jbHVkZXMoZG9jLmZpbGVUeXBlKTtcbiAgICBpZiAoIWlzU3VwcG9ydGVkTW9kdWxlKSB7XG4gICAgICBtb2R1bGUub24oXCJkZXRhY2hlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkTW9kdWxlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUVycm9ycyhkb2MpIHtcbiAgdmFyIGNvbXBpbGVkID0gZG9jLmNvbXBpbGVkO1xuICBkb2MuZXJyb3JzID0gY29uY2F0QXJyYXlzKE9iamVjdC5rZXlzKGNvbXBpbGVkKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gY29tcGlsZWRbbmFtZV0uYWxsRXJyb3JzO1xuICB9KSk7XG4gIGlmIChkb2MuZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChkb2Mub3B0aW9ucy5lcnJvckxvZ2dpbmcpIHtcbiAgICAgIGxvZ0Vycm9ycyhkb2MuZXJyb3JzLCBkb2Mub3B0aW9ucy5lcnJvckxvZ2dpbmcpO1xuICAgIH1cbiAgICB0aHJvd011bHRpRXJyb3IoZG9jLmVycm9ycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIEJ1ZmZlci5pc0J1ZmZlcih2KTtcbn1cbnZhciBEb2N4dGVtcGxhdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRG9jeHRlbXBsYXRlcih6aXApIHtcbiAgICB2YXIgX3JlZjQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZjQkbW9kdWxlcyA9IF9yZWY0Lm1vZHVsZXMsXG4gICAgICBtb2R1bGVzID0gX3JlZjQkbW9kdWxlcyA9PT0gdm9pZCAwID8gW10gOiBfcmVmNCRtb2R1bGVzLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNCwgX2V4Y2x1ZGVkKTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9jeHRlbXBsYXRlcik7XG4gICAgdGhpcy50YXJnZXRzID0gW107XG4gICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2NvcGVNYW5hZ2VycyA9IHt9O1xuICAgIHRoaXMuY29tcGlsZWQgPSB7fTtcbiAgICB0aGlzLm1vZHVsZXMgPSBbY29tbW9uTW9kdWxlKCldO1xuICAgIHRoaXMueG1sRG9jdW1lbnRzID0ge307XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlcHJlY2F0ZWRNZXNzYWdlKHRoaXMsIFwiRGVwcmVjYXRlZCBkb2N4dGVtcGxhdGVyIGNvbnN0cnVjdG9yIHdpdGggbm8gYXJndW1lbnRzLCB2aWV3IHVwZ3JhZGUgZ3VpZGUgOiBodHRwczovL2RvY3h0ZW1wbGF0ZXIuY29tL2RvY3MvYXBpLyN1cGdyYWRlLWd1aWRlLCBzdGFjayA6IFwiLmNvbmNhdChuZXcgRXJyb3IoKS5zdGFjaykpO1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGlmIChpc0J1ZmZlcih6aXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBwYXNzZWQgYSBCdWZmZXIgdG8gdGhlIERvY3h0ZW1wbGF0ZXIgY29uc3RydWN0b3IuIFRoZSBmaXJzdCBhcmd1bWVudCBvZiBkb2N4dGVtcGxhdGVyJ3MgY29uc3RydWN0b3IgbXVzdCBiZSBhIHZhbGlkIHppcCBmaWxlIChqc3ppcCB2MiBvciBwaXp6aXAgdjMpXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF6aXAgfHwgIXppcC5maWxlcyB8fCB0eXBlb2YgemlwLmZpbGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgb2YgZG9jeHRlbXBsYXRlcidzIGNvbnN0cnVjdG9yIG11c3QgYmUgYSB2YWxpZCB6aXAgZmlsZSAoanN6aXAgdjIgb3IgcGl6emlwIHYzKVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbW9kdWxlcyBhcmd1bWVudCBvZiBkb2N4dGVtcGxhdGVyJ3MgY29uc3RydWN0b3IgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbW9kdWxlcy5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgICB2YXIgX21vZHVsZTIgPSBtb2R1bGVzW19pMTJdO1xuICAgICAgICB0aGlzLmF0dGFjaE1vZHVsZShfbW9kdWxlMik7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRaaXAoemlwKTtcbiAgICAgIHRoaXMuY29tcGlsZSgpO1xuICAgICAgdGhpcy52NENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEb2N4dGVtcGxhdGVyLCBbe1xuICAgIGtleTogXCJ2ZXJpZnlBcGlWZXJzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeUFwaVZlcnNpb24obmVlZGVkVmVyc2lvbikge1xuICAgICAgbmVlZGVkVmVyc2lvbiA9IG5lZWRlZFZlcnNpb24uc3BsaXQoXCIuXCIpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaSwgMTApO1xuICAgICAgfSk7XG4gICAgICBpZiAobmVlZGVkVmVyc2lvbi5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3dBcGlWZXJzaW9uRXJyb3IoXCJuZWVkZWRWZXJzaW9uIGlzIG5vdCBhIHZhbGlkIHZlcnNpb25cIiwge1xuICAgICAgICAgIG5lZWRlZFZlcnNpb246IG5lZWRlZFZlcnNpb24sXG4gICAgICAgICAgZXhwbGFuYXRpb246IFwidGhlIG5lZWRlZFZlcnNpb24gbXVzdCBiZSBhbiBhcnJheSBvZiBsZW5ndGggM1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRlZFZlcnNpb25bMF0gIT09IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uWzBdKSB7XG4gICAgICAgIHRocm93QXBpVmVyc2lvbkVycm9yKFwiVGhlIG1ham9yIGFwaSB2ZXJzaW9uIGRvIG5vdCBtYXRjaCwgeW91IHByb2JhYmx5IGhhdmUgdG8gdXBkYXRlIGRvY3h0ZW1wbGF0ZXIgd2l0aCBucG0gaW5zdGFsbCAtLXNhdmUgZG9jeHRlbXBsYXRlclwiLCB7XG4gICAgICAgICAgbmVlZGVkVmVyc2lvbjogbmVlZGVkVmVyc2lvbixcbiAgICAgICAgICBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbjogY3VycmVudE1vZHVsZUFwaVZlcnNpb24sXG4gICAgICAgICAgZXhwbGFuYXRpb246IFwibW9kdWxlQVBJVmVyc2lvbk1pc21hdGNoIDogbmVlZGVkPVwiLmNvbmNhdChuZWVkZWRWZXJzaW9uLmpvaW4oXCIuXCIpLCBcIiwgY3VycmVudD1cIikuY29uY2F0KGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLmpvaW4oXCIuXCIpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkZWRWZXJzaW9uWzFdID4gY3VycmVudE1vZHVsZUFwaVZlcnNpb25bMV0pIHtcbiAgICAgICAgdGhyb3dBcGlWZXJzaW9uRXJyb3IoXCJUaGUgbWlub3IgYXBpIHZlcnNpb24gaXMgbm90IHVwdG9kYXRlLCB5b3UgcHJvYmFibHkgaGF2ZSB0byB1cGRhdGUgZG9jeHRlbXBsYXRlciB3aXRoIG5wbSBpbnN0YWxsIC0tc2F2ZSBkb2N4dGVtcGxhdGVyXCIsIHtcbiAgICAgICAgICBuZWVkZWRWZXJzaW9uOiBuZWVkZWRWZXJzaW9uLFxuICAgICAgICAgIGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uOiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbixcbiAgICAgICAgICBleHBsYW5hdGlvbjogXCJtb2R1bGVBUElWZXJzaW9uTWlzbWF0Y2ggOiBuZWVkZWQ9XCIuY29uY2F0KG5lZWRlZFZlcnNpb24uam9pbihcIi5cIiksIFwiLCBjdXJyZW50PVwiKS5jb25jYXQoY3VycmVudE1vZHVsZUFwaVZlcnNpb24uam9pbihcIi5cIikpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRlZFZlcnNpb25bMV0gPT09IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uWzFdICYmIG5lZWRlZFZlcnNpb25bMl0gPiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvblsyXSkge1xuICAgICAgICB0aHJvd0FwaVZlcnNpb25FcnJvcihcIlRoZSBwYXRjaCBhcGkgdmVyc2lvbiBpcyBub3QgdXB0b2RhdGUsIHlvdSBwcm9iYWJseSBoYXZlIHRvIHVwZGF0ZSBkb2N4dGVtcGxhdGVyIHdpdGggbnBtIGluc3RhbGwgLS1zYXZlIGRvY3h0ZW1wbGF0ZXJcIiwge1xuICAgICAgICAgIG5lZWRlZFZlcnNpb246IG5lZWRlZFZlcnNpb24sXG4gICAgICAgICAgY3VycmVudE1vZHVsZUFwaVZlcnNpb246IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBcIm1vZHVsZUFQSVZlcnNpb25NaXNtYXRjaCA6IG5lZWRlZD1cIi5jb25jYXQobmVlZGVkVmVyc2lvbi5qb2luKFwiLlwiKSwgXCIsIGN1cnJlbnQ9XCIpLmNvbmNhdChjdXJyZW50TW9kdWxlQXBpVmVyc2lvbi5qb2luKFwiLlwiKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TW9kdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNb2R1bGVzKG9iaikge1xuICAgICAgZm9yICh2YXIgX2kxNCA9IDAsIF90aGlzJG1vZHVsZXMyID0gdGhpcy5tb2R1bGVzOyBfaTE0IDwgX3RoaXMkbW9kdWxlczIubGVuZ3RoOyBfaTE0KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGUzID0gX3RoaXMkbW9kdWxlczJbX2kxNF07XG4gICAgICAgIF9tb2R1bGUzLnNldChvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZEV2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgZm9yICh2YXIgX2kxNiA9IDAsIF90aGlzJG1vZHVsZXM0ID0gdGhpcy5tb2R1bGVzOyBfaTE2IDwgX3RoaXMkbW9kdWxlczQubGVuZ3RoOyBfaTE2KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU0ID0gX3RoaXMkbW9kdWxlczRbX2kxNl07XG4gICAgICAgIF9tb2R1bGU0Lm9uKGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0dGFjaE1vZHVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hNb2R1bGUobW9kdWxlKSB7XG4gICAgICBpZiAodGhpcy52NENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBYVEludGVybmFsRXJyb3IoXCJhdHRhY2hNb2R1bGUoKSBzaG91bGQgbm90IGJlIGNhbGxlZCBtYW51YWxseSB3aGVuIHVzaW5nIHRoZSB2NCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgIH1cbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJhdHRhY2hNb2R1bGVcIik7XG4gICAgICB2YXIgbW9kdWxlVHlwZSA9IF90eXBlb2YobW9kdWxlKTtcbiAgICAgIGlmIChtb2R1bGVUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcIkNhbm5vdCBhdHRhY2ggYSBjbGFzcy9mdW5jdGlvbiBhcyBhIG1vZHVsZS4gTW9zdCBwcm9iYWJseSB5b3UgZm9yZ290IHRvIGluc3RhbnRpYXRlIHRoZSBtb2R1bGUgYnkgdXNpbmcgYG5ld2Agb24gdGhlIG1vZHVsZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAoIW1vZHVsZSB8fCBtb2R1bGVUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBYVEludGVybmFsRXJyb3IoXCJDYW5ub3QgYXR0YWNoTW9kdWxlIHdpdGggYSBmYWxzeSB2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2R1bGUucmVxdWlyZWRBUElWZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5QXBpVmVyc2lvbihtb2R1bGUucmVxdWlyZWRBUElWZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2R1bGUuYXR0YWNoZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUuY2xvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIG1vZHVsZSA9IG1vZHVsZS5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggYSBtb2R1bGUgdGhhdCB3YXMgYWxyZWFkeSBhdHRhY2hlZCA6IFxcXCJcIi5jb25jYXQobW9kdWxlLm5hbWUsIFwiXFxcIi4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIGlzIHRoYXQgeW91IGFyZSBpbnN0YW50aWF0aW5nIHRoZSBtb2R1bGUgYXQgdGhlIHJvb3QgbGV2ZWwsIGFuZCB1c2luZyBpdCBmb3IgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIERvY3h0ZW1wbGF0ZXJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb2R1bGUuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdmFyIHdyYXBwZWRNb2R1bGUgPSBtb2R1bGVXcmFwcGVyKG1vZHVsZSk7XG4gICAgICB0aGlzLm1vZHVsZXMucHVzaCh3cmFwcGVkTW9kdWxlKTtcbiAgICAgIHdyYXBwZWRNb2R1bGUub24oXCJhdHRhY2hlZFwiKTtcbiAgICAgIGlmICh0aGlzLmZpbGVUeXBlKSB7XG4gICAgICAgIGRyb3BVbnN1cHBvcnRlZEZpbGVUeXBlc01vZHVsZXModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZE1vZHVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTW9kdWxlKG5hbWUpIHtcbiAgICAgIGZvciAodmFyIF9pMTggPSAwLCBfdGhpcyRtb2R1bGVzNiA9IHRoaXMubW9kdWxlczsgX2kxOCA8IF90aGlzJG1vZHVsZXM2Lmxlbmd0aDsgX2kxOCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlNSA9IF90aGlzJG1vZHVsZXM2W19pMThdO1xuICAgICAgICBpZiAoX21vZHVsZTUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiBfbW9kdWxlNTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzJGRlbGltaXRlcnMsIF90aGlzJGRlbGltaXRlcnMyO1xuICAgICAgaWYgKHRoaXMudjRDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRPcHRpb25zKCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgd2hlbiB1c2luZyB0aGUgdjQgY29uc3RydWN0b3JcIik7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0T3B0aW9ucyBzaG91bGQgYmUgY2FsbGVkIHdpdGggYW4gb2JqZWN0IGFzIGZpcnN0IHBhcmFtZXRlclwiKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBkeHRPcHRpb25zU2NoZW1hLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yKTtcbiAgICAgIH1cbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJzZXRPcHRpb25zXCIpO1xuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB2YXIgZGVmYXVsdHMgPSBnZXREZWZhdWx0cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBkZWZhdWx0c1trZXldO1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XSAhPSBudWxsID8gb3B0aW9uc1trZXldIDogdGhpc1trZXldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpc1trZXldID0gdGhpcy5vcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgICAoX3RoaXMkZGVsaW1pdGVycyA9IHRoaXMuZGVsaW1pdGVycykuc3RhcnQgJiYgKF90aGlzJGRlbGltaXRlcnMuc3RhcnQgPSB1dGY4VG9Xb3JkKHRoaXMuZGVsaW1pdGVycy5zdGFydCkpO1xuICAgICAgKF90aGlzJGRlbGltaXRlcnMyID0gdGhpcy5kZWxpbWl0ZXJzKS5lbmQgJiYgKF90aGlzJGRlbGltaXRlcnMyLmVuZCA9IHV0ZjhUb1dvcmQodGhpcy5kZWxpbWl0ZXJzLmVuZCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFppcCh6aXApIHtcbiAgICAgIGlmICh0aGlzLnY0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFppcCgpIHNob3VsZCBub3QgYmUgY2FsbGVkIG1hbnVhbGx5IHdoZW4gdXNpbmcgdGhlIHY0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgfVxuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcImxvYWRaaXBcIik7XG4gICAgICBpZiAoemlwLmxvYWRBc3luYykge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiRG9jeHRlbXBsYXRlciBkb2Vzbid0IGhhbmRsZSBKU1ppcCB2ZXJzaW9uID49MywgcGxlYXNlIHVzZSBwaXp6aXBcIik7XG4gICAgICB9XG4gICAgICBpZiAoemlwLnh0UmVuZGVyZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLndhcm5GbihbbmV3IEVycm9yKFwiVGhpcyB6aXAgZmlsZSBhcHBlYXJzIHRvIGJlIHRoZSBvdXRjb21lIG9mIGEgcHJldmlvdXMgZG9jeHRlbXBsYXRlciBnZW5lcmF0aW9uLiBUaGlzIHR5cGljYWxseSBpbmRpY2F0ZXMgdGhhdCBkb2N4dGVtcGxhdGVyIHdhcyBpbnRlZ3JhdGVkIGJ5IHJldXNpbmcgdGhlIHNhbWUgemlwIGZpbGUuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGNyZWF0ZSBhIG5ldyBQaXp6aXAgaW5zdGFuY2UgZm9yIGVhY2ggZG9jeHRlbXBsYXRlciBnZW5lcmF0aW9uLlwiKV0pO1xuICAgICAgfVxuICAgICAgdGhpcy56aXAgPSB6aXA7XG4gICAgICB0aGlzLnVwZGF0ZUZpbGVUeXBlQ29uZmlnKCk7XG4gICAgICB0aGlzLm1vZHVsZXMgPSBjb25jYXRBcnJheXMoW3RoaXMuZmlsZVR5cGVDb25maWcuYmFzZU1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGVGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gbW9kdWxlRnVuY3Rpb24oKTtcbiAgICAgIH0pLCB0aGlzLm1vZHVsZXNdKTtcbiAgICAgIGZvciAodmFyIF9pMjAgPSAwLCBfdGhpcyRtb2R1bGVzOCA9IHRoaXMubW9kdWxlczsgX2kyMCA8IF90aGlzJG1vZHVsZXM4Lmxlbmd0aDsgX2kyMCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlNiA9IF90aGlzJG1vZHVsZXM4W19pMjBdO1xuICAgICAgICBfbW9kdWxlNi56aXAgPSB0aGlzLnppcDtcbiAgICAgICAgX21vZHVsZTYuZG9jeHRlbXBsYXRlciA9IHRoaXM7XG4gICAgICAgIF9tb2R1bGU2LmZpbGVUeXBlQ29uZmlnID0gdGhpcy5maWxlVHlwZUNvbmZpZztcbiAgICAgICAgX21vZHVsZTYuZmlsZVR5cGUgPSB0aGlzLmZpbGVUeXBlO1xuICAgICAgICBfbW9kdWxlNi54dE9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIF9tb2R1bGU2Lm1vZHVsZXMgPSB0aGlzLm1vZHVsZXM7XG4gICAgICB9XG4gICAgICBkcm9wVW5zdXBwb3J0ZWRGaWxlVHlwZXNNb2R1bGVzKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZWNvbXBpbGVGaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWNvbXBpbGVGaWxlKGZpbGVOYW1lKSB7XG4gICAgICB2YXIgY3VycmVudEZpbGUgPSB0aGlzLmNyZWF0ZVRlbXBsYXRlQ2xhc3MoZmlsZU5hbWUpO1xuICAgICAgY3VycmVudEZpbGUucHJlcGFyc2UoKTtcbiAgICAgIHRoaXMuY29tcGlsZWRbZmlsZU5hbWVdID0gY3VycmVudEZpbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBpbGVGaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGVGaWxlKGZpbGVOYW1lKSB7XG4gICAgICB0aGlzLmNvbXBpbGVkW2ZpbGVOYW1lXS5wYXJzZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTY29wZU1hbmFnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NvcGVNYW5hZ2VyKHRvLCBjdXJyZW50RmlsZSwgdGFncykge1xuICAgICAgdmFyIF90aGlzJHNjb3BlTWFuYWdlcnM7XG4gICAgICAoX3RoaXMkc2NvcGVNYW5hZ2VycyA9IHRoaXMuc2NvcGVNYW5hZ2VycylbdG9dIHx8IChfdGhpcyRzY29wZU1hbmFnZXJzW3RvXSA9IGNyZWF0ZVNjb3BlKHtcbiAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgcGFyc2VyOiB0aGlzLnBhcnNlcixcbiAgICAgICAgY2FjaGVkUGFyc2VyczogY3VycmVudEZpbGUuY2FjaGVkUGFyc2Vyc1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHRoaXMuc2NvcGVNYW5hZ2Vyc1t0b107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVEYXRhKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBkZXByZWNhdGVkTWV0aG9kKHRoaXMsIFwicmVzb2x2ZURhdGFcIik7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuY29tcGlsZWQpLmxlbmd0aCkge1xuICAgICAgICB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIF90aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICAgIGRhdGE6IF90aGlzLmRhdGEsXG4gICAgICAgICAgTGV4ZXI6IExleGVyXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5tYXBwZXIgPSBfdGhpcy5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIG1vZHVsZSkge1xuICAgICAgICAgIHJldHVybiBtb2R1bGUuZ2V0UmVuZGVyZWRNYXAodmFsdWUpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfdGhpcy5tYXBwZXIpLm1hcChmdW5jdGlvbiAodG8pIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWFwcGVyJHRvID0gX3RoaXMubWFwcGVyW3RvXSxcbiAgICAgICAgICAgIGZyb20gPSBfdGhpcyRtYXBwZXIkdG8uZnJvbSxcbiAgICAgICAgICAgIGRhdGEgPSBfdGhpcyRtYXBwZXIkdG8uZGF0YTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RmlsZSA9IF90aGlzLmNvbXBpbGVkW2Zyb21dO1xuICAgICAgICAgICAgY3VycmVudEZpbGUuZmlsZVBhdGggPSB0bztcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLnNjb3BlTWFuYWdlciA9IF90aGlzLmdldFNjb3BlTWFuYWdlcih0bywgY3VycmVudEZpbGUsIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRGaWxlLnJlc29sdmVUYWdzKGRhdGEpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICBjdXJyZW50RmlsZS5zY29wZU1hbmFnZXIuZmluaXNoZWRSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycnMpIHtcbiAgICAgICAgICAgICAgcHVzaEFycmF5KGVycm9ycywgZXJycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmVycm9yTG9nZ2luZykge1xuICAgICAgICAgICAgICBsb2dFcnJvcnMoZXJyb3JzLCBfdGhpcy5vcHRpb25zLmVycm9yTG9nZ2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd011bHRpRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdEFycmF5cyhyZXNvbHZlZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZSgpIHtcbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJjb21waWxlXCIpO1xuICAgICAgdGhpcy51cGRhdGVGaWxlVHlwZUNvbmZpZygpO1xuICAgICAgdGhyb3dJZkR1cGxpY2F0ZU1vZHVsZXModGhpcy5tb2R1bGVzKTtcbiAgICAgIHRoaXMubW9kdWxlcyA9IHJlb3JkZXJNb2R1bGVzKHRoaXMubW9kdWxlcyk7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBmb3IgKHZhciBfaTIyID0gMCwgX3RoaXMkbW9kdWxlczAgPSB0aGlzLm1vZHVsZXM7IF9pMjIgPCBfdGhpcyRtb2R1bGVzMC5sZW5ndGg7IF9pMjIrKykge1xuICAgICAgICB2YXIgX21vZHVsZTcgPSBfdGhpcyRtb2R1bGVzMFtfaTIyXTtcbiAgICAgICAgb3B0aW9ucyA9IF9tb2R1bGU3Lm9wdGlvbnNUcmFuc2Zvcm1lcihvcHRpb25zLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLm9wdGlvbnMueG1sRmlsZU5hbWVzID0gdW5pcSh0aGlzLm9wdGlvbnMueG1sRmlsZU5hbWVzKTtcbiAgICAgIGZvciAodmFyIF9pMjQgPSAwLCBfdGhpcyRvcHRpb25zJHhtbEZpbGUyID0gdGhpcy5vcHRpb25zLnhtbEZpbGVOYW1lczsgX2kyNCA8IF90aGlzJG9wdGlvbnMkeG1sRmlsZTIubGVuZ3RoOyBfaTI0KyspIHtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gX3RoaXMkb3B0aW9ucyR4bWxGaWxlMltfaTI0XTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnppcC5maWxlc1tmaWxlTmFtZV0uYXNUZXh0KCk7XG4gICAgICAgIHRoaXMueG1sRG9jdW1lbnRzW2ZpbGVOYW1lXSA9IHN0cjJ4bWwoY29udGVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICB6aXA6IHRoaXMuemlwLFxuICAgICAgICB4bWxEb2N1bWVudHM6IHRoaXMueG1sRG9jdW1lbnRzXG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIF9pMjYgPSAwLCBfdGhpcyRtb2R1bGVzMTAgPSB0aGlzLm1vZHVsZXM7IF9pMjYgPCBfdGhpcyRtb2R1bGVzMTAubGVuZ3RoOyBfaTI2KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU4ID0gX3RoaXMkbW9kdWxlczEwW19pMjZdO1xuICAgICAgICBfbW9kdWxlOC54bWxEb2N1bWVudHMgPSB0aGlzLnhtbERvY3VtZW50cztcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0VGVtcGxhdGVkRmlsZXMoKTtcbiAgICAgIC8qXG4gICAgICAgKiBMb29wIGluc2lkZSBhbGwgdGVtcGxhdGVkRmlsZXMgKGllIHhtbCBmaWxlcyB3aXRoIGNvbnRlbnQpLlxuICAgICAgICogU29tZXRpbWVzIHRoZXkgZG9uJ3QgZXhpc3QgKGZvb3Rlci54bWwgZm9yIGV4YW1wbGUpXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc2VuZEV2ZW50KFwiYmVmb3JlLXByZXBhcnNlXCIpO1xuICAgICAgZm9yICh2YXIgX2kyOCA9IDAsIF90aGlzJHRlbXBsYXRlZEZpbGVzMiA9IHRoaXMudGVtcGxhdGVkRmlsZXM7IF9pMjggPCBfdGhpcyR0ZW1wbGF0ZWRGaWxlczIubGVuZ3RoOyBfaTI4KyspIHtcbiAgICAgICAgdmFyIF9maWxlTmFtZSA9IF90aGlzJHRlbXBsYXRlZEZpbGVzMltfaTI4XTtcbiAgICAgICAgaWYgKHRoaXMuemlwLmZpbGVzW19maWxlTmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucHJlY29tcGlsZUZpbGUoX2ZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZW5kRXZlbnQoXCJhZnRlci1wcmVwYXJzZVwiKTtcbiAgICAgIGZvciAodmFyIF9pMzAgPSAwLCBfdGhpcyR0ZW1wbGF0ZWRGaWxlczQgPSB0aGlzLnRlbXBsYXRlZEZpbGVzOyBfaTMwIDwgX3RoaXMkdGVtcGxhdGVkRmlsZXM0Lmxlbmd0aDsgX2kzMCsrKSB7XG4gICAgICAgIHZhciBfZmlsZU5hbWUyID0gX3RoaXMkdGVtcGxhdGVkRmlsZXM0W19pMzBdO1xuICAgICAgICBpZiAodGhpcy56aXAuZmlsZXNbX2ZpbGVOYW1lMl0gIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY29tcGlsZWRbX2ZpbGVOYW1lMl0ucGFyc2Uoe1xuICAgICAgICAgICAgbm9Qb3N0UGFyc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZW5kRXZlbnQoXCJhZnRlci1wYXJzZVwiKTtcbiAgICAgIGZvciAodmFyIF9pMzIgPSAwLCBfdGhpcyR0ZW1wbGF0ZWRGaWxlczYgPSB0aGlzLnRlbXBsYXRlZEZpbGVzOyBfaTMyIDwgX3RoaXMkdGVtcGxhdGVkRmlsZXM2Lmxlbmd0aDsgX2kzMisrKSB7XG4gICAgICAgIHZhciBfZmlsZU5hbWUzID0gX3RoaXMkdGVtcGxhdGVkRmlsZXM2W19pMzJdO1xuICAgICAgICBpZiAodGhpcy56aXAuZmlsZXNbX2ZpbGVOYW1lM10gIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY29tcGlsZWRbX2ZpbGVOYW1lM10ucG9zdHBhcnNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VuZEV2ZW50KFwiYWZ0ZXItcG9zdHBhcnNlXCIpO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgY29tcGlsZWQ6IHRoaXMuY29tcGlsZWRcbiAgICAgIH0pO1xuICAgICAgdmVyaWZ5RXJyb3JzKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUZpbGVUeXBlQ29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUZpbGVUeXBlQ29uZmlnKCkge1xuICAgICAgdGhpcy5yZWxzVHlwZXMgPSBnZXRSZWxzVHlwZXModGhpcy56aXApO1xuICAgICAgdmFyIF9nZXRDb250ZW50VHlwZXMgPSBnZXRDb250ZW50VHlwZXModGhpcy56aXApLFxuICAgICAgICBvdmVycmlkZXMgPSBfZ2V0Q29udGVudFR5cGVzLm92ZXJyaWRlcyxcbiAgICAgICAgZGVmYXVsdHMgPSBfZ2V0Q29udGVudFR5cGVzLmRlZmF1bHRzLFxuICAgICAgICBjb250ZW50VHlwZXMgPSBfZ2V0Q29udGVudFR5cGVzLmNvbnRlbnRUeXBlcyxcbiAgICAgICAgY29udGVudFR5cGVYbWwgPSBfZ2V0Q29udGVudFR5cGVzLmNvbnRlbnRUeXBlWG1sO1xuICAgICAgaWYgKGNvbnRlbnRUeXBlWG1sKSB7XG4gICAgICAgIHRoaXMuZmlsZXNDb250ZW50VHlwZXMgPSBjb2xsZWN0Q29udGVudFR5cGVzKG92ZXJyaWRlcywgZGVmYXVsdHMsIHRoaXMuemlwKTtcbiAgICAgICAgdGhpcy5pbnZlcnRlZENvbnRlbnRUeXBlcyA9IGludmVydE1hcCh0aGlzLmZpbGVzQ29udGVudFR5cGVzKTtcbiAgICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgICBjb250ZW50VHlwZXM6IHRoaXMuY29udGVudFR5cGVzLFxuICAgICAgICAgIGludmVydGVkQ29udGVudFR5cGVzOiB0aGlzLmludmVydGVkQ29udGVudFR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGZpbGVUeXBlO1xuICAgICAgaWYgKHRoaXMuemlwLmZpbGVzLm1pbWV0eXBlKSB7XG4gICAgICAgIGZpbGVUeXBlID0gXCJvZHRcIjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMzQgPSAwLCBfdGhpcyRtb2R1bGVzMTIgPSB0aGlzLm1vZHVsZXM7IF9pMzQgPCBfdGhpcyRtb2R1bGVzMTIubGVuZ3RoOyBfaTM0KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU5ID0gX3RoaXMkbW9kdWxlczEyW19pMzRdO1xuICAgICAgICBmaWxlVHlwZSA9IF9tb2R1bGU5LmdldEZpbGVUeXBlKHtcbiAgICAgICAgICB6aXA6IHRoaXMuemlwLFxuICAgICAgICAgIGNvbnRlbnRUeXBlczogY29udGVudFR5cGVzLFxuICAgICAgICAgIGNvbnRlbnRUeXBlWG1sOiBjb250ZW50VHlwZVhtbCxcbiAgICAgICAgICBvdmVycmlkZXM6IG92ZXJyaWRlcyxcbiAgICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgICAgZG9jOiB0aGlzXG4gICAgICAgIH0pIHx8IGZpbGVUeXBlO1xuICAgICAgfVxuICAgICAgdGhpcy5maWxlVHlwZSA9IGZpbGVUeXBlO1xuICAgICAgaWYgKGZpbGVUeXBlID09PSBcIm9kdFwiKSB7XG4gICAgICAgIHRocm93RmlsZVR5cGVOb3RIYW5kbGVkKGZpbGVUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZmlsZVR5cGUpIHtcbiAgICAgICAgdGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQodGhpcy56aXApO1xuICAgICAgfVxuICAgICAgYWRkWG1sRmlsZU5hbWVzRnJvbVhtbENvbnRlbnRUeXBlKHRoaXMpO1xuICAgICAgZHJvcFVuc3VwcG9ydGVkRmlsZVR5cGVzTW9kdWxlcyh0aGlzKTtcbiAgICAgIHRoaXMuZmlsZVR5cGVDb25maWcgPSB0aGlzLm9wdGlvbnMuZmlsZVR5cGVDb25maWcgfHwgdGhpcy5maWxlVHlwZUNvbmZpZztcbiAgICAgIGlmICghdGhpcy5maWxlVHlwZUNvbmZpZykge1xuICAgICAgICBpZiAoRG9jeHRlbXBsYXRlci5GaWxlVHlwZUNvbmZpZ1t0aGlzLmZpbGVUeXBlXSkge1xuICAgICAgICAgIHRoaXMuZmlsZVR5cGVDb25maWcgPSBEb2N4dGVtcGxhdGVyLkZpbGVUeXBlQ29uZmlnW3RoaXMuZmlsZVR5cGVdKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBFcnJvciBjYXNlIGhhbmRsZWQgc2luY2UgdjMuNjAuMlxuICAgICAgICAgICAqIFRocm93IHNwZWNpZmljIGVycm9yIHdoZW4gdHJ5aW5nIHRvIHRlbXBsYXRlIHhsc3ggZmlsZSB3aXRob3V0IHhsc3htb2R1bGVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRmlsZXR5cGUgXFxcIlwiLmNvbmNhdCh0aGlzLmZpbGVUeXBlLCBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICB2YXIgaWQgPSBcImZpbGV0eXBlX25vdF9zdXBwb3J0ZWRcIjtcbiAgICAgICAgICBpZiAodGhpcy5maWxlVHlwZSA9PT0gXCJ4bHN4XCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkZpbGV0eXBlIFxcXCJcIi5jb25jYXQodGhpcy5maWxlVHlwZSwgXCJcXFwiIGlzIHN1cHBvcnRlZCBvbmx5IHdpdGggdGhlIHBhaWQgWGxzeE1vZHVsZVwiKTtcbiAgICAgICAgICAgIGlkID0gXCJ4bHN4X2ZpbGV0eXBlX25lZWRzX3hsc3hfbW9kdWxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZXhwbGFuYXRpb246IG1lc3NhZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckFzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckFzeW5jKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gdHJ1ZTtcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5yZXNvbHZlRGF0YShkYXRhKTtcbiAgICAgIHRoaXMuaGlkZURlcHJlY2F0aW9ucyA9IGZhbHNlO1xuICAgICAgdGhpcy56aXAueHRSZW5kZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKGRhdGEpIHtcbiAgICAgIHRoaXMuemlwLnh0UmVuZGVyZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgICAgICAgdGhyb3dSZW5kZXJUd2ljZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuY29tcGlsZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICBMZXhlcjogTGV4ZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXBwZXIgfHwgKHRoaXMubWFwcGVyID0gdGhpcy5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmdldFJlbmRlcmVkTWFwKHZhbHVlKTtcbiAgICAgIH0sIHt9KSk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICBmb3IgKHZhciB0byBpbiB0aGlzLm1hcHBlcikge1xuICAgICAgICB2YXIgX3RoaXMkbWFwcGVyJHRvMiA9IHRoaXMubWFwcGVyW3RvXSxcbiAgICAgICAgICBmcm9tID0gX3RoaXMkbWFwcGVyJHRvMi5mcm9tLFxuICAgICAgICAgIF9kYXRhID0gX3RoaXMkbWFwcGVyJHRvMi5kYXRhO1xuICAgICAgICB2YXIgY3VycmVudEZpbGUgPSB0aGlzLmNvbXBpbGVkW2Zyb21dO1xuICAgICAgICBjdXJyZW50RmlsZS5zY29wZU1hbmFnZXIgPSB0aGlzLmdldFNjb3BlTWFuYWdlcih0bywgY3VycmVudEZpbGUsIF9kYXRhKTtcbiAgICAgICAgY3VycmVudEZpbGUucmVuZGVyKHRvKTtcbiAgICAgICAgb3V0cHV0LnB1c2goW3RvLCBjdXJyZW50RmlsZS5jb250ZW50LCBjdXJyZW50RmlsZV0pO1xuICAgICAgICBkZWxldGUgY3VycmVudEZpbGUuY29udGVudDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMzYgPSAwOyBfaTM2IDwgb3V0cHV0Lmxlbmd0aDsgX2kzNisrKSB7XG4gICAgICAgIHZhciBvdXRwdXRQYXJ0ID0gb3V0cHV0W19pMzZdO1xuICAgICAgICB2YXIgX291dHB1dFBhcnQgPSBfc2xpY2VkVG9BcnJheShvdXRwdXRQYXJ0LCAzKSxcbiAgICAgICAgICBjb250ZW50ID0gX291dHB1dFBhcnRbMV0sXG4gICAgICAgICAgX2N1cnJlbnRGaWxlID0gX291dHB1dFBhcnRbMl07XG4gICAgICAgIGZvciAodmFyIF9pMzggPSAwLCBfdGhpcyRtb2R1bGVzMTQgPSB0aGlzLm1vZHVsZXM7IF9pMzggPCBfdGhpcyRtb2R1bGVzMTQubGVuZ3RoOyBfaTM4KyspIHtcbiAgICAgICAgICB2YXIgX21vZHVsZTAgPSBfdGhpcyRtb2R1bGVzMTRbX2kzOF07XG4gICAgICAgICAgaWYgKF9tb2R1bGUwLnByZVppcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9tb2R1bGUwLnByZVppcChjb250ZW50LCBfY3VycmVudEZpbGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgb3V0cHV0UGFydFsxXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pNDAgPSAwOyBfaTQwIDwgb3V0cHV0Lmxlbmd0aDsgX2k0MCsrKSB7XG4gICAgICAgIHZhciBfb3V0cHV0JF9pID0gX3NsaWNlZFRvQXJyYXkob3V0cHV0W19pNDBdLCAyKSxcbiAgICAgICAgICBfdG8gPSBfb3V0cHV0JF9pWzBdLFxuICAgICAgICAgIF9jb250ZW50ID0gX291dHB1dCRfaVsxXTtcbiAgICAgICAgdGhpcy56aXAuZmlsZShfdG8sIF9jb250ZW50LCB7XG4gICAgICAgICAgY3JlYXRlRm9sZGVyczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZlcmlmeUVycm9ycyh0aGlzKTtcbiAgICAgIHRoaXMuc2VuZEV2ZW50KFwic3luY2luZy16aXBcIik7XG4gICAgICB0aGlzLnN5bmNaaXAoKTtcbiAgICAgIC8vIFRoZSBzeW5jZWQtemlwIGV2ZW50IGlzIHVzZWQgaW4gdGhlIHN1YnRlbXBsYXRlIG1vZHVsZSBmb3IgZXhhbXBsZVxuICAgICAgdGhpcy5zZW5kRXZlbnQoXCJzeW5jZWQtemlwXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN5bmNaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3luY1ppcCgpIHtcbiAgICAgIGZvciAodmFyIGZpbGVOYW1lIGluIHRoaXMueG1sRG9jdW1lbnRzKSB7XG4gICAgICAgIHRoaXMuemlwLnJlbW92ZShmaWxlTmFtZSk7XG4gICAgICAgIHZhciBjb250ZW50ID0geG1sMnN0cih0aGlzLnhtbERvY3VtZW50c1tmaWxlTmFtZV0pO1xuICAgICAgICB0aGlzLnppcC5maWxlKGZpbGVOYW1lLCBjb250ZW50LCB7XG4gICAgICAgICAgY3JlYXRlRm9sZGVyczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKGRhdGEpIHtcbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJzZXREYXRhXCIpO1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WmlwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuemlwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVUZW1wbGF0ZUNsYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlQ2xhc3MocGF0aCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnppcC5maWxlc1twYXRoXS5hc1RleHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRlbXBsYXRlQ2xhc3NGcm9tQ29udGVudChjb250ZW50LCBwYXRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVGVtcGxhdGVDbGFzc0Zyb21Db250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlQ2xhc3NGcm9tQ29udGVudChjb250ZW50LCBmaWxlUGF0aCkge1xuICAgICAgdmFyIHhtbHRPcHRpb25zID0ge1xuICAgICAgICBmaWxlUGF0aDogZmlsZVBhdGgsXG4gICAgICAgIGNvbnRlbnRUeXBlOiB0aGlzLmZpbGVzQ29udGVudFR5cGVzW2ZpbGVQYXRoXSxcbiAgICAgICAgcmVsc1R5cGU6IHRoaXMucmVsc1R5cGVzW2ZpbGVQYXRoXVxuICAgICAgfTtcbiAgICAgIHZhciBkZWZhdWx0cyA9IGdldERlZmF1bHRzKCk7XG4gICAgICB2YXIgZGVmYXVsdEtleXMgPSBwdXNoQXJyYXkoT2JqZWN0LmtleXMoZGVmYXVsdHMpLCBbXCJmaWxlc0NvbnRlbnRUeXBlc1wiLCBcImZpbGVUeXBlQ29uZmlnXCIsIFwiZmlsZVR5cGVcIiwgXCJtb2R1bGVzXCJdKTtcbiAgICAgIGZvciAodmFyIF9pNDIgPSAwOyBfaTQyIDwgZGVmYXVsdEtleXMubGVuZ3RoOyBfaTQyKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGRlZmF1bHRLZXlzW19pNDJdO1xuICAgICAgICB4bWx0T3B0aW9uc1trZXldID0gdGhpc1trZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEb2N4dGVtcGxhdGVyLlhtbFRlbXBsYXRlcihjb250ZW50LCB4bWx0T3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxUZXh0KHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRlbXBsYXRlQ2xhc3MocGF0aCB8fCB0aGlzLmZpbGVUeXBlQ29uZmlnLnRleHRQYXRoKHRoaXMpKS5nZXRGdWxsVGV4dCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZW1wbGF0ZWRGaWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZWRGaWxlcygpIHtcbiAgICAgIHRoaXMudGVtcGxhdGVkRmlsZXMgPSB0aGlzLmZpbGVUeXBlQ29uZmlnLmdldFRlbXBsYXRlZEZpbGVzKHRoaXMuemlwKTtcbiAgICAgIHB1c2hBcnJheSh0aGlzLnRlbXBsYXRlZEZpbGVzLCB0aGlzLnRhcmdldHMpO1xuICAgICAgdmFyIHRlbXBsYXRlZE5zID0gdGhpcy5maWxlVHlwZUNvbmZpZy50ZW1wbGF0ZWROcyB8fCBbXTtcbiAgICAgIGlmICh0ZW1wbGF0ZWROcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmZpbGVzQ29udGVudFR5cGVzKSB7XG4gICAgICAgICAgaWYgKC9eY3VzdG9tWG1sXFwvaXRlbVxcZCtcXC54bWwkLy50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pNDQgPSAwOyBfaTQ0IDwgdGVtcGxhdGVkTnMubGVuZ3RoOyBfaTQ0KyspIHtcbiAgICAgICAgICAgICAgdmFyIG5zID0gdGVtcGxhdGVkTnNbX2k0NF07XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy56aXAuZmlsZShrZXkpLmFzVGV4dCgpO1xuICAgICAgICAgICAgICBpZiAodGV4dC5pbmRleE9mKFwieG1sbnM9XFxcIlwiLmNvbmNhdChucywgXCJcXFwiXCIpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlZEZpbGVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50ZW1wbGF0ZWRGaWxlcyA9IHVuaXEodGhpcy50ZW1wbGF0ZWRGaWxlcyk7XG4gICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZWRGaWxlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYWdzKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgaGVhZGVyczogW10sXG4gICAgICAgIGZvb3RlcnM6IFtdXG4gICAgICB9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5maWxlc0NvbnRlbnRUeXBlc1trZXldO1xuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQubWFpbit4bWxcIikge1xuICAgICAgICAgIHJlc3VsdC5kb2N1bWVudCA9IHtcbiAgICAgICAgICAgIHRhcmdldDoga2V5LFxuICAgICAgICAgICAgdGFnczogX2dldFRhZ3ModGhpcy5jb21waWxlZFtrZXldLnBvc3RwYXJzZWQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuaGVhZGVyK3htbFwiKSB7XG4gICAgICAgICAgcmVzdWx0LmhlYWRlcnMucHVzaCh7XG4gICAgICAgICAgICB0YXJnZXQ6IGtleSxcbiAgICAgICAgICAgIHRhZ3M6IF9nZXRUYWdzKHRoaXMuY29tcGlsZWRba2V5XS5wb3N0cGFyc2VkKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5mb290ZXIreG1sXCIpIHtcbiAgICAgICAgICByZXN1bHQuZm9vdGVycy5wdXNoKHtcbiAgICAgICAgICAgIHRhcmdldDoga2V5LFxuICAgICAgICAgICAgdGFnczogX2dldFRhZ3ModGhpcy5jb21waWxlZFtrZXldLnBvc3RwYXJzZWQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyogRXhwb3J0IGZ1bmN0aW9ucywgcHJlc2VudCBzaW5jZSAzLjYyLjAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b0J1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy56aXAuZ2VuZXJhdGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgY29tcHJlc3Npb246IFwiREVGTEFURVwiLFxuICAgICAgICBmaWxlT3JkZXI6IHppcEZpbGVPcmRlclxuICAgICAgfSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgIHR5cGU6IFwibm9kZWJ1ZmZlclwiXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyogRXhwb3J0IGZ1bmN0aW9ucywgcHJlc2VudCBzaW5jZSAzLjYyLjAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b0Jsb2JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9CbG9iKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnppcC5nZW5lcmF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBjb21wcmVzc2lvbjogXCJERUZMQVRFXCIsXG4gICAgICAgIGZpbGVPcmRlcjogemlwRmlsZU9yZGVyXG4gICAgICB9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgdHlwZTogXCJibG9iXCJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKiBFeHBvcnQgZnVuY3Rpb25zLCBwcmVzZW50IHNpbmNlIDMuNjIuMCAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvQmFzZTY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQmFzZTY0KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnppcC5nZW5lcmF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBjb21wcmVzc2lvbjogXCJERUZMQVRFXCIsXG4gICAgICAgIGZpbGVPcmRlcjogemlwRmlsZU9yZGVyXG4gICAgICB9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgdHlwZTogXCJiYXNlNjRcIlxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qIEV4cG9ydCBmdW5jdGlvbnMsIHByZXNlbnQgc2luY2UgMy42Mi4wICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9VaW50OEFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvVWludDhBcnJheShvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy56aXAuZ2VuZXJhdGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgY29tcHJlc3Npb246IFwiREVGTEFURVwiLFxuICAgICAgICBmaWxlT3JkZXI6IHppcEZpbGVPcmRlclxuICAgICAgfSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgIHR5cGU6IFwidWludDhhcnJheVwiXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyogRXhwb3J0IGZ1bmN0aW9ucywgcHJlc2VudCBzaW5jZSAzLjYyLjAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b0FycmF5QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuemlwLmdlbmVyYXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGNvbXByZXNzaW9uOiBcIkRFRkxBVEVcIixcbiAgICAgICAgZmlsZU9yZGVyOiB6aXBGaWxlT3JkZXJcbiAgICAgIH0sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICB0eXBlOiBcImFycmF5YnVmZmVyXCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbkRvY3h0ZW1wbGF0ZXIuRG9jVXRpbHMgPSBEb2NVdGlscztcbkRvY3h0ZW1wbGF0ZXIuRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuRG9jeHRlbXBsYXRlci5YbWxUZW1wbGF0ZXIgPSByZXF1aXJlKFwiLi94bWwtdGVtcGxhdGVyLmpzXCIpO1xuRG9jeHRlbXBsYXRlci5GaWxlVHlwZUNvbmZpZyA9IHJlcXVpcmUoXCIuL2ZpbGUtdHlwZS1jb25maWcuanNcIik7XG5Eb2N4dGVtcGxhdGVyLlhtbE1hdGNoZXIgPSByZXF1aXJlKFwiLi94bWwtbWF0Y2hlci5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gRG9jeHRlbXBsYXRlcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERvY3h0ZW1wbGF0ZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/docxtemplater.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/error-logger.js":
/*!*******************************************************!*\
  !*** ./node_modules/docxtemplater/js/error-logger.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray;\n// The error thrown here contains additional information when logged with JSON.stringify (it contains a properties object containing all suberrors).\nfunction replaceErrors(key, value) {\n  if (value instanceof Error) {\n    return pushArray(Object.getOwnPropertyNames(value), [\"stack\"]).reduce(function (error, key) {\n      error[key] = value[key];\n      if (key === \"stack\") {\n        // This is used because in Firefox, stack is not an own property\n        error[key] = value[key].toString();\n      }\n      return error;\n    }, {});\n  }\n  return value;\n}\nfunction logger(error, logging) {\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify({\n    error: error\n  }, replaceErrors, logging === \"json\" ? 2 : null));\n  if (error.properties && error.properties.errors instanceof Array) {\n    var errorMessages = error.properties.errors.map(function (error) {\n      return error.properties.explanation;\n    }).join(\"\\n\");\n    // eslint-disable-next-line no-console\n    console.log(\"errorMessages\", errorMessages);\n    /*\n     * errorMessages is a humanly readable message looking like this :\n     * 'The tag beginning with \"foobar\" is unopened'\n     */\n  }\n}\nmodule.exports = logger;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvci1sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDBFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZXJyb3ItbG9nZ2VyLmpzPzk3ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUucHVzaEFycmF5O1xuLy8gVGhlIGVycm9yIHRocm93biBoZXJlIGNvbnRhaW5zIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gd2hlbiBsb2dnZWQgd2l0aCBKU09OLnN0cmluZ2lmeSAoaXQgY29udGFpbnMgYSBwcm9wZXJ0aWVzIG9iamVjdCBjb250YWluaW5nIGFsbCBzdWJlcnJvcnMpLlxuZnVuY3Rpb24gcmVwbGFjZUVycm9ycyhrZXksIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIHB1c2hBcnJheShPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSksIFtcInN0YWNrXCJdKS5yZWR1Y2UoZnVuY3Rpb24gKGVycm9yLCBrZXkpIHtcbiAgICAgIGVycm9yW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgaWYgKGtleSA9PT0gXCJzdGFja1wiKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCBiZWNhdXNlIGluIEZpcmVmb3gsIHN0YWNrIGlzIG5vdCBhbiBvd24gcHJvcGVydHlcbiAgICAgICAgZXJyb3Jba2V5XSA9IHZhbHVlW2tleV0udG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9LCB7fSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbG9nZ2VyKGVycm9yLCBsb2dnaW5nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHtcbiAgICBlcnJvcjogZXJyb3JcbiAgfSwgcmVwbGFjZUVycm9ycywgbG9nZ2luZyA9PT0gXCJqc29uXCIgPyAyIDogbnVsbCkpO1xuICBpZiAoZXJyb3IucHJvcGVydGllcyAmJiBlcnJvci5wcm9wZXJ0aWVzLmVycm9ycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGVycm9yTWVzc2FnZXMgPSBlcnJvci5wcm9wZXJ0aWVzLmVycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3IucHJvcGVydGllcy5leHBsYW5hdGlvbjtcbiAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2coXCJlcnJvck1lc3NhZ2VzXCIsIGVycm9yTWVzc2FnZXMpO1xuICAgIC8qXG4gICAgICogZXJyb3JNZXNzYWdlcyBpcyBhIGh1bWFubHkgcmVhZGFibGUgbWVzc2FnZSBsb29raW5nIGxpa2UgdGhpcyA6XG4gICAgICogJ1RoZSB0YWcgYmVnaW5uaW5nIHdpdGggXCJmb29iYXJcIiBpcyB1bm9wZW5lZCdcbiAgICAgKi9cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBsb2dnZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/error-logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/errors.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/errors.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/docxtemplater/js/utils.js\"),\n  last = _require.last,\n  first = _require.first;\nfunction XTError(message) {\n  this.name = \"GenericError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTError.prototype = Error.prototype;\nfunction XTTemplateError(message) {\n  this.name = \"TemplateError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTTemplateError.prototype = new XTError();\nfunction XTRenderingError(message) {\n  this.name = \"RenderingError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTRenderingError.prototype = new XTError();\nfunction XTScopeParserError(message) {\n  this.name = \"ScopeParserError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTScopeParserError.prototype = new XTError();\nfunction XTInternalError(message) {\n  this.name = \"InternalError\";\n  this.properties = {\n    explanation: \"InternalError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTInternalError.prototype = new XTError();\nfunction XTAPIVersionError(message) {\n  this.name = \"APIVersionError\";\n  this.properties = {\n    explanation: \"APIVersionError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTAPIVersionError.prototype = new XTError();\nfunction throwApiVersionError(msg, properties) {\n  var err = new XTAPIVersionError(msg);\n  err.properties = _objectSpread({\n    id: \"api_version_error\"\n  }, properties);\n  throw err;\n}\nfunction throwMultiError(errors) {\n  var err = new XTTemplateError(\"Multi error\");\n  err.properties = {\n    errors: errors,\n    id: \"multi_error\",\n    explanation: \"The template has multiple errors\"\n  };\n  throw err;\n}\nfunction getUnopenedTagException(options) {\n  var err = new XTTemplateError(\"Unopened tag\");\n  err.properties = {\n    xtag: last(options.xtag.split(\" \")),\n    id: \"unopened_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unopened\")\n  };\n  return err;\n}\nfunction getDuplicateOpenTagException(options) {\n  var err = new XTTemplateError(\"Duplicate open tag, expected one open tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_open_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate open tags\")\n  };\n  return err;\n}\nfunction getDuplicateCloseTagException(options) {\n  var err = new XTTemplateError(\"Duplicate close tag, expected one close tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_close_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag ending with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate close tags\")\n  };\n  return err;\n}\nfunction getUnclosedTagException(options) {\n  var err = new XTTemplateError(\"Unclosed tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")).substr(1),\n    id: \"unclosed_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unclosed\")\n  };\n  return err;\n}\nfunction throwXmlTagNotFound(options) {\n  var err = new XTTemplateError(\"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position));\n  var part = options.parsed[options.index];\n  err.properties = {\n    id: \"no_xml_tag_found_at_\".concat(options.position),\n    explanation: \"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position),\n    offset: part.offset,\n    part: part,\n    parsed: options.parsed,\n    index: options.index,\n    element: options.element\n  };\n  throw err;\n}\nfunction getCorruptCharactersException(_ref) {\n  var tag = _ref.tag,\n    value = _ref.value,\n    offset = _ref.offset;\n  var err = new XTRenderingError(\"There are some XML corrupt characters\");\n  err.properties = {\n    id: \"invalid_xml_characters\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"There are some corrupt characters for the field \".concat(tag)\n  };\n  return err;\n}\nfunction getInvalidRawXMLValueException(_ref2) {\n  var tag = _ref2.tag,\n    value = _ref2.value,\n    offset = _ref2.offset;\n  var err = new XTRenderingError(\"Non string values are not allowed for rawXML tags\");\n  err.properties = {\n    id: \"invalid_raw_xml_value\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"The value of the raw tag : '\".concat(tag, \"' is not a string\")\n  };\n  return err;\n}\nfunction throwExpandNotFound(options) {\n  var _options$part = options.part,\n    value = _options$part.value,\n    offset = _options$part.offset,\n    _options$id = options.id,\n    id = _options$id === void 0 ? \"raw_tag_outerxml_invalid\" : _options$id,\n    _options$message = options.message,\n    message = _options$message === void 0 ? \"Raw tag not in paragraph\" : _options$message;\n  var part = options.part;\n  var _options$explanation = options.explanation,\n    explanation = _options$explanation === void 0 ? \"The tag \\\"\".concat(value, \"\\\" is not inside a paragraph\") : _options$explanation;\n  if (typeof explanation === \"function\") {\n    explanation = explanation(part);\n  }\n  var err = new XTTemplateError(message);\n  err.properties = {\n    id: id,\n    explanation: explanation,\n    rootError: options.rootError,\n    xtag: value,\n    offset: offset,\n    postparsed: options.postparsed,\n    expandTo: options.expandTo,\n    index: options.index\n  };\n  throw err;\n}\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n  var err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\n  var tag = options.part.value;\n  err.properties = {\n    id: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n    explanation: \"The raw tag \\\"\".concat(tag, \"\\\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.\"),\n    xtag: tag,\n    offset: options.part.offset,\n    paragraphParts: options.paragraphParts\n  };\n  throw err;\n}\nfunction getUnmatchedLoopException(part) {\n  var location = part.location,\n    offset = part.offset,\n    square = part.square;\n  var t = location === \"start\" ? \"unclosed\" : \"unopened\";\n  var T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n  var err = new XTTemplateError(\"\".concat(T, \" loop\"));\n  var tag = part.value;\n  err.properties = {\n    id: \"\".concat(t, \"_loop\"),\n    explanation: \"The loop with tag \\\"\".concat(tag, \"\\\" is \").concat(t),\n    xtag: tag,\n    offset: offset\n  };\n  if (square) {\n    err.properties.square = square;\n  }\n  return err;\n}\nfunction getUnbalancedLoopException(pair, lastPair) {\n  var err = new XTTemplateError(\"Unbalanced loop tag\");\n  var lastL = lastPair[0].part.value;\n  var lastR = lastPair[1].part.value;\n  var l = pair[0].part.value;\n  var r = pair[1].part.value;\n  err.properties = {\n    id: \"unbalanced_loop_tags\",\n    explanation: \"Unbalanced loop tags {#\".concat(lastL, \"}{/\").concat(lastR, \"}{#\").concat(l, \"}{/\").concat(r, \"}\"),\n    offset: [lastPair[0].part.offset, pair[1].part.offset],\n    lastPair: {\n      left: lastPair[0].part.value,\n      right: lastPair[1].part.value\n    },\n    pair: {\n      left: pair[0].part.value,\n      right: pair[1].part.value\n    }\n  };\n  return err;\n}\nfunction getClosingTagNotMatchOpeningTag(_ref3) {\n  var tags = _ref3.tags;\n  var err = new XTTemplateError(\"Closing tag does not match opening tag\");\n  err.properties = {\n    id: \"closing_tag_does_not_match_opening_tag\",\n    explanation: \"The tag \\\"\".concat(tags[0].value, \"\\\" is closed by the tag \\\"\").concat(tags[1].value, \"\\\"\"),\n    openingtag: first(tags).value,\n    offset: [first(tags).offset, last(tags).offset],\n    closingtag: last(tags).value\n  };\n  if (first(tags).square) {\n    err.properties.square = [first(tags).square, last(tags).square];\n  }\n  return err;\n}\nfunction getScopeCompilationError(_ref4) {\n  var tag = _ref4.tag,\n    rootError = _ref4.rootError,\n    offset = _ref4.offset;\n  var err = new XTScopeParserError(\"Scope parser compilation failed\");\n  err.properties = {\n    id: \"scopeparser_compilation_failed\",\n    offset: offset,\n    xtag: tag,\n    explanation: \"The scope parser for the tag \\\"\".concat(tag, \"\\\" failed to compile\"),\n    rootError: rootError\n  };\n  return err;\n}\nfunction getScopeParserExecutionError(_ref5) {\n  var tag = _ref5.tag,\n    scope = _ref5.scope,\n    error = _ref5.error,\n    offset = _ref5.offset;\n  var err = new XTScopeParserError(\"Scope parser execution failed\");\n  err.properties = {\n    id: \"scopeparser_execution_failed\",\n    explanation: \"The scope parser for the tag \".concat(tag, \" failed to execute\"),\n    scope: scope,\n    offset: offset,\n    xtag: tag,\n    rootError: error\n  };\n  return err;\n}\nfunction getLoopPositionProducesInvalidXMLError(_ref6) {\n  var tag = _ref6.tag,\n    offset = _ref6.offset;\n  var err = new XTTemplateError(\"The position of the loop tags \\\"\".concat(tag, \"\\\" would produce invalid XML\"));\n  err.properties = {\n    xtag: tag,\n    id: \"loop_position_invalid\",\n    explanation: \"The tags \\\"\".concat(tag, \"\\\" are misplaced in the document, for example one of them is in a table and the other one outside the table\"),\n    offset: offset\n  };\n  return err;\n}\nfunction throwUnimplementedTagType(part, index) {\n  var errorMsg = \"Unimplemented tag type \\\"\".concat(part.type, \"\\\"\");\n  if (part.module) {\n    errorMsg += \" \\\"\".concat(part.module, \"\\\"\");\n  }\n  var err = new XTTemplateError(errorMsg);\n  err.properties = {\n    part: part,\n    index: index,\n    id: \"unimplemented_tag_type\"\n  };\n  throw err;\n}\nfunction throwMalformedXml() {\n  var err = new XTInternalError(\"Malformed xml\");\n  err.properties = {\n    explanation: \"The template contains malformed xml\",\n    id: \"malformed_xml\"\n  };\n  throw err;\n}\nfunction throwResolveBeforeCompile() {\n  var err = new XTInternalError(\"You must run `.compile()` before running `.resolveData()`\");\n  err.properties = {\n    id: \"resolve_before_compile\",\n    explanation: \"You must run `.compile()` before running `.resolveData()`\"\n  };\n  throw err;\n}\nfunction throwRenderInvalidTemplate() {\n  var err = new XTInternalError(\"You should not call .render on a document that had compilation errors\");\n  err.properties = {\n    id: \"render_on_invalid_template\",\n    explanation: \"You should not call .render on a document that had compilation errors\"\n  };\n  throw err;\n}\nfunction throwRenderTwice() {\n  var err = new XTInternalError(\"You should not call .render twice on the same docxtemplater instance\");\n  err.properties = {\n    id: \"render_twice\",\n    explanation: \"You should not call .render twice on the same docxtemplater instance\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotIdentified(zip) {\n  var files = Object.keys(zip.files).slice(0, 10);\n  var msg = \"\";\n  if (files.length === 0) {\n    msg = \"Empty zip file\";\n  } else {\n    msg = \"Zip file contains : \".concat(files.join(\",\"));\n  }\n  var err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg));\n  err.properties = {\n    id: \"filetype_not_identified\",\n    explanation: \"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg)\n  };\n  throw err;\n}\nfunction throwXmlInvalid(content, offset) {\n  var err = new XTTemplateError(\"An XML file has invalid xml\");\n  err.properties = {\n    id: \"file_has_invalid_xml\",\n    content: content,\n    offset: offset,\n    explanation: \"The docx contains invalid XML, it is most likely corrupt\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotHandled(fileType) {\n  var err = new XTInternalError(\"The filetype \\\"\".concat(fileType, \"\\\" is not handled by docxtemplater\"));\n  err.properties = {\n    id: \"filetype_not_handled\",\n    explanation: \"The file you are trying to generate is of type \\\"\".concat(fileType, \"\\\", but only docx and pptx formats are handled\"),\n    fileType: fileType\n  };\n  throw err;\n}\nmodule.exports = {\n  XTError: XTError,\n  XTTemplateError: XTTemplateError,\n  XTInternalError: XTInternalError,\n  XTScopeParserError: XTScopeParserError,\n  XTAPIVersionError: XTAPIVersionError,\n  // Remove this alias in v4\n  RenderingError: XTRenderingError,\n  XTRenderingError: XTRenderingError,\n  getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\n  getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\n  getScopeCompilationError: getScopeCompilationError,\n  getScopeParserExecutionError: getScopeParserExecutionError,\n  getUnclosedTagException: getUnclosedTagException,\n  getUnopenedTagException: getUnopenedTagException,\n  getUnmatchedLoopException: getUnmatchedLoopException,\n  getDuplicateCloseTagException: getDuplicateCloseTagException,\n  getDuplicateOpenTagException: getDuplicateOpenTagException,\n  getCorruptCharactersException: getCorruptCharactersException,\n  getInvalidRawXMLValueException: getInvalidRawXMLValueException,\n  getUnbalancedLoopException: getUnbalancedLoopException,\n  throwApiVersionError: throwApiVersionError,\n  throwFileTypeNotHandled: throwFileTypeNotHandled,\n  throwFileTypeNotIdentified: throwFileTypeNotIdentified,\n  throwMalformedXml: throwMalformedXml,\n  throwMultiError: throwMultiError,\n  throwExpandNotFound: throwExpandNotFound,\n  throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\n  throwUnimplementedTagType: throwUnimplementedTagType,\n  throwXmlTagNotFound: throwXmlTagNotFound,\n  throwXmlInvalid: throwXmlInvalid,\n  throwResolveBeforeCompile: throwResolveBeforeCompile,\n  throwRenderInvalidTemplate: throwRenderInvalidTemplate,\n  throwRenderTwice: throwRenderTwice\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQyxrRUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0IscUJBQXFCLGlCQUFpQixnQkFBZ0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZXJyb3JzLmpzPzRmNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIiksXG4gIGxhc3QgPSBfcmVxdWlyZS5sYXN0LFxuICBmaXJzdCA9IF9yZXF1aXJlLmZpcnN0O1xuZnVuY3Rpb24gWFRFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiR2VuZXJpY0Vycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVEVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbmZ1bmN0aW9uIFhUVGVtcGxhdGVFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiVGVtcGxhdGVFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSA9IG5ldyBYVEVycm9yKCk7XG5mdW5jdGlvbiBYVFJlbmRlcmluZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJSZW5kZXJpbmdFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRSZW5kZXJpbmdFcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gWFRTY29wZVBhcnNlckVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJTY29wZVBhcnNlckVycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVFNjb3BlUGFyc2VyRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIFhUSW50ZXJuYWxFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgZXhwbGFuYXRpb246IFwiSW50ZXJuYWxFcnJvclwiXG4gIH07XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVEludGVybmFsRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIFhUQVBJVmVyc2lvbkVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJBUElWZXJzaW9uRXJyb3JcIjtcbiAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgIGV4cGxhbmF0aW9uOiBcIkFQSVZlcnNpb25FcnJvclwiXG4gIH07XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVEFQSVZlcnNpb25FcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gdGhyb3dBcGlWZXJzaW9uRXJyb3IobXNnLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRBUElWZXJzaW9uRXJyb3IobXNnKTtcbiAgZXJyLnByb3BlcnRpZXMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBpZDogXCJhcGlfdmVyc2lvbl9lcnJvclwiXG4gIH0sIHByb3BlcnRpZXMpO1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd011bHRpRXJyb3IoZXJyb3JzKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTXVsdGkgZXJyb3JcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGVycm9yczogZXJyb3JzLFxuICAgIGlkOiBcIm11bHRpX2Vycm9yXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRlbXBsYXRlIGhhcyBtdWx0aXBsZSBlcnJvcnNcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVW5vcGVuZWQgdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBsYXN0KG9wdGlvbnMueHRhZy5zcGxpdChcIiBcIikpLFxuICAgIGlkOiBcInVub3BlbmVkX3RhZ1wiLFxuICAgIGNvbnRleHQ6IG9wdGlvbnMueHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgIGxJbmRleDogb3B0aW9ucy5sSW5kZXgsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBiZWdpbm5pbmcgd2l0aCBcXFwiXCIuY29uY2F0KG9wdGlvbnMueHRhZy5zdWJzdHIoMCwgMTApLCBcIlxcXCIgaXMgdW5vcGVuZWRcIilcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24ob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIkR1cGxpY2F0ZSBvcGVuIHRhZywgZXhwZWN0ZWQgb25lIG9wZW4gdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBmaXJzdChvcHRpb25zLnh0YWcuc3BsaXQoXCIgXCIpKSxcbiAgICBpZDogXCJkdXBsaWNhdGVfb3Blbl90YWdcIixcbiAgICBjb250ZXh0OiBvcHRpb25zLnh0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcbiAgICBsSW5kZXg6IG9wdGlvbnMubEluZGV4LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWcgYmVnaW5uaW5nIHdpdGggXFxcIlwiLmNvbmNhdChvcHRpb25zLnh0YWcuc3Vic3RyKDAsIDEwKSwgXCJcXFwiIGhhcyBkdXBsaWNhdGUgb3BlbiB0YWdzXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiRHVwbGljYXRlIGNsb3NlIHRhZywgZXhwZWN0ZWQgb25lIGNsb3NlIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogZmlyc3Qob3B0aW9ucy54dGFnLnNwbGl0KFwiIFwiKSksXG4gICAgaWQ6IFwiZHVwbGljYXRlX2Nsb3NlX3RhZ1wiLFxuICAgIGNvbnRleHQ6IG9wdGlvbnMueHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgIGxJbmRleDogb3B0aW9ucy5sSW5kZXgsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBlbmRpbmcgd2l0aCBcXFwiXCIuY29uY2F0KG9wdGlvbnMueHRhZy5zdWJzdHIoMCwgMTApLCBcIlxcXCIgaGFzIGR1cGxpY2F0ZSBjbG9zZSB0YWdzXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVW5jbG9zZWQgdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBmaXJzdChvcHRpb25zLnh0YWcuc3BsaXQoXCIgXCIpKS5zdWJzdHIoMSksXG4gICAgaWQ6IFwidW5jbG9zZWRfdGFnXCIsXG4gICAgY29udGV4dDogb3B0aW9ucy54dGFnLFxuICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQsXG4gICAgbEluZGV4OiBvcHRpb25zLmxJbmRleCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIGJlZ2lubmluZyB3aXRoIFxcXCJcIi5jb25jYXQob3B0aW9ucy54dGFnLnN1YnN0cigwLCAxMCksIFwiXFxcIiBpcyB1bmNsb3NlZFwiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dYbWxUYWdOb3RGb3VuZChvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTm8gdGFnIFxcXCJcIi5jb25jYXQob3B0aW9ucy5lbGVtZW50LCBcIlxcXCIgd2FzIGZvdW5kIGF0IHRoZSBcIikuY29uY2F0KG9wdGlvbnMucG9zaXRpb24pKTtcbiAgdmFyIHBhcnQgPSBvcHRpb25zLnBhcnNlZFtvcHRpb25zLmluZGV4XTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwibm9feG1sX3RhZ19mb3VuZF9hdF9cIi5jb25jYXQob3B0aW9ucy5wb3NpdGlvbiksXG4gICAgZXhwbGFuYXRpb246IFwiTm8gdGFnIFxcXCJcIi5jb25jYXQob3B0aW9ucy5lbGVtZW50LCBcIlxcXCIgd2FzIGZvdW5kIGF0IHRoZSBcIikuY29uY2F0KG9wdGlvbnMucG9zaXRpb24pLFxuICAgIG9mZnNldDogcGFydC5vZmZzZXQsXG4gICAgcGFydDogcGFydCxcbiAgICBwYXJzZWQ6IG9wdGlvbnMucGFyc2VkLFxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgIGVsZW1lbnQ6IG9wdGlvbnMuZWxlbWVudFxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbihfcmVmKSB7XG4gIHZhciB0YWcgPSBfcmVmLnRhZyxcbiAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRSZW5kZXJpbmdFcnJvcihcIlRoZXJlIGFyZSBzb21lIFhNTCBjb3JydXB0IGNoYXJhY3RlcnNcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImludmFsaWRfeG1sX2NoYXJhY3RlcnNcIixcbiAgICB4dGFnOiB0YWcsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZXJlIGFyZSBzb21lIGNvcnJ1cHQgY2hhcmFjdGVycyBmb3IgdGhlIGZpZWxkIFwiLmNvbmNhdCh0YWcpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24oX3JlZjIpIHtcbiAgdmFyIHRhZyA9IF9yZWYyLnRhZyxcbiAgICB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgIG9mZnNldCA9IF9yZWYyLm9mZnNldDtcbiAgdmFyIGVyciA9IG5ldyBYVFJlbmRlcmluZ0Vycm9yKFwiTm9uIHN0cmluZyB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkIGZvciByYXdYTUwgdGFnc1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiaW52YWxpZF9yYXdfeG1sX3ZhbHVlXCIsXG4gICAgeHRhZzogdGFnLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdmFsdWUgb2YgdGhlIHJhdyB0YWcgOiAnXCIuY29uY2F0KHRhZywgXCInIGlzIG5vdCBhIHN0cmluZ1wiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dFeHBhbmROb3RGb3VuZChvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRwYXJ0ID0gb3B0aW9ucy5wYXJ0LFxuICAgIHZhbHVlID0gX29wdGlvbnMkcGFydC52YWx1ZSxcbiAgICBvZmZzZXQgPSBfb3B0aW9ucyRwYXJ0Lm9mZnNldCxcbiAgICBfb3B0aW9ucyRpZCA9IG9wdGlvbnMuaWQsXG4gICAgaWQgPSBfb3B0aW9ucyRpZCA9PT0gdm9pZCAwID8gXCJyYXdfdGFnX291dGVyeG1sX2ludmFsaWRcIiA6IF9vcHRpb25zJGlkLFxuICAgIF9vcHRpb25zJG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgbWVzc2FnZSA9IF9vcHRpb25zJG1lc3NhZ2UgPT09IHZvaWQgMCA/IFwiUmF3IHRhZyBub3QgaW4gcGFyYWdyYXBoXCIgOiBfb3B0aW9ucyRtZXNzYWdlO1xuICB2YXIgcGFydCA9IG9wdGlvbnMucGFydDtcbiAgdmFyIF9vcHRpb25zJGV4cGxhbmF0aW9uID0gb3B0aW9ucy5leHBsYW5hdGlvbixcbiAgICBleHBsYW5hdGlvbiA9IF9vcHRpb25zJGV4cGxhbmF0aW9uID09PSB2b2lkIDAgPyBcIlRoZSB0YWcgXFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiIGlzIG5vdCBpbnNpZGUgYSBwYXJhZ3JhcGhcIikgOiBfb3B0aW9ucyRleHBsYW5hdGlvbjtcbiAgaWYgKHR5cGVvZiBleHBsYW5hdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbihwYXJ0KTtcbiAgfVxuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihtZXNzYWdlKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IGlkLFxuICAgIGV4cGxhbmF0aW9uOiBleHBsYW5hdGlvbixcbiAgICByb290RXJyb3I6IG9wdGlvbnMucm9vdEVycm9yLFxuICAgIHh0YWc6IHZhbHVlLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHBvc3RwYXJzZWQ6IG9wdGlvbnMucG9zdHBhcnNlZCxcbiAgICBleHBhbmRUbzogb3B0aW9ucy5leHBhbmRUbyxcbiAgICBpbmRleDogb3B0aW9ucy5pbmRleFxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaChvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiUmF3IHRhZyBzaG91bGQgYmUgdGhlIG9ubHkgdGV4dCBpbiBwYXJhZ3JhcGhcIik7XG4gIHZhciB0YWcgPSBvcHRpb25zLnBhcnQudmFsdWU7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJhd194bWxfdGFnX3Nob3VsZF9iZV9vbmx5X3RleHRfaW5fcGFyYWdyYXBoXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHJhdyB0YWcgXFxcIlwiLmNvbmNhdCh0YWcsIFwiXFxcIiBzaG91bGQgYmUgdGhlIG9ubHkgdGV4dCBpbiB0aGlzIHBhcmFncmFwaC4gVGhpcyBtZWFucyB0aGF0IHRoaXMgdGFnIHNob3VsZCBub3QgYmUgc3Vycm91bmRlZCBieSBhbnkgdGV4dCBvciBzcGFjZXMuXCIpLFxuICAgIHh0YWc6IHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMucGFydC5vZmZzZXQsXG4gICAgcGFyYWdyYXBoUGFydHM6IG9wdGlvbnMucGFyYWdyYXBoUGFydHNcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbihwYXJ0KSB7XG4gIHZhciBsb2NhdGlvbiA9IHBhcnQubG9jYXRpb24sXG4gICAgb2Zmc2V0ID0gcGFydC5vZmZzZXQsXG4gICAgc3F1YXJlID0gcGFydC5zcXVhcmU7XG4gIHZhciB0ID0gbG9jYXRpb24gPT09IFwic3RhcnRcIiA/IFwidW5jbG9zZWRcIiA6IFwidW5vcGVuZWRcIjtcbiAgdmFyIFQgPSBsb2NhdGlvbiA9PT0gXCJzdGFydFwiID8gXCJVbmNsb3NlZFwiIDogXCJVbm9wZW5lZFwiO1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlwiLmNvbmNhdChULCBcIiBsb29wXCIpKTtcbiAgdmFyIHRhZyA9IHBhcnQudmFsdWU7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcIlwiLmNvbmNhdCh0LCBcIl9sb29wXCIpLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSBsb29wIHdpdGggdGFnIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgaXMgXCIpLmNvbmNhdCh0KSxcbiAgICB4dGFnOiB0YWcsXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfTtcbiAgaWYgKHNxdWFyZSkge1xuICAgIGVyci5wcm9wZXJ0aWVzLnNxdWFyZSA9IHNxdWFyZTtcbiAgfVxuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24ocGFpciwgbGFzdFBhaXIpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJVbmJhbGFuY2VkIGxvb3AgdGFnXCIpO1xuICB2YXIgbGFzdEwgPSBsYXN0UGFpclswXS5wYXJ0LnZhbHVlO1xuICB2YXIgbGFzdFIgPSBsYXN0UGFpclsxXS5wYXJ0LnZhbHVlO1xuICB2YXIgbCA9IHBhaXJbMF0ucGFydC52YWx1ZTtcbiAgdmFyIHIgPSBwYWlyWzFdLnBhcnQudmFsdWU7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInVuYmFsYW5jZWRfbG9vcF90YWdzXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVW5iYWxhbmNlZCBsb29wIHRhZ3MgeyNcIi5jb25jYXQobGFzdEwsIFwifXsvXCIpLmNvbmNhdChsYXN0UiwgXCJ9eyNcIikuY29uY2F0KGwsIFwifXsvXCIpLmNvbmNhdChyLCBcIn1cIiksXG4gICAgb2Zmc2V0OiBbbGFzdFBhaXJbMF0ucGFydC5vZmZzZXQsIHBhaXJbMV0ucGFydC5vZmZzZXRdLFxuICAgIGxhc3RQYWlyOiB7XG4gICAgICBsZWZ0OiBsYXN0UGFpclswXS5wYXJ0LnZhbHVlLFxuICAgICAgcmlnaHQ6IGxhc3RQYWlyWzFdLnBhcnQudmFsdWVcbiAgICB9LFxuICAgIHBhaXI6IHtcbiAgICAgIGxlZnQ6IHBhaXJbMF0ucGFydC52YWx1ZSxcbiAgICAgIHJpZ2h0OiBwYWlyWzFdLnBhcnQudmFsdWVcbiAgICB9XG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnKF9yZWYzKSB7XG4gIHZhciB0YWdzID0gX3JlZjMudGFncztcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJDbG9zaW5nIHRhZyBkb2VzIG5vdCBtYXRjaCBvcGVuaW5nIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiY2xvc2luZ190YWdfZG9lc19ub3RfbWF0Y2hfb3BlbmluZ190YWdcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIFxcXCJcIi5jb25jYXQodGFnc1swXS52YWx1ZSwgXCJcXFwiIGlzIGNsb3NlZCBieSB0aGUgdGFnIFxcXCJcIikuY29uY2F0KHRhZ3NbMV0udmFsdWUsIFwiXFxcIlwiKSxcbiAgICBvcGVuaW5ndGFnOiBmaXJzdCh0YWdzKS52YWx1ZSxcbiAgICBvZmZzZXQ6IFtmaXJzdCh0YWdzKS5vZmZzZXQsIGxhc3QodGFncykub2Zmc2V0XSxcbiAgICBjbG9zaW5ndGFnOiBsYXN0KHRhZ3MpLnZhbHVlXG4gIH07XG4gIGlmIChmaXJzdCh0YWdzKS5zcXVhcmUpIHtcbiAgICBlcnIucHJvcGVydGllcy5zcXVhcmUgPSBbZmlyc3QodGFncykuc3F1YXJlLCBsYXN0KHRhZ3MpLnNxdWFyZV07XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldFNjb3BlQ29tcGlsYXRpb25FcnJvcihfcmVmNCkge1xuICB2YXIgdGFnID0gX3JlZjQudGFnLFxuICAgIHJvb3RFcnJvciA9IF9yZWY0LnJvb3RFcnJvcixcbiAgICBvZmZzZXQgPSBfcmVmNC5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRTY29wZVBhcnNlckVycm9yKFwiU2NvcGUgcGFyc2VyIGNvbXBpbGF0aW9uIGZhaWxlZFwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwic2NvcGVwYXJzZXJfY29tcGlsYXRpb25fZmFpbGVkXCIsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgeHRhZzogdGFnLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSBzY29wZSBwYXJzZXIgZm9yIHRoZSB0YWcgXFxcIlwiLmNvbmNhdCh0YWcsIFwiXFxcIiBmYWlsZWQgdG8gY29tcGlsZVwiKSxcbiAgICByb290RXJyb3I6IHJvb3RFcnJvclxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcihfcmVmNSkge1xuICB2YXIgdGFnID0gX3JlZjUudGFnLFxuICAgIHNjb3BlID0gX3JlZjUuc2NvcGUsXG4gICAgZXJyb3IgPSBfcmVmNS5lcnJvcixcbiAgICBvZmZzZXQgPSBfcmVmNS5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRTY29wZVBhcnNlckVycm9yKFwiU2NvcGUgcGFyc2VyIGV4ZWN1dGlvbiBmYWlsZWRcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInNjb3BlcGFyc2VyX2V4ZWN1dGlvbl9mYWlsZWRcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgc2NvcGUgcGFyc2VyIGZvciB0aGUgdGFnIFwiLmNvbmNhdCh0YWcsIFwiIGZhaWxlZCB0byBleGVjdXRlXCIpLFxuICAgIHNjb3BlOiBzY29wZSxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICB4dGFnOiB0YWcsXG4gICAgcm9vdEVycm9yOiBlcnJvclxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3IoX3JlZjYpIHtcbiAgdmFyIHRhZyA9IF9yZWY2LnRhZyxcbiAgICBvZmZzZXQgPSBfcmVmNi5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVGhlIHBvc2l0aW9uIG9mIHRoZSBsb29wIHRhZ3MgXFxcIlwiLmNvbmNhdCh0YWcsIFwiXFxcIiB3b3VsZCBwcm9kdWNlIGludmFsaWQgWE1MXCIpKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogdGFnLFxuICAgIGlkOiBcImxvb3BfcG9zaXRpb25faW52YWxpZFwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWdzIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgYXJlIG1pc3BsYWNlZCBpbiB0aGUgZG9jdW1lbnQsIGZvciBleGFtcGxlIG9uZSBvZiB0aGVtIGlzIGluIGEgdGFibGUgYW5kIHRoZSBvdGhlciBvbmUgb3V0c2lkZSB0aGUgdGFibGVcIiksXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIHRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUocGFydCwgaW5kZXgpIHtcbiAgdmFyIGVycm9yTXNnID0gXCJVbmltcGxlbWVudGVkIHRhZyB0eXBlIFxcXCJcIi5jb25jYXQocGFydC50eXBlLCBcIlxcXCJcIik7XG4gIGlmIChwYXJ0Lm1vZHVsZSkge1xuICAgIGVycm9yTXNnICs9IFwiIFxcXCJcIi5jb25jYXQocGFydC5tb2R1bGUsIFwiXFxcIlwiKTtcbiAgfVxuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihlcnJvck1zZyk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHBhcnQ6IHBhcnQsXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGlkOiBcInVuaW1wbGVtZW50ZWRfdGFnX3R5cGVcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd01hbGZvcm1lZFhtbCgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJNYWxmb3JtZWQgeG1sXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGVtcGxhdGUgY29udGFpbnMgbWFsZm9ybWVkIHhtbFwiLFxuICAgIGlkOiBcIm1hbGZvcm1lZF94bWxcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlKCkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIllvdSBtdXN0IHJ1biBgLmNvbXBpbGUoKWAgYmVmb3JlIHJ1bm5pbmcgYC5yZXNvbHZlRGF0YSgpYFwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwicmVzb2x2ZV9iZWZvcmVfY29tcGlsZVwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIllvdSBtdXN0IHJ1biBgLmNvbXBpbGUoKWAgYmVmb3JlIHJ1bm5pbmcgYC5yZXNvbHZlRGF0YSgpYFwiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlKCkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIllvdSBzaG91bGQgbm90IGNhbGwgLnJlbmRlciBvbiBhIGRvY3VtZW50IHRoYXQgaGFkIGNvbXBpbGF0aW9uIGVycm9yc1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwicmVuZGVyX29uX2ludmFsaWRfdGVtcGxhdGVcIixcbiAgICBleHBsYW5hdGlvbjogXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgb24gYSBkb2N1bWVudCB0aGF0IGhhZCBjb21waWxhdGlvbiBlcnJvcnNcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1JlbmRlclR3aWNlKCkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIllvdSBzaG91bGQgbm90IGNhbGwgLnJlbmRlciB0d2ljZSBvbiB0aGUgc2FtZSBkb2N4dGVtcGxhdGVyIGluc3RhbmNlXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJyZW5kZXJfdHdpY2VcIixcbiAgICBleHBsYW5hdGlvbjogXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgdHdpY2Ugb24gdGhlIHNhbWUgZG9jeHRlbXBsYXRlciBpbnN0YW5jZVwiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkKHppcCkge1xuICB2YXIgZmlsZXMgPSBPYmplY3Qua2V5cyh6aXAuZmlsZXMpLnNsaWNlKDAsIDEwKTtcbiAgdmFyIG1zZyA9IFwiXCI7XG4gIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICBtc2cgPSBcIkVtcHR5IHppcCBmaWxlXCI7XG4gIH0gZWxzZSB7XG4gICAgbXNnID0gXCJaaXAgZmlsZSBjb250YWlucyA6IFwiLmNvbmNhdChmaWxlcy5qb2luKFwiLFwiKSk7XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJUaGUgZmlsZXR5cGUgZm9yIHRoaXMgZmlsZSBjb3VsZCBub3QgYmUgaWRlbnRpZmllZCwgaXMgdGhpcyBmaWxlIGNvcnJ1cHRlZCA/IFwiLmNvbmNhdChtc2cpKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiZmlsZXR5cGVfbm90X2lkZW50aWZpZWRcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgZmlsZXR5cGUgZm9yIHRoaXMgZmlsZSBjb3VsZCBub3QgYmUgaWRlbnRpZmllZCwgaXMgdGhpcyBmaWxlIGNvcnJ1cHRlZCA/IFwiLmNvbmNhdChtc2cpXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93WG1sSW52YWxpZChjb250ZW50LCBvZmZzZXQpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJBbiBYTUwgZmlsZSBoYXMgaW52YWxpZCB4bWxcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImZpbGVfaGFzX2ludmFsaWRfeG1sXCIsXG4gICAgY29udGVudDogY29udGVudCxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgZG9jeCBjb250YWlucyBpbnZhbGlkIFhNTCwgaXQgaXMgbW9zdCBsaWtlbHkgY29ycnVwdFwiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93RmlsZVR5cGVOb3RIYW5kbGVkKGZpbGVUeXBlKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiVGhlIGZpbGV0eXBlIFxcXCJcIi5jb25jYXQoZmlsZVR5cGUsIFwiXFxcIiBpcyBub3QgaGFuZGxlZCBieSBkb2N4dGVtcGxhdGVyXCIpKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiZmlsZXR5cGVfbm90X2hhbmRsZWRcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgZmlsZSB5b3UgYXJlIHRyeWluZyB0byBnZW5lcmF0ZSBpcyBvZiB0eXBlIFxcXCJcIi5jb25jYXQoZmlsZVR5cGUsIFwiXFxcIiwgYnV0IG9ubHkgZG9jeCBhbmQgcHB0eCBmb3JtYXRzIGFyZSBoYW5kbGVkXCIpLFxuICAgIGZpbGVUeXBlOiBmaWxlVHlwZVxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgWFRFcnJvcjogWFRFcnJvcixcbiAgWFRUZW1wbGF0ZUVycm9yOiBYVFRlbXBsYXRlRXJyb3IsXG4gIFhUSW50ZXJuYWxFcnJvcjogWFRJbnRlcm5hbEVycm9yLFxuICBYVFNjb3BlUGFyc2VyRXJyb3I6IFhUU2NvcGVQYXJzZXJFcnJvcixcbiAgWFRBUElWZXJzaW9uRXJyb3I6IFhUQVBJVmVyc2lvbkVycm9yLFxuICAvLyBSZW1vdmUgdGhpcyBhbGlhcyBpbiB2NFxuICBSZW5kZXJpbmdFcnJvcjogWFRSZW5kZXJpbmdFcnJvcixcbiAgWFRSZW5kZXJpbmdFcnJvcjogWFRSZW5kZXJpbmdFcnJvcixcbiAgZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZzogZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyxcbiAgZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3I6IGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yLFxuICBnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3I6IGdldFNjb3BlQ29tcGlsYXRpb25FcnJvcixcbiAgZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcjogZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcixcbiAgZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb246IGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uLFxuICBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbjogZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24sXG4gIGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb246IGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24sXG4gIGdldER1cGxpY2F0ZUNsb3NlVGFnRXhjZXB0aW9uOiBnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbixcbiAgZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbjogZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbixcbiAgZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb246IGdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uLFxuICBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb246IGdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbixcbiAgZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb246IGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uLFxuICB0aHJvd0FwaVZlcnNpb25FcnJvcjogdGhyb3dBcGlWZXJzaW9uRXJyb3IsXG4gIHRocm93RmlsZVR5cGVOb3RIYW5kbGVkOiB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZCxcbiAgdGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQ6IHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkLFxuICB0aHJvd01hbGZvcm1lZFhtbDogdGhyb3dNYWxmb3JtZWRYbWwsXG4gIHRocm93TXVsdGlFcnJvcjogdGhyb3dNdWx0aUVycm9yLFxuICB0aHJvd0V4cGFuZE5vdEZvdW5kOiB0aHJvd0V4cGFuZE5vdEZvdW5kLFxuICB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaDogdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGgsXG4gIHRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGU6IHRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUsXG4gIHRocm93WG1sVGFnTm90Rm91bmQ6IHRocm93WG1sVGFnTm90Rm91bmQsXG4gIHRocm93WG1sSW52YWxpZDogdGhyb3dYbWxJbnZhbGlkLFxuICB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlOiB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlLFxuICB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZTogdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGUsXG4gIHRocm93UmVuZGVyVHdpY2U6IHRocm93UmVuZGVyVHdpY2Vcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/file-type-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/docxtemplater/js/file-type-config.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar loopModule = __webpack_require__(/*! ./modules/loop.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/loop.js\");\nvar spacePreserveModule = __webpack_require__(/*! ./modules/space-preserve.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/space-preserve.js\");\nvar rawXmlModule = __webpack_require__(/*! ./modules/rawxml.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/rawxml.js\");\nvar expandPairTrait = __webpack_require__(/*! ./modules/expand-pair-trait.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js\");\nvar render = __webpack_require__(/*! ./modules/render.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/render.js\");\nfunction DocXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    templatedNs: [\"http://schemas.microsoft.com/office/2006/coverPageProps\"],\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"cp:contentStatus\", \"PublishDate\", \"Abstract\", \"CompanyAddress\", \"CompanyPhone\", \"CompanyFax\", \"CompanyEmail\", \"w:t\", \"a:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"w:proofState\", \"w:tc\", \"w:tr\", \"w:tbl\", \"w:ftr\", \"w:hdr\", \"w:body\", \"w:document\", \"w:p\", \"w:r\", \"w:br\", \"w:rPr\", \"w:pPr\", \"w:spacing\", \"w:sdtContent\", \"w:sdt\", \"w:drawing\", \"w:sectPr\", \"w:type\", \"w:headerReference\", \"w:footerReference\", \"w:bookmarkStart\", \"w:bookmarkEnd\", \"w:commentRangeStart\", \"w:commentRangeEnd\", \"w:commentReference\"],\n    droppedTagsInsidePlaceholder: [\"w:p\", \"w:br\", \"w:bookmarkStart\", \"w:bookmarkEnd\"],\n    expandTags: [{\n      contains: \"w:tc\",\n      expand: \"w:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"w:p\",\n      expand: \"w:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"w:p\",\n    baseModules: [loopModule, spacePreserveModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"w:sdtContent\",\n      shouldContain: [\"w:p\", \"w:r\", \"w:commentRangeStart\", \"w:sdt\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:tc\",\n      shouldContain: [\"w:p\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:tr\",\n      shouldContain: [\"w:tc\"],\n      drop: true\n    }, {\n      tag: \"w:tbl\",\n      shouldContain: [\"w:tr\"],\n      drop: true\n    }]\n  };\n}\nfunction PptXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"a:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"p:sp\", \"a:tc\", \"a:tr\", \"a:tbl\", \"a:graphicData\", \"a:p\", \"a:r\", \"a:rPr\", \"p:txBody\", \"a:txBody\", \"a:off\", \"a:ext\", \"p:graphicFrame\", \"p:xfrm\", \"a16:rowId\", \"a:endParaRPr\"],\n    droppedTagsInsidePlaceholder: [\"a:p\", \"a:endParaRPr\"],\n    expandTags: [{\n      contains: \"a:tc\",\n      expand: \"a:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"a:p\",\n      expand: \"a:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"p:sp\",\n    baseModules: [loopModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"a:tbl\",\n      shouldContain: [\"a:tr\"],\n      dropParent: \"p:graphicFrame\"\n    }, {\n      tag: \"p:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }, {\n      tag: \"a:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }]\n  };\n}\nmodule.exports = {\n  docx: DocXFileTypeConfig,\n  pptx: PptXFileTypeConfig\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9maWxlLXR5cGUtY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFtQjtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDL0QsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLDBHQUFnQztBQUM5RCxhQUFhLG1CQUFPLENBQUMsb0ZBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2ZpbGUtdHlwZS1jb25maWcuanM/MDhjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGxvb3BNb2R1bGUgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2xvb3AuanNcIik7XG52YXIgc3BhY2VQcmVzZXJ2ZU1vZHVsZSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvc3BhY2UtcHJlc2VydmUuanNcIik7XG52YXIgcmF3WG1sTW9kdWxlID0gcmVxdWlyZShcIi4vbW9kdWxlcy9yYXd4bWwuanNcIik7XG52YXIgZXhwYW5kUGFpclRyYWl0ID0gcmVxdWlyZShcIi4vbW9kdWxlcy9leHBhbmQtcGFpci10cmFpdC5qc1wiKTtcbnZhciByZW5kZXIgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3JlbmRlci5qc1wiKTtcbmZ1bmN0aW9uIERvY1hGaWxlVHlwZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRUZW1wbGF0ZWRGaWxlczogZnVuY3Rpb24gZ2V0VGVtcGxhdGVkRmlsZXMoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICB0ZW1wbGF0ZWROczogW1wiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvMjAwNi9jb3ZlclBhZ2VQcm9wc1wiXSxcbiAgICB0ZXh0UGF0aDogZnVuY3Rpb24gdGV4dFBhdGgoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLnRleHRUYXJnZXQ7XG4gICAgfSxcbiAgICB0YWdzWG1sVGV4dEFycmF5OiBbXCJDb21wYW55XCIsIFwiSHlwZXJsaW5rQmFzZVwiLCBcIk1hbmFnZXJcIiwgXCJjcDpjYXRlZ29yeVwiLCBcImNwOmtleXdvcmRzXCIsIFwiZGM6Y3JlYXRvclwiLCBcImRjOmRlc2NyaXB0aW9uXCIsIFwiZGM6c3ViamVjdFwiLCBcImRjOnRpdGxlXCIsIFwiY3A6Y29udGVudFN0YXR1c1wiLCBcIlB1Ymxpc2hEYXRlXCIsIFwiQWJzdHJhY3RcIiwgXCJDb21wYW55QWRkcmVzc1wiLCBcIkNvbXBhbnlQaG9uZVwiLCBcIkNvbXBhbnlGYXhcIiwgXCJDb21wYW55RW1haWxcIiwgXCJ3OnRcIiwgXCJhOnRcIiwgXCJtOnRcIiwgXCJ2dDpscHN0clwiLCBcInZ0Omxwd3N0clwiXSxcbiAgICB0YWdzWG1sTGV4ZWRBcnJheTogW1widzpwcm9vZlN0YXRlXCIsIFwidzp0Y1wiLCBcInc6dHJcIiwgXCJ3OnRibFwiLCBcInc6ZnRyXCIsIFwidzpoZHJcIiwgXCJ3OmJvZHlcIiwgXCJ3OmRvY3VtZW50XCIsIFwidzpwXCIsIFwidzpyXCIsIFwidzpiclwiLCBcInc6clByXCIsIFwidzpwUHJcIiwgXCJ3OnNwYWNpbmdcIiwgXCJ3OnNkdENvbnRlbnRcIiwgXCJ3OnNkdFwiLCBcInc6ZHJhd2luZ1wiLCBcInc6c2VjdFByXCIsIFwidzp0eXBlXCIsIFwidzpoZWFkZXJSZWZlcmVuY2VcIiwgXCJ3OmZvb3RlclJlZmVyZW5jZVwiLCBcInc6Ym9va21hcmtTdGFydFwiLCBcInc6Ym9va21hcmtFbmRcIiwgXCJ3OmNvbW1lbnRSYW5nZVN0YXJ0XCIsIFwidzpjb21tZW50UmFuZ2VFbmRcIiwgXCJ3OmNvbW1lbnRSZWZlcmVuY2VcIl0sXG4gICAgZHJvcHBlZFRhZ3NJbnNpZGVQbGFjZWhvbGRlcjogW1widzpwXCIsIFwidzpiclwiLCBcInc6Ym9va21hcmtTdGFydFwiLCBcInc6Ym9va21hcmtFbmRcIl0sXG4gICAgZXhwYW5kVGFnczogW3tcbiAgICAgIGNvbnRhaW5zOiBcInc6dGNcIixcbiAgICAgIGV4cGFuZDogXCJ3OnRyXCJcbiAgICB9XSxcbiAgICBvblBhcmFncmFwaExvb3A6IFt7XG4gICAgICBjb250YWluczogXCJ3OnBcIixcbiAgICAgIGV4cGFuZDogXCJ3OnBcIixcbiAgICAgIG9ubHlUZXh0SW5UYWc6IHRydWVcbiAgICB9XSxcbiAgICB0YWdSYXdYbWw6IFwidzpwXCIsXG4gICAgYmFzZU1vZHVsZXM6IFtsb29wTW9kdWxlLCBzcGFjZVByZXNlcnZlTW9kdWxlLCBleHBhbmRQYWlyVHJhaXQsIHJhd1htbE1vZHVsZSwgcmVuZGVyXSxcbiAgICB0YWdTaG91bGRDb250YWluOiBbe1xuICAgICAgdGFnOiBcInc6c2R0Q29udGVudFwiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1widzpwXCIsIFwidzpyXCIsIFwidzpjb21tZW50UmFuZ2VTdGFydFwiLCBcInc6c2R0XCJdLFxuICAgICAgdmFsdWU6IFwiPHc6cD48L3c6cD5cIlxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJ3OnRjXCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJ3OnBcIl0sXG4gICAgICB2YWx1ZTogXCI8dzpwPjwvdzpwPlwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcInc6dHJcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcInc6dGNcIl0sXG4gICAgICBkcm9wOiB0cnVlXG4gICAgfSwge1xuICAgICAgdGFnOiBcInc6dGJsXCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJ3OnRyXCJdLFxuICAgICAgZHJvcDogdHJ1ZVxuICAgIH1dXG4gIH07XG59XG5mdW5jdGlvbiBQcHRYRmlsZVR5cGVDb25maWcoKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0VGVtcGxhdGVkRmlsZXM6IGZ1bmN0aW9uIGdldFRlbXBsYXRlZEZpbGVzKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgdGV4dFBhdGg6IGZ1bmN0aW9uIHRleHRQYXRoKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy50ZXh0VGFyZ2V0O1xuICAgIH0sXG4gICAgdGFnc1htbFRleHRBcnJheTogW1wiQ29tcGFueVwiLCBcIkh5cGVybGlua0Jhc2VcIiwgXCJNYW5hZ2VyXCIsIFwiY3A6Y2F0ZWdvcnlcIiwgXCJjcDprZXl3b3Jkc1wiLCBcImRjOmNyZWF0b3JcIiwgXCJkYzpkZXNjcmlwdGlvblwiLCBcImRjOnN1YmplY3RcIiwgXCJkYzp0aXRsZVwiLCBcImE6dFwiLCBcIm06dFwiLCBcInZ0Omxwc3RyXCIsIFwidnQ6bHB3c3RyXCJdLFxuICAgIHRhZ3NYbWxMZXhlZEFycmF5OiBbXCJwOnNwXCIsIFwiYTp0Y1wiLCBcImE6dHJcIiwgXCJhOnRibFwiLCBcImE6Z3JhcGhpY0RhdGFcIiwgXCJhOnBcIiwgXCJhOnJcIiwgXCJhOnJQclwiLCBcInA6dHhCb2R5XCIsIFwiYTp0eEJvZHlcIiwgXCJhOm9mZlwiLCBcImE6ZXh0XCIsIFwicDpncmFwaGljRnJhbWVcIiwgXCJwOnhmcm1cIiwgXCJhMTY6cm93SWRcIiwgXCJhOmVuZFBhcmFSUHJcIl0sXG4gICAgZHJvcHBlZFRhZ3NJbnNpZGVQbGFjZWhvbGRlcjogW1wiYTpwXCIsIFwiYTplbmRQYXJhUlByXCJdLFxuICAgIGV4cGFuZFRhZ3M6IFt7XG4gICAgICBjb250YWluczogXCJhOnRjXCIsXG4gICAgICBleHBhbmQ6IFwiYTp0clwiXG4gICAgfV0sXG4gICAgb25QYXJhZ3JhcGhMb29wOiBbe1xuICAgICAgY29udGFpbnM6IFwiYTpwXCIsXG4gICAgICBleHBhbmQ6IFwiYTpwXCIsXG4gICAgICBvbmx5VGV4dEluVGFnOiB0cnVlXG4gICAgfV0sXG4gICAgdGFnUmF3WG1sOiBcInA6c3BcIixcbiAgICBiYXNlTW9kdWxlczogW2xvb3BNb2R1bGUsIGV4cGFuZFBhaXJUcmFpdCwgcmF3WG1sTW9kdWxlLCByZW5kZXJdLFxuICAgIHRhZ1Nob3VsZENvbnRhaW46IFt7XG4gICAgICB0YWc6IFwiYTp0YmxcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcImE6dHJcIl0sXG4gICAgICBkcm9wUGFyZW50OiBcInA6Z3JhcGhpY0ZyYW1lXCJcbiAgICB9LCB7XG4gICAgICB0YWc6IFwicDp0eEJvZHlcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcImE6cFwiXSxcbiAgICAgIHZhbHVlOiBcIjxhOnA+PC9hOnA+XCJcbiAgICB9LCB7XG4gICAgICB0YWc6IFwiYTp0eEJvZHlcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcImE6cFwiXSxcbiAgICAgIHZhbHVlOiBcIjxhOnA+PC9hOnA+XCJcbiAgICB9XVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRvY3g6IERvY1hGaWxlVHlwZUNvbmZpZyxcbiAgcHB0eDogUHB0WEZpbGVUeXBlQ29uZmlnXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/file-type-config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/filetypes.js":
/*!****************************************************!*\
  !*** ./node_modules/docxtemplater/js/filetypes.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\n\nvar docxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\";\nvar docxmContentType = \"application/vnd.ms-word.document.macroEnabled.main+xml\";\nvar dotxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\";\nvar dotmContentType = \"application/vnd.ms-word.template.macroEnabledTemplate.main+xml\";\nvar headerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\";\nvar footnotesContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\";\nvar commentsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\";\nvar footerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\";\nvar pptxContentType = \"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\";\nvar pptxSlideMaster = \"application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml\";\nvar pptxSlideLayout = \"application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml\";\nvar pptxPresentationContentType = \"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\";\nvar xlsxContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\";\nvar xlsmContentType = \"application/vnd.ms-excel.sheet.macroEnabled.main+xml\";\nvar xlsxWorksheetContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\";\n/*\n * This is used for the main part of the document, ie usually that would be the\n * type of word/document.xml\n */\nvar main = [docxContentType, docxmContentType, dotxContentType, dotmContentType];\nvar filetypes = {\n  main: main,\n  docx: [headerContentType].concat(main, [footerContentType, footnotesContentType, commentsContentType]),\n  pptx: [pptxContentType, pptxSlideMaster, pptxSlideLayout, pptxPresentationContentType],\n  xlsx: [xlsxContentType, xlsmContentType, xlsxWorksheetContentType]\n};\nmodule.exports = filetypes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9maWxldHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9maWxldHlwZXMuanM/NmE2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGRvY3hDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQubWFpbit4bWxcIjtcbnZhciBkb2N4bUNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb0VuYWJsZWQubWFpbit4bWxcIjtcbnZhciBkb3R4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlLm1haW4reG1sXCI7XG52YXIgZG90bUNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQubXMtd29yZC50ZW1wbGF0ZS5tYWNyb0VuYWJsZWRUZW1wbGF0ZS5tYWluK3htbFwiO1xudmFyIGhlYWRlckNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5oZWFkZXIreG1sXCI7XG52YXIgZm9vdG5vdGVzQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmZvb3Rub3Rlcyt4bWxcIjtcbnZhciBjb21tZW50c0NvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5jb21tZW50cyt4bWxcIjtcbnZhciBmb290ZXJDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZm9vdGVyK3htbFwiO1xudmFyIHBwdHhDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlK3htbFwiO1xudmFyIHBwdHhTbGlkZU1hc3RlciA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlTWFzdGVyK3htbFwiO1xudmFyIHBwdHhTbGlkZUxheW91dCA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlTGF5b3V0K3htbFwiO1xudmFyIHBwdHhQcmVzZW50YXRpb25Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbi5tYWluK3htbFwiO1xudmFyIHhsc3hDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQubWFpbit4bWxcIjtcbnZhciB4bHNtQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5tYWNyb0VuYWJsZWQubWFpbit4bWxcIjtcbnZhciB4bHN4V29ya3NoZWV0Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLndvcmtzaGVldCt4bWxcIjtcbi8qXG4gKiBUaGlzIGlzIHVzZWQgZm9yIHRoZSBtYWluIHBhcnQgb2YgdGhlIGRvY3VtZW50LCBpZSB1c3VhbGx5IHRoYXQgd291bGQgYmUgdGhlXG4gKiB0eXBlIG9mIHdvcmQvZG9jdW1lbnQueG1sXG4gKi9cbnZhciBtYWluID0gW2RvY3hDb250ZW50VHlwZSwgZG9jeG1Db250ZW50VHlwZSwgZG90eENvbnRlbnRUeXBlLCBkb3RtQ29udGVudFR5cGVdO1xudmFyIGZpbGV0eXBlcyA9IHtcbiAgbWFpbjogbWFpbixcbiAgZG9jeDogW2hlYWRlckNvbnRlbnRUeXBlXS5jb25jYXQobWFpbiwgW2Zvb3RlckNvbnRlbnRUeXBlLCBmb290bm90ZXNDb250ZW50VHlwZSwgY29tbWVudHNDb250ZW50VHlwZV0pLFxuICBwcHR4OiBbcHB0eENvbnRlbnRUeXBlLCBwcHR4U2xpZGVNYXN0ZXIsIHBwdHhTbGlkZUxheW91dCwgcHB0eFByZXNlbnRhdGlvbkNvbnRlbnRUeXBlXSxcbiAgeGxzeDogW3hsc3hDb250ZW50VHlwZSwgeGxzbUNvbnRlbnRUeXBlLCB4bHN4V29ya3NoZWV0Q29udGVudFR5cGVdXG59O1xubW9kdWxlLmV4cG9ydHMgPSBmaWxldHlwZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/filetypes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/get-content-types.js":
/*!************************************************************!*\
  !*** ./node_modules/docxtemplater/js/get-content-types.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  str2xml = _require.str2xml;\nvar ctXML = \"[Content_Types].xml\";\nfunction collectContentTypes(overrides, defaults, zip) {\n  var partNames = {};\n  for (var _i2 = 0; _i2 < overrides.length; _i2++) {\n    var override = overrides[_i2];\n    var contentType = override.getAttribute(\"ContentType\");\n    var partName = override.getAttribute(\"PartName\").substr(1);\n    partNames[partName] = contentType;\n  }\n  zip.file(/./).map(function (_ref) {\n    var name = _ref.name;\n    for (var _i4 = 0; _i4 < defaults.length; _i4++) {\n      var def = defaults[_i4];\n      var _contentType = def.getAttribute(\"ContentType\");\n      var extension = def.getAttribute(\"Extension\");\n      if (name.slice(name.length - extension.length) === extension && !partNames[name] && name !== ctXML) {\n        partNames[name] = _contentType;\n      }\n    }\n    partNames[name] || (partNames[name] = \"\");\n  });\n  return partNames;\n}\nfunction getContentTypes(zip) {\n  var contentTypes = zip.files[ctXML];\n  var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;\n  var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Override\") : null;\n  var defaults = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Default\") : null;\n  return {\n    overrides: overrides,\n    defaults: defaults,\n    contentTypes: contentTypes,\n    contentTypeXml: contentTypeXml\n  };\n}\nmodule.exports = {\n  collectContentTypes: collectContentTypes,\n  getContentTypes: getContentTypes\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtY29udGVudC10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2dldC1jb250ZW50LXR5cGVzLmpzPzdmZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgc3RyMnhtbCA9IF9yZXF1aXJlLnN0cjJ4bWw7XG52YXIgY3RYTUwgPSBcIltDb250ZW50X1R5cGVzXS54bWxcIjtcbmZ1bmN0aW9uIGNvbGxlY3RDb250ZW50VHlwZXMob3ZlcnJpZGVzLCBkZWZhdWx0cywgemlwKSB7XG4gIHZhciBwYXJ0TmFtZXMgPSB7fTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgb3ZlcnJpZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgb3ZlcnJpZGUgPSBvdmVycmlkZXNbX2kyXTtcbiAgICB2YXIgY29udGVudFR5cGUgPSBvdmVycmlkZS5nZXRBdHRyaWJ1dGUoXCJDb250ZW50VHlwZVwiKTtcbiAgICB2YXIgcGFydE5hbWUgPSBvdmVycmlkZS5nZXRBdHRyaWJ1dGUoXCJQYXJ0TmFtZVwiKS5zdWJzdHIoMSk7XG4gICAgcGFydE5hbWVzW3BhcnROYW1lXSA9IGNvbnRlbnRUeXBlO1xuICB9XG4gIHppcC5maWxlKC8uLykubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgZGVmYXVsdHMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIGRlZiA9IGRlZmF1bHRzW19pNF07XG4gICAgICB2YXIgX2NvbnRlbnRUeXBlID0gZGVmLmdldEF0dHJpYnV0ZShcIkNvbnRlbnRUeXBlXCIpO1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGRlZi5nZXRBdHRyaWJ1dGUoXCJFeHRlbnNpb25cIik7XG4gICAgICBpZiAobmFtZS5zbGljZShuYW1lLmxlbmd0aCAtIGV4dGVuc2lvbi5sZW5ndGgpID09PSBleHRlbnNpb24gJiYgIXBhcnROYW1lc1tuYW1lXSAmJiBuYW1lICE9PSBjdFhNTCkge1xuICAgICAgICBwYXJ0TmFtZXNbbmFtZV0gPSBfY29udGVudFR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnROYW1lc1tuYW1lXSB8fCAocGFydE5hbWVzW25hbWVdID0gXCJcIik7XG4gIH0pO1xuICByZXR1cm4gcGFydE5hbWVzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGVudFR5cGVzKHppcCkge1xuICB2YXIgY29udGVudFR5cGVzID0gemlwLmZpbGVzW2N0WE1MXTtcbiAgdmFyIGNvbnRlbnRUeXBlWG1sID0gY29udGVudFR5cGVzID8gc3RyMnhtbChjb250ZW50VHlwZXMuYXNUZXh0KCkpIDogbnVsbDtcbiAgdmFyIG92ZXJyaWRlcyA9IGNvbnRlbnRUeXBlWG1sID8gY29udGVudFR5cGVYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJPdmVycmlkZVwiKSA6IG51bGw7XG4gIHZhciBkZWZhdWx0cyA9IGNvbnRlbnRUeXBlWG1sID8gY29udGVudFR5cGVYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJEZWZhdWx0XCIpIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBvdmVycmlkZXM6IG92ZXJyaWRlcyxcbiAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgY29udGVudFR5cGVzOiBjb250ZW50VHlwZXMsXG4gICAgY29udGVudFR5cGVYbWw6IGNvbnRlbnRUeXBlWG1sXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29sbGVjdENvbnRlbnRUeXBlczogY29sbGVjdENvbnRlbnRUeXBlcyxcbiAgZ2V0Q29udGVudFR5cGVzOiBnZXRDb250ZW50VHlwZXNcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/get-content-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/get-relation-types.js":
/*!*************************************************************!*\
  !*** ./node_modules/docxtemplater/js/get-relation-types.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  str2xml = _require.str2xml;\nvar relsFile = \"_rels/.rels\";\nfunction getRelsTypes(zip) {\n  var rootRels = zip.files[relsFile];\n  var rootRelsXml = rootRels ? str2xml(rootRels.asText()) : null;\n  var rootRelationships = rootRelsXml ? rootRelsXml.getElementsByTagName(\"Relationship\") : [];\n  var relsTypes = {};\n  for (var _i2 = 0; _i2 < rootRelationships.length; _i2++) {\n    var relation = rootRelationships[_i2];\n    relsTypes[relation.getAttribute(\"Target\")] = relation.getAttribute(\"Type\");\n  }\n  return relsTypes;\n}\nmodule.exports = {\n  getRelsTypes: getRelsTypes\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtcmVsYXRpb24tdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDBFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LXJlbGF0aW9uLXR5cGVzLmpzPzgyNzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgc3RyMnhtbCA9IF9yZXF1aXJlLnN0cjJ4bWw7XG52YXIgcmVsc0ZpbGUgPSBcIl9yZWxzLy5yZWxzXCI7XG5mdW5jdGlvbiBnZXRSZWxzVHlwZXMoemlwKSB7XG4gIHZhciByb290UmVscyA9IHppcC5maWxlc1tyZWxzRmlsZV07XG4gIHZhciByb290UmVsc1htbCA9IHJvb3RSZWxzID8gc3RyMnhtbChyb290UmVscy5hc1RleHQoKSkgOiBudWxsO1xuICB2YXIgcm9vdFJlbGF0aW9uc2hpcHMgPSByb290UmVsc1htbCA/IHJvb3RSZWxzWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiUmVsYXRpb25zaGlwXCIpIDogW107XG4gIHZhciByZWxzVHlwZXMgPSB7fTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcm9vdFJlbGF0aW9uc2hpcHMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciByZWxhdGlvbiA9IHJvb3RSZWxhdGlvbnNoaXBzW19pMl07XG4gICAgcmVsc1R5cGVzW3JlbGF0aW9uLmdldEF0dHJpYnV0ZShcIlRhcmdldFwiKV0gPSByZWxhdGlvbi5nZXRBdHRyaWJ1dGUoXCJUeXBlXCIpO1xuICB9XG4gIHJldHVybiByZWxzVHlwZXM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0UmVsc1R5cGVzOiBnZXRSZWxzVHlwZXNcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/get-relation-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/get-resolved-id.js":
/*!**********************************************************!*\
  !*** ./node_modules/docxtemplater/js/get-resolved-id.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\n\nfunction getResolvedId(part, options) {\n  if (part.lIndex == null) {\n    return null;\n  }\n  var path = options.scopeManager.scopePathItem;\n  if (part.parentPart) {\n    path = path.slice(0, path.length - 1);\n  }\n  var res = options.filePath + \"@\" + part.lIndex.toString() + \"-\" + path.join(\"-\");\n  return res;\n}\nmodule.exports = getResolvedId;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtcmVzb2x2ZWQtaWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtcmVzb2x2ZWQtaWQuanM/M2U1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0UmVzb2x2ZWRJZChwYXJ0LCBvcHRpb25zKSB7XG4gIGlmIChwYXJ0LmxJbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHBhdGggPSBvcHRpb25zLnNjb3BlTWFuYWdlci5zY29wZVBhdGhJdGVtO1xuICBpZiAocGFydC5wYXJlbnRQYXJ0KSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgfVxuICB2YXIgcmVzID0gb3B0aW9ucy5maWxlUGF0aCArIFwiQFwiICsgcGFydC5sSW5kZXgudG9TdHJpbmcoKSArIFwiLVwiICsgcGF0aC5qb2luKFwiLVwiKTtcbiAgcmV0dXJuIHJlcztcbn1cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmVzb2x2ZWRJZDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/get-resolved-id.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/get-tags.js":
/*!***************************************************!*\
  !*** ./node_modules/docxtemplater/js/get-tags.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\n\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction isPlaceholder(part) {\n  return part.type === \"placeholder\";\n}\n\n/* eslint-disable-next-line complexity */\nfunction getTags(postParsed) {\n  var tags = {};\n  var stack = [{\n    items: postParsed.filter(isPlaceholder),\n    parents: [],\n    path: []\n  }];\n  function processFiltered(part, current, filtered) {\n    if (filtered.length) {\n      stack.push({\n        items: filtered,\n        parents: [].concat(_toConsumableArray(current.parents), [part]),\n        path: part.dataBound !== false && !part.attrParsed && part.value && !part.attrParsed ? [].concat(_toConsumableArray(current.path), [part.value]) : _toConsumableArray(current.path)\n      });\n    }\n  }\n  function getLocalTags(tags, path) {\n    var sizeScope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.length;\n    var localTags = tags;\n    for (var i = 0; i < sizeScope; i++) {\n      localTags = localTags[path[i]];\n    }\n    return localTags;\n  }\n  function getScopeSize(part, parents) {\n    var size = parents.length;\n    for (var _i2 = 0; _i2 < parents.length; _i2++) {\n      var parent = parents[_i2];\n      var lIndexLoop = typeof parent.lIndex === \"number\" ? parent.lIndex : parseInt(parent.lIndex.split(\"-\")[0], 10);\n      if (lIndexLoop > part.lIndex) {\n        size--;\n      }\n    }\n    return size;\n  }\n  while (stack.length > 0) {\n    var current = stack.pop();\n    var localTags = getLocalTags(tags, current.path);\n    for (var _i4 = 0, _current$items2 = current.items; _i4 < _current$items2.length; _i4++) {\n      var _localTags4, _part$value2;\n      var part = _current$items2[_i4];\n      if (part.attrParsed) {\n        for (var key in part.attrParsed) {\n          processFiltered(part, current, part.attrParsed[key].filter(isPlaceholder));\n        }\n        continue;\n      }\n      if (part.subparsed) {\n        if (part.dataBound !== false) {\n          var _localTags, _part$value;\n          (_localTags = localTags)[_part$value = part.value] || (_localTags[_part$value] = {});\n        }\n        processFiltered(part, current, part.subparsed.filter(isPlaceholder));\n        continue;\n      }\n      if (part.cellParsed) {\n        for (var _i6 = 0, _part$cellPostParsed2 = part.cellPostParsed; _i6 < _part$cellPostParsed2.length; _i6++) {\n          var cp = _part$cellPostParsed2[_i6];\n          if (cp.type === \"placeholder\") {\n            if (cp.module === \"pro-xml-templating/xls-module-loop\") {\n              continue;\n            } else if (cp.subparsed) {\n              var _localTags2, _cp$value;\n              (_localTags2 = localTags)[_cp$value = cp.value] || (_localTags2[_cp$value] = {});\n              processFiltered(cp, current, cp.subparsed.filter(isPlaceholder));\n            } else {\n              var _localTags3, _cp$value2;\n              var sizeScope = getScopeSize(part, current.parents);\n              localTags = getLocalTags(tags, current.path, sizeScope);\n              (_localTags3 = localTags)[_cp$value2 = cp.value] || (_localTags3[_cp$value2] = {});\n            }\n          }\n        }\n        continue;\n      }\n      if (part.dataBound === false) {\n        continue;\n      }\n      (_localTags4 = localTags)[_part$value2 = part.value] || (_localTags4[_part$value2] = {});\n    }\n  }\n  return tags;\n}\nmodule.exports = {\n  getTags: getTags,\n  isPlaceholder: isPlaceholder\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtdGFncy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw4QkFBOEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG9DQUFvQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtdGFncy5qcz83NzEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHsgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gaXNQbGFjZWhvbGRlcihwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIjtcbn1cblxuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHkgKi9cbmZ1bmN0aW9uIGdldFRhZ3MocG9zdFBhcnNlZCkge1xuICB2YXIgdGFncyA9IHt9O1xuICB2YXIgc3RhY2sgPSBbe1xuICAgIGl0ZW1zOiBwb3N0UGFyc2VkLmZpbHRlcihpc1BsYWNlaG9sZGVyKSxcbiAgICBwYXJlbnRzOiBbXSxcbiAgICBwYXRoOiBbXVxuICB9XTtcbiAgZnVuY3Rpb24gcHJvY2Vzc0ZpbHRlcmVkKHBhcnQsIGN1cnJlbnQsIGZpbHRlcmVkKSB7XG4gICAgaWYgKGZpbHRlcmVkLmxlbmd0aCkge1xuICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgIGl0ZW1zOiBmaWx0ZXJlZCxcbiAgICAgICAgcGFyZW50czogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjdXJyZW50LnBhcmVudHMpLCBbcGFydF0pLFxuICAgICAgICBwYXRoOiBwYXJ0LmRhdGFCb3VuZCAhPT0gZmFsc2UgJiYgIXBhcnQuYXR0clBhcnNlZCAmJiBwYXJ0LnZhbHVlICYmICFwYXJ0LmF0dHJQYXJzZWQgPyBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGN1cnJlbnQucGF0aCksIFtwYXJ0LnZhbHVlXSkgOiBfdG9Db25zdW1hYmxlQXJyYXkoY3VycmVudC5wYXRoKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldExvY2FsVGFncyh0YWdzLCBwYXRoKSB7XG4gICAgdmFyIHNpemVTY29wZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogcGF0aC5sZW5ndGg7XG4gICAgdmFyIGxvY2FsVGFncyA9IHRhZ3M7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplU2NvcGU7IGkrKykge1xuICAgICAgbG9jYWxUYWdzID0gbG9jYWxUYWdzW3BhdGhbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxUYWdzO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNjb3BlU2l6ZShwYXJ0LCBwYXJlbnRzKSB7XG4gICAgdmFyIHNpemUgPSBwYXJlbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYXJlbnRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW19pMl07XG4gICAgICB2YXIgbEluZGV4TG9vcCA9IHR5cGVvZiBwYXJlbnQubEluZGV4ID09PSBcIm51bWJlclwiID8gcGFyZW50LmxJbmRleCA6IHBhcnNlSW50KHBhcmVudC5sSW5kZXguc3BsaXQoXCItXCIpWzBdLCAxMCk7XG4gICAgICBpZiAobEluZGV4TG9vcCA+IHBhcnQubEluZGV4KSB7XG4gICAgICAgIHNpemUtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY3VycmVudCA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBsb2NhbFRhZ3MgPSBnZXRMb2NhbFRhZ3ModGFncywgY3VycmVudC5wYXRoKTtcbiAgICBmb3IgKHZhciBfaTQgPSAwLCBfY3VycmVudCRpdGVtczIgPSBjdXJyZW50Lml0ZW1zOyBfaTQgPCBfY3VycmVudCRpdGVtczIubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIF9sb2NhbFRhZ3M0LCBfcGFydCR2YWx1ZTI7XG4gICAgICB2YXIgcGFydCA9IF9jdXJyZW50JGl0ZW1zMltfaTRdO1xuICAgICAgaWYgKHBhcnQuYXR0clBhcnNlZCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGFydC5hdHRyUGFyc2VkKSB7XG4gICAgICAgICAgcHJvY2Vzc0ZpbHRlcmVkKHBhcnQsIGN1cnJlbnQsIHBhcnQuYXR0clBhcnNlZFtrZXldLmZpbHRlcihpc1BsYWNlaG9sZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocGFydC5zdWJwYXJzZWQpIHtcbiAgICAgICAgaWYgKHBhcnQuZGF0YUJvdW5kICE9PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBfbG9jYWxUYWdzLCBfcGFydCR2YWx1ZTtcbiAgICAgICAgICAoX2xvY2FsVGFncyA9IGxvY2FsVGFncylbX3BhcnQkdmFsdWUgPSBwYXJ0LnZhbHVlXSB8fCAoX2xvY2FsVGFnc1tfcGFydCR2YWx1ZV0gPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0ZpbHRlcmVkKHBhcnQsIGN1cnJlbnQsIHBhcnQuc3VicGFyc2VkLmZpbHRlcihpc1BsYWNlaG9sZGVyKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQuY2VsbFBhcnNlZCkge1xuICAgICAgICBmb3IgKHZhciBfaTYgPSAwLCBfcGFydCRjZWxsUG9zdFBhcnNlZDIgPSBwYXJ0LmNlbGxQb3N0UGFyc2VkOyBfaTYgPCBfcGFydCRjZWxsUG9zdFBhcnNlZDIubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICAgIHZhciBjcCA9IF9wYXJ0JGNlbGxQb3N0UGFyc2VkMltfaTZdO1xuICAgICAgICAgIGlmIChjcC50eXBlID09PSBcInBsYWNlaG9sZGVyXCIpIHtcbiAgICAgICAgICAgIGlmIChjcC5tb2R1bGUgPT09IFwicHJvLXhtbC10ZW1wbGF0aW5nL3hscy1tb2R1bGUtbG9vcFwiKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjcC5zdWJwYXJzZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9sb2NhbFRhZ3MyLCBfY3AkdmFsdWU7XG4gICAgICAgICAgICAgIChfbG9jYWxUYWdzMiA9IGxvY2FsVGFncylbX2NwJHZhbHVlID0gY3AudmFsdWVdIHx8IChfbG9jYWxUYWdzMltfY3AkdmFsdWVdID0ge30pO1xuICAgICAgICAgICAgICBwcm9jZXNzRmlsdGVyZWQoY3AsIGN1cnJlbnQsIGNwLnN1YnBhcnNlZC5maWx0ZXIoaXNQbGFjZWhvbGRlcikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9sb2NhbFRhZ3MzLCBfY3AkdmFsdWUyO1xuICAgICAgICAgICAgICB2YXIgc2l6ZVNjb3BlID0gZ2V0U2NvcGVTaXplKHBhcnQsIGN1cnJlbnQucGFyZW50cyk7XG4gICAgICAgICAgICAgIGxvY2FsVGFncyA9IGdldExvY2FsVGFncyh0YWdzLCBjdXJyZW50LnBhdGgsIHNpemVTY29wZSk7XG4gICAgICAgICAgICAgIChfbG9jYWxUYWdzMyA9IGxvY2FsVGFncylbX2NwJHZhbHVlMiA9IGNwLnZhbHVlXSB8fCAoX2xvY2FsVGFnczNbX2NwJHZhbHVlMl0gPSB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQuZGF0YUJvdW5kID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIChfbG9jYWxUYWdzNCA9IGxvY2FsVGFncylbX3BhcnQkdmFsdWUyID0gcGFydC52YWx1ZV0gfHwgKF9sb2NhbFRhZ3M0W19wYXJ0JHZhbHVlMl0gPSB7fSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YWdzO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFRhZ3M6IGdldFRhZ3MsXG4gIGlzUGxhY2Vob2xkZXI6IGlzUGxhY2Vob2xkZXJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/get-tags.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/join-uncorrupt.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/join-uncorrupt.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  startsWith = _require.startsWith,\n  endsWith = _require.endsWith,\n  isStarting = _require.isStarting,\n  isEnding = _require.isEnding,\n  isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = __webpack_require__(/*! ./filetypes.js */ \"(rsc)/./node_modules/docxtemplater/js/filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n  var lastNonEmpty = \"\";\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var p = parts[i];\n    if (isWhiteSpace(p) || startsWith(p, \"<w:bookmarkEnd\")) {\n      continue;\n    }\n    if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n      if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\") &&\n      // Tested by #regression-paragraph-after-table-header-footer\n      !startsWith(p, \"</w:ftr>\") && !startsWith(p, \"</w:hdr>\")) {\n        p = \"<w:p/>\".concat(p);\n      }\n    }\n    lastNonEmpty = p;\n    parts[i] = p;\n  }\n  return parts;\n}\n\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || [];\n  /*\n   * Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * ------------------------------------------------\n   */\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n  if (filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n  var startIndex = -1;\n  for (var j = 0, len2 = contains.length; j < len2; j++) {\n    var _contains$j = contains[j],\n      tag = _contains$j.tag,\n      shouldContain = _contains$j.shouldContain,\n      value = _contains$j.value,\n      drop = _contains$j.drop,\n      dropParent = _contains$j.dropParent;\n    for (var i = 0, len = parts.length; i < len; i++) {\n      var part = parts[i];\n      if (currentlyCollecting === j) {\n        if (isEnding(part, tag)) {\n          currentlyCollecting = -1;\n          if (dropParent) {\n            var start = -1;\n            for (var k = startIndex; k > 0; k--) {\n              if (isStarting(parts[k], dropParent)) {\n                start = k;\n                break;\n              }\n            }\n            for (var _k = start; _k <= parts.length; _k++) {\n              if (isEnding(parts[_k], dropParent)) {\n                parts[_k] = \"\";\n                break;\n              }\n              parts[_k] = \"\";\n            }\n          } else {\n            for (var _k2 = startIndex; _k2 <= i; _k2++) {\n              parts[_k2] = \"\";\n            }\n            if (!drop) {\n              parts[i] = collecting + value + part;\n            }\n          }\n        }\n        collecting += part;\n        for (var _k3 = 0, len3 = shouldContain.length; _k3 < len3; _k3++) {\n          var sc = shouldContain[_k3];\n          if (isStarting(part, sc)) {\n            currentlyCollecting = -1;\n            break;\n          }\n        }\n      }\n      if (currentlyCollecting === -1 && isStarting(part, tag) &&\n      /*\n       * To verify that the part doesn't have multiple tags,\n       * such as <w:tc><w:p>\n       */\n      part.substr(1).indexOf(\"<\") === -1) {\n        // self-closing tag such as <w:t/>\n        if (part[part.length - 2] === \"/\") {\n          parts[i] = \"\";\n        } else {\n          startIndex = i;\n          currentlyCollecting = j;\n          collecting = part;\n        }\n      }\n    }\n  }\n  return parts;\n}\nmodule.exports = joinUncorrupt;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9qb2luLXVuY29ycnVwdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDeEM7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVyxRQUFRLFVBQVU7QUFDckMsUUFBUSxXQUFXLFFBQVEsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvam9pbi11bmNvcnJ1cHQuanM/NTRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBzdGFydHNXaXRoID0gX3JlcXVpcmUuc3RhcnRzV2l0aCxcbiAgZW5kc1dpdGggPSBfcmVxdWlyZS5lbmRzV2l0aCxcbiAgaXNTdGFydGluZyA9IF9yZXF1aXJlLmlzU3RhcnRpbmcsXG4gIGlzRW5kaW5nID0gX3JlcXVpcmUuaXNFbmRpbmcsXG4gIGlzV2hpdGVTcGFjZSA9IF9yZXF1aXJlLmlzV2hpdGVTcGFjZTtcbnZhciBmaWxldHlwZXMgPSByZXF1aXJlKFwiLi9maWxldHlwZXMuanNcIik7XG5mdW5jdGlvbiBhZGRFbXB0eVBhcmFncmFwaEFmdGVyVGFibGUocGFydHMpIHtcbiAgdmFyIGxhc3ROb25FbXB0eSA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwID0gcGFydHNbaV07XG4gICAgaWYgKGlzV2hpdGVTcGFjZShwKSB8fCBzdGFydHNXaXRoKHAsIFwiPHc6Ym9va21hcmtFbmRcIikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZW5kc1dpdGgobGFzdE5vbkVtcHR5LCBcIjwvdzp0Ymw+XCIpKSB7XG4gICAgICBpZiAoIXN0YXJ0c1dpdGgocCwgXCI8dzpwXCIpICYmICFzdGFydHNXaXRoKHAsIFwiPHc6dGJsXCIpICYmICFzdGFydHNXaXRoKHAsIFwiPHc6c2VjdFByXCIpICYmXG4gICAgICAvLyBUZXN0ZWQgYnkgI3JlZ3Jlc3Npb24tcGFyYWdyYXBoLWFmdGVyLXRhYmxlLWhlYWRlci1mb290ZXJcbiAgICAgICFzdGFydHNXaXRoKHAsIFwiPC93OmZ0cj5cIikgJiYgIXN0YXJ0c1dpdGgocCwgXCI8L3c6aGRyPlwiKSkge1xuICAgICAgICBwID0gXCI8dzpwLz5cIi5jb25jYXQocCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3ROb25FbXB0eSA9IHA7XG4gICAgcGFydHNbaV0gPSBwO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIGpvaW5VbmNvcnJ1cHQocGFydHMsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5zID0gb3B0aW9ucy5maWxlVHlwZUNvbmZpZy50YWdTaG91bGRDb250YWluIHx8IFtdO1xuICAvKlxuICAgKiBCZWZvcmUgZG9pbmcgdGhpcyBcInVuY29ycnVwdGlvblwiIG1ldGhvZCBoZXJlLCB0aGlzIHdhcyBkb25lIHdpdGggdGhlXG4gICAqIGBwYXJ0LmVtcHR5VmFsdWVgIHRyaWNrLCBob3dldmVyLCB0aGVyZSB3ZXJlIHNvbWUgY29ycnVwdGlvbnMgdGhhdCB3ZXJlXG4gICAqIG5vdCBoYW5kbGVkLCBmb3IgZXhhbXBsZSB3aXRoIGEgdGVtcGxhdGUgbGlrZSB0aGlzIDpcbiAgICpcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIHwgey13OnAgZmFsc3l9TXkgcGFyYXsvZmFsc3l9ICAgfCAgICAgICAgICAgICAgfFxuICAgKiB8IHstdzpwIGZhbHN5fU15IHBhcmF7L2ZhbHN5fSAgIHwgICAgICAgICAgICAgIHxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICB2YXIgY29sbGVjdGluZyA9IFwiXCI7XG4gIHZhciBjdXJyZW50bHlDb2xsZWN0aW5nID0gLTE7XG4gIGlmIChmaWxldHlwZXMuZG9jeC5pbmRleE9mKG9wdGlvbnMuY29udGVudFR5cGUpICE9PSAtMSkge1xuICAgIHBhcnRzID0gYWRkRW1wdHlQYXJhZ3JhcGhBZnRlclRhYmxlKHBhcnRzKTtcbiAgfVxuICB2YXIgc3RhcnRJbmRleCA9IC0xO1xuICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IGNvbnRhaW5zLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICAgIHZhciBfY29udGFpbnMkaiA9IGNvbnRhaW5zW2pdLFxuICAgICAgdGFnID0gX2NvbnRhaW5zJGoudGFnLFxuICAgICAgc2hvdWxkQ29udGFpbiA9IF9jb250YWlucyRqLnNob3VsZENvbnRhaW4sXG4gICAgICB2YWx1ZSA9IF9jb250YWlucyRqLnZhbHVlLFxuICAgICAgZHJvcCA9IF9jb250YWlucyRqLmRyb3AsXG4gICAgICBkcm9wUGFyZW50ID0gX2NvbnRhaW5zJGouZHJvcFBhcmVudDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAoY3VycmVudGx5Q29sbGVjdGluZyA9PT0gaikge1xuICAgICAgICBpZiAoaXNFbmRpbmcocGFydCwgdGFnKSkge1xuICAgICAgICAgIGN1cnJlbnRseUNvbGxlY3RpbmcgPSAtMTtcbiAgICAgICAgICBpZiAoZHJvcFBhcmVudCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gc3RhcnRJbmRleDsgayA+IDA7IGstLSkge1xuICAgICAgICAgICAgICBpZiAoaXNTdGFydGluZyhwYXJ0c1trXSwgZHJvcFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGs7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9rID0gc3RhcnQ7IF9rIDw9IHBhcnRzLmxlbmd0aDsgX2srKykge1xuICAgICAgICAgICAgICBpZiAoaXNFbmRpbmcocGFydHNbX2tdLCBkcm9wUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzW19rXSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFydHNbX2tdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgX2syID0gc3RhcnRJbmRleDsgX2syIDw9IGk7IF9rMisrKSB7XG4gICAgICAgICAgICAgIHBhcnRzW19rMl0gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkcm9wKSB7XG4gICAgICAgICAgICAgIHBhcnRzW2ldID0gY29sbGVjdGluZyArIHZhbHVlICsgcGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdGluZyArPSBwYXJ0O1xuICAgICAgICBmb3IgKHZhciBfazMgPSAwLCBsZW4zID0gc2hvdWxkQ29udGFpbi5sZW5ndGg7IF9rMyA8IGxlbjM7IF9rMysrKSB7XG4gICAgICAgICAgdmFyIHNjID0gc2hvdWxkQ29udGFpbltfazNdO1xuICAgICAgICAgIGlmIChpc1N0YXJ0aW5nKHBhcnQsIHNjKSkge1xuICAgICAgICAgICAgY3VycmVudGx5Q29sbGVjdGluZyA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudGx5Q29sbGVjdGluZyA9PT0gLTEgJiYgaXNTdGFydGluZyhwYXJ0LCB0YWcpICYmXG4gICAgICAvKlxuICAgICAgICogVG8gdmVyaWZ5IHRoYXQgdGhlIHBhcnQgZG9lc24ndCBoYXZlIG11bHRpcGxlIHRhZ3MsXG4gICAgICAgKiBzdWNoIGFzIDx3OnRjPjx3OnA+XG4gICAgICAgKi9cbiAgICAgIHBhcnQuc3Vic3RyKDEpLmluZGV4T2YoXCI8XCIpID09PSAtMSkge1xuICAgICAgICAvLyBzZWxmLWNsb3NpbmcgdGFnIHN1Y2ggYXMgPHc6dC8+XG4gICAgICAgIGlmIChwYXJ0W3BhcnQubGVuZ3RoIC0gMl0gPT09IFwiL1wiKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0SW5kZXggPSBpO1xuICAgICAgICAgIGN1cnJlbnRseUNvbGxlY3RpbmcgPSBqO1xuICAgICAgICAgIGNvbGxlY3RpbmcgPSBwYXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbm1vZHVsZS5leHBvcnRzID0gam9pblVuY29ycnVwdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/join-uncorrupt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/lexer.js":
/*!************************************************!*\
  !*** ./node_modules/docxtemplater/js/lexer.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8,\n  pushArray = _require2.pushArray;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var _i2 = 0; _i2 < textMatchArray.length; _i2++) {\n    var m = textMatchArray[_i2];\n    allMatches[m] = true;\n  }\n  for (var _i4 = 0; _i4 < othersMatchArray.length; _i4++) {\n    var _m = othersMatchArray[_i4];\n    allMatches[_m] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  var delimiterWithErrors = delimiterMatches.reduce(function (delimiterAcc, currDelimiterMatch) {\n    var position = currDelimiterMatch.position;\n    var delimiterOffset = currDelimiterMatch.offset;\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    var lastDelimiterLength = lastDelimiterMatch.length;\n    xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n    if (inDelimiter && position === \"start\") {\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        if (!syntaxOptions.allowUnclosedTag) {\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterOffset\n          }));\n          lastDelimiterMatch = currDelimiterMatch;\n          delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n            error: true\n          }));\n          return delimiterAcc;\n        }\n      }\n      if (!syntaxOptions.allowUnclosedTag) {\n        errors.push(getUnclosedTagException({\n          xtag: wordToUtf8(xtag),\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      delimiterAcc.pop();\n    }\n    if (!inDelimiter && position === \"end\") {\n      if (syntaxOptions.allowUnopenedTag) {\n        return delimiterAcc;\n      }\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateCloseTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnopenedTagException({\n        xtag: xtag,\n        offset: delimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    inDelimiter = position === \"start\";\n    lastDelimiterMatch = currDelimiterMatch;\n    delimiterAcc.push(currDelimiterMatch);\n    return delimiterAcc;\n  }, []);\n  if (inDelimiter) {\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n    if (!syntaxOptions.allowUnclosedTag) {\n      errors.push(getUnclosedTagException({\n        xtag: wordToUtf8(xtag),\n        offset: lastDelimiterOffset\n      }));\n    } else {\n      delimiterWithErrors.pop();\n    }\n  }\n  return {\n    delimiterWithErrors: delimiterWithErrors,\n    errors: errors\n  };\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    _err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw _err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters, syntaxOptions) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  if (start == null && end == null) {\n    // Special case of delimiter set to null/null, no templating is done\n    return [];\n  }\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    /*\n     * If tag starts with =, such as {=[ ]=}\n     * then the delimiters will change right after that tag.\n     *\n     * For example, with the following template :\n     *\n     * Hello {foo}, {=[ ]=}what's up with [name] ?\n     *\n     * The \"foo\" tag is a normal tag, the \"=[ ]=\" is a tag to change the\n     * delimiters to \"[\" and \"]\", and the last \"name\" is a tag with the new\n     * delimiters\n     */\n    if (syntaxOptions.changeDelimiterPrefix && compareResult === DELIMITER_START && fullText[offset + start.length] === syntaxOptions.changeDelimiterPrefix) {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(syntaxOptions.changeDelimiterPrefix, offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters, syntaxOptions);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions),\n    delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors,\n    errors = _getDelimiterErrors.errors;\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])) {\n      delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    for (var _i6 = 0; _i6 < delimitersInOffset.length; _i6++) {\n      var delimiterInOffset = delimitersInOffset[_i6];\n      var _value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (_value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: _value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        continue;\n      }\n      if (_value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: _value\n        });\n        cursor += _value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    }\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n  var inTextTag = false;\n  for (var _i8 = 0; _i8 < xmlparsed.length; _i8++) {\n    var part = xmlparsed[_i8];\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (fileType !== \"text\" && isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  }\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmllexed, delimiters, syntax, fileType) {\n    decodeContentParts(xmllexed, fileType);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    for (var _i0 = 0; _i0 < xmllexed.length; _i0++) {\n      var part = xmllexed[_i0];\n      if (isInsideContent(part)) {\n        for (var _i10 = 0, _delimiterParsed$inde2 = delimiterParsed[index]; _i10 < _delimiterParsed$inde2.length; _i10++) {\n          var p = _delimiterParsed$inde2[_i10];\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n        }\n        pushArray(lexed, delimiterParsed[index]);\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    }\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = [];\n    for (var _i12 = 0; _i12 < matches.length; _i12++) {\n      var match = matches[_i12];\n      if (content.length > cursor && match.offset - cursor > 0) {\n        parsed.push({\n          type: \"content\",\n          value: content.substr(cursor, match.offset - cursor)\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n    }\n    if (content.length > cursor) {\n      parsed.push({\n        type: \"content\",\n        value: content.substr(cursor)\n      });\n    }\n    return parsed;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9sZXhlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSx1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQyxvRUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDBEQUEwRCx5QkFBeUI7QUFDbkY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3REFBd0QseUJBQXlCO0FBQ2pGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJLEdBQUcsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQSw0RUFBNEUsc0NBQXNDO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2xleGVyLmpzP2I0ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldFVuY2xvc2VkVGFnRXhjZXB0aW9uLFxuICBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldFVub3BlbmVkVGFnRXhjZXB0aW9uLFxuICBnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uID0gX3JlcXVpcmUuZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbixcbiAgZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbixcbiAgdGhyb3dNYWxmb3JtZWRYbWwgPSBfcmVxdWlyZS50aHJvd01hbGZvcm1lZFhtbCxcbiAgdGhyb3dYbWxJbnZhbGlkID0gX3JlcXVpcmUudGhyb3dYbWxJbnZhbGlkLFxuICBYVFRlbXBsYXRlRXJyb3IgPSBfcmVxdWlyZS5YVFRlbXBsYXRlRXJyb3I7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBpc1RleHRTdGFydCA9IF9yZXF1aXJlMi5pc1RleHRTdGFydCxcbiAgaXNUZXh0RW5kID0gX3JlcXVpcmUyLmlzVGV4dEVuZCxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlMi53b3JkVG9VdGY4LFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZTIucHVzaEFycmF5O1xudmFyIERFTElNSVRFUl9OT05FID0gMCxcbiAgREVMSU1JVEVSX0VRVUFMID0gMSxcbiAgREVMSU1JVEVSX1NUQVJUID0gMixcbiAgREVMSU1JVEVSX0VORCA9IDM7XG5mdW5jdGlvbiBpblJhbmdlKHJhbmdlLCBtYXRjaCkge1xuICByZXR1cm4gcmFuZ2VbMF0gPD0gbWF0Y2gub2Zmc2V0ICYmIG1hdGNoLm9mZnNldCA8IHJhbmdlWzFdO1xufVxuZnVuY3Rpb24gdXBkYXRlSW5UZXh0VGFnKHBhcnQsIGluVGV4dFRhZykge1xuICBpZiAoaXNUZXh0U3RhcnQocGFydCkpIHtcbiAgICBpZiAoaW5UZXh0VGFnKSB7XG4gICAgICB0aHJvd01hbGZvcm1lZFhtbCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNUZXh0RW5kKHBhcnQpKSB7XG4gICAgaWYgKCFpblRleHRUYWcpIHtcbiAgICAgIHRocm93TWFsZm9ybWVkWG1sKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaW5UZXh0VGFnO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHRhZykge1xuICB2YXIgcG9zaXRpb24gPSBcIlwiO1xuICB2YXIgc3RhcnQgPSAxO1xuICB2YXIgZW5kID0gdGFnLmluZGV4T2YoXCIgXCIpO1xuICBpZiAodGFnW3RhZy5sZW5ndGggLSAyXSA9PT0gXCIvXCIpIHtcbiAgICBwb3NpdGlvbiA9IFwic2VsZmNsb3NpbmdcIjtcbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgZW5kID0gdGFnLmxlbmd0aCAtIDI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZ1sxXSA9PT0gXCIvXCIpIHtcbiAgICBzdGFydCA9IDI7XG4gICAgcG9zaXRpb24gPSBcImVuZFwiO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICBlbmQgPSB0YWcubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24gPSBcInN0YXJ0XCI7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIGVuZCA9IHRhZy5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9O1xufVxuZnVuY3Rpb24gdGFnTWF0Y2hlcihjb250ZW50LCB0ZXh0TWF0Y2hBcnJheSwgb3RoZXJzTWF0Y2hBcnJheSkge1xuICB2YXIgY3Vyc29yID0gMDtcbiAgdmFyIGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgdmFyIGFsbE1hdGNoZXMgPSB7fTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGV4dE1hdGNoQXJyYXkubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBtID0gdGV4dE1hdGNoQXJyYXlbX2kyXTtcbiAgICBhbGxNYXRjaGVzW21dID0gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBvdGhlcnNNYXRjaEFycmF5Lmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgX20gPSBvdGhlcnNNYXRjaEFycmF5W19pNF07XG4gICAgYWxsTWF0Y2hlc1tfbV0gPSBmYWxzZTtcbiAgfVxuICB2YXIgdG90YWxNYXRjaGVzID0gW107XG4gIHdoaWxlIChjdXJzb3IgPCBjb250ZW50TGVuZ3RoKSB7XG4gICAgY3Vyc29yID0gY29udGVudC5pbmRleE9mKFwiPFwiLCBjdXJzb3IpO1xuICAgIGlmIChjdXJzb3IgPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IGN1cnNvcjtcbiAgICB2YXIgbmV4dE9wZW5pbmcgPSBjb250ZW50LmluZGV4T2YoXCI8XCIsIGN1cnNvciArIDEpO1xuICAgIGN1cnNvciA9IGNvbnRlbnQuaW5kZXhPZihcIj5cIiwgY3Vyc29yKTtcbiAgICBpZiAoY3Vyc29yID09PSAtMSB8fCBuZXh0T3BlbmluZyAhPT0gLTEgJiYgY3Vyc29yID4gbmV4dE9wZW5pbmcpIHtcbiAgICAgIHRocm93WG1sSW52YWxpZChjb250ZW50LCBvZmZzZXQpO1xuICAgIH1cbiAgICB2YXIgdGFnVGV4dCA9IGNvbnRlbnQuc2xpY2Uob2Zmc2V0LCBjdXJzb3IgKyAxKTtcbiAgICB2YXIgX2dldFRhZyA9IGdldFRhZyh0YWdUZXh0KSxcbiAgICAgIHRhZyA9IF9nZXRUYWcudGFnLFxuICAgICAgcG9zaXRpb24gPSBfZ2V0VGFnLnBvc2l0aW9uO1xuICAgIHZhciB0ZXh0ID0gYWxsTWF0Y2hlc1t0YWddO1xuICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0b3RhbE1hdGNoZXMucHVzaCh7XG4gICAgICB0eXBlOiBcInRhZ1wiLFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgdmFsdWU6IHRhZ1RleHQsXG4gICAgICB0YWc6IHRhZ1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b3RhbE1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZXREZWxpbWl0ZXJFcnJvcnMoZGVsaW1pdGVyTWF0Y2hlcywgZnVsbFRleHQsIHN5bnRheE9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgaW5EZWxpbWl0ZXIgPSBmYWxzZTtcbiAgdmFyIGxhc3REZWxpbWl0ZXJNYXRjaCA9IHtcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbiAgdmFyIHh0YWc7XG4gIHZhciBkZWxpbWl0ZXJXaXRoRXJyb3JzID0gZGVsaW1pdGVyTWF0Y2hlcy5yZWR1Y2UoZnVuY3Rpb24gKGRlbGltaXRlckFjYywgY3VyckRlbGltaXRlck1hdGNoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gY3VyckRlbGltaXRlck1hdGNoLnBvc2l0aW9uO1xuICAgIHZhciBkZWxpbWl0ZXJPZmZzZXQgPSBjdXJyRGVsaW1pdGVyTWF0Y2gub2Zmc2V0O1xuICAgIHZhciBsYXN0RGVsaW1pdGVyT2Zmc2V0ID0gbGFzdERlbGltaXRlck1hdGNoLm9mZnNldDtcbiAgICB2YXIgbGFzdERlbGltaXRlckxlbmd0aCA9IGxhc3REZWxpbWl0ZXJNYXRjaC5sZW5ndGg7XG4gICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0LCBkZWxpbWl0ZXJPZmZzZXQgLSBsYXN0RGVsaW1pdGVyT2Zmc2V0KTtcbiAgICBpZiAoaW5EZWxpbWl0ZXIgJiYgcG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgaWYgKGxhc3REZWxpbWl0ZXJPZmZzZXQgKyBsYXN0RGVsaW1pdGVyTGVuZ3RoID09PSBkZWxpbWl0ZXJPZmZzZXQpIHtcbiAgICAgICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0LCBkZWxpbWl0ZXJPZmZzZXQgLSBsYXN0RGVsaW1pdGVyT2Zmc2V0ICsgbGFzdERlbGltaXRlckxlbmd0aCArIDQpO1xuICAgICAgICBpZiAoIXN5bnRheE9wdGlvbnMuYWxsb3dVbmNsb3NlZFRhZykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24oe1xuICAgICAgICAgICAgeHRhZzogeHRhZyxcbiAgICAgICAgICAgIG9mZnNldDogbGFzdERlbGltaXRlck9mZnNldFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBsYXN0RGVsaW1pdGVyTWF0Y2ggPSBjdXJyRGVsaW1pdGVyTWF0Y2g7XG4gICAgICAgICAgZGVsaW1pdGVyQWNjLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyRGVsaW1pdGVyTWF0Y2gpLCB7fSwge1xuICAgICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzeW50YXhPcHRpb25zLmFsbG93VW5jbG9zZWRUYWcpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24oe1xuICAgICAgICAgIHh0YWc6IHdvcmRUb1V0ZjgoeHRhZyksXG4gICAgICAgICAgb2Zmc2V0OiBsYXN0RGVsaW1pdGVyT2Zmc2V0XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgICBkZWxpbWl0ZXJBY2MucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJEZWxpbWl0ZXJNYXRjaCksIHt9LCB7XG4gICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgICAgfVxuICAgICAgZGVsaW1pdGVyQWNjLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoIWluRGVsaW1pdGVyICYmIHBvc2l0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICBpZiAoc3ludGF4T3B0aW9ucy5hbGxvd1Vub3BlbmVkVGFnKSB7XG4gICAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgICB9XG4gICAgICBpZiAobGFzdERlbGltaXRlck9mZnNldCArIGxhc3REZWxpbWl0ZXJMZW5ndGggPT09IGRlbGltaXRlck9mZnNldCkge1xuICAgICAgICB4dGFnID0gZnVsbFRleHQuc3Vic3RyKGxhc3REZWxpbWl0ZXJPZmZzZXQgLSA0LCBkZWxpbWl0ZXJPZmZzZXQgLSBsYXN0RGVsaW1pdGVyT2Zmc2V0ICsgbGFzdERlbGltaXRlckxlbmd0aCArIDQpO1xuICAgICAgICBlcnJvcnMucHVzaChnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbih7XG4gICAgICAgICAgeHRhZzogeHRhZyxcbiAgICAgICAgICBvZmZzZXQ6IGxhc3REZWxpbWl0ZXJPZmZzZXRcbiAgICAgICAgfSkpO1xuICAgICAgICBsYXN0RGVsaW1pdGVyTWF0Y2ggPSBjdXJyRGVsaW1pdGVyTWF0Y2g7XG4gICAgICAgIGRlbGltaXRlckFjYy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3VyckRlbGltaXRlck1hdGNoKSwge30sIHtcbiAgICAgICAgICBlcnJvcjogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgICB9XG4gICAgICBlcnJvcnMucHVzaChnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbih7XG4gICAgICAgIHh0YWc6IHh0YWcsXG4gICAgICAgIG9mZnNldDogZGVsaW1pdGVyT2Zmc2V0XG4gICAgICB9KSk7XG4gICAgICBsYXN0RGVsaW1pdGVyTWF0Y2ggPSBjdXJyRGVsaW1pdGVyTWF0Y2g7XG4gICAgICBkZWxpbWl0ZXJBY2MucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJEZWxpbWl0ZXJNYXRjaCksIHt9LCB7XG4gICAgICAgIGVycm9yOiB0cnVlXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgIH1cbiAgICBpbkRlbGltaXRlciA9IHBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG4gICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgIGRlbGltaXRlckFjYy5wdXNoKGN1cnJEZWxpbWl0ZXJNYXRjaCk7XG4gICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgfSwgW10pO1xuICBpZiAoaW5EZWxpbWl0ZXIpIHtcbiAgICB2YXIgbGFzdERlbGltaXRlck9mZnNldCA9IGxhc3REZWxpbWl0ZXJNYXRjaC5vZmZzZXQ7XG4gICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0LCBmdWxsVGV4dC5sZW5ndGggLSBsYXN0RGVsaW1pdGVyT2Zmc2V0KTtcbiAgICBpZiAoIXN5bnRheE9wdGlvbnMuYWxsb3dVbmNsb3NlZFRhZykge1xuICAgICAgZXJyb3JzLnB1c2goZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24oe1xuICAgICAgICB4dGFnOiB3b3JkVG9VdGY4KHh0YWcpLFxuICAgICAgICBvZmZzZXQ6IGxhc3REZWxpbWl0ZXJPZmZzZXRcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsaW1pdGVyV2l0aEVycm9ycy5wb3AoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZWxpbWl0ZXJXaXRoRXJyb3JzOiBkZWxpbWl0ZXJXaXRoRXJyb3JzLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBjb21wYXJlT2Zmc2V0cyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gIGlmIChzdGFydE9mZnNldCA9PT0gLTEgJiYgZW5kT2Zmc2V0ID09PSAtMSkge1xuICAgIHJldHVybiBERUxJTUlURVJfTk9ORTtcbiAgfVxuICBpZiAoc3RhcnRPZmZzZXQgPT09IGVuZE9mZnNldCkge1xuICAgIHJldHVybiBERUxJTUlURVJfRVFVQUw7XG4gIH1cbiAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAtMSB8fCBlbmRPZmZzZXQgPT09IC0xKSB7XG4gICAgcmV0dXJuIGVuZE9mZnNldCA8IHN0YXJ0T2Zmc2V0ID8gREVMSU1JVEVSX1NUQVJUIDogREVMSU1JVEVSX0VORDtcbiAgfVxuICByZXR1cm4gc3RhcnRPZmZzZXQgPCBlbmRPZmZzZXQgPyBERUxJTUlURVJfU1RBUlQgOiBERUxJTUlURVJfRU5EO1xufVxuZnVuY3Rpb24gc3BsaXREZWxpbWl0ZXJzKGluc2lkZSkge1xuICB2YXIgbmV3RGVsaW1pdGVycyA9IGluc2lkZS5zcGxpdChcIiBcIik7XG4gIGlmIChuZXdEZWxpbWl0ZXJzLmxlbmd0aCAhPT0gMikge1xuICAgIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTmV3IERlbGltaXRlcnMgY2Fubm90IGJlIHBhcnNlZFwiKTtcbiAgICBlcnIucHJvcGVydGllcyA9IHtcbiAgICAgIGlkOiBcImNoYW5nZV9kZWxpbWl0ZXJzX2ludmFsaWRcIixcbiAgICAgIGV4cGxhbmF0aW9uOiBcIkNhbm5vdCBwYXJzZXIgZGVsaW1pdGVyc1wiXG4gICAgfTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgdmFyIF9uZXdEZWxpbWl0ZXJzID0gX3NsaWNlZFRvQXJyYXkobmV3RGVsaW1pdGVycywgMiksXG4gICAgc3RhcnQgPSBfbmV3RGVsaW1pdGVyc1swXSxcbiAgICBlbmQgPSBfbmV3RGVsaW1pdGVyc1sxXTtcbiAgaWYgKHN0YXJ0Lmxlbmd0aCA9PT0gMCB8fCBlbmQubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIF9lcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTmV3IERlbGltaXRlcnMgY2Fubm90IGJlIHBhcnNlZFwiKTtcbiAgICBfZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICBpZDogXCJjaGFuZ2VfZGVsaW1pdGVyc19pbnZhbGlkXCIsXG4gICAgICBleHBsYW5hdGlvbjogXCJDYW5ub3QgcGFyc2VyIGRlbGltaXRlcnNcIlxuICAgIH07XG4gICAgdGhyb3cgX2VycjtcbiAgfVxuICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xufVxuZnVuY3Rpb24gZ2V0QWxsRGVsaW1pdGVySW5kZXhlcyhmdWxsVGV4dCwgZGVsaW1pdGVycywgc3ludGF4T3B0aW9ucykge1xuICB2YXIgaW5kZXhlcyA9IFtdO1xuICB2YXIgc3RhcnQgPSBkZWxpbWl0ZXJzLnN0YXJ0LFxuICAgIGVuZCA9IGRlbGltaXRlcnMuZW5kO1xuICB2YXIgb2Zmc2V0ID0gLTE7XG4gIHZhciBpbnNpZGVUYWcgPSBmYWxzZTtcbiAgaWYgKHN0YXJ0ID09IG51bGwgJiYgZW5kID09IG51bGwpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2Ugb2YgZGVsaW1pdGVyIHNldCB0byBudWxsL251bGwsIG5vIHRlbXBsYXRpbmcgaXMgZG9uZVxuICAgIHJldHVybiBbXTtcbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IGZ1bGxUZXh0LmluZGV4T2Yoc3RhcnQsIG9mZnNldCArIDEpO1xuICAgIHZhciBlbmRPZmZzZXQgPSBmdWxsVGV4dC5pbmRleE9mKGVuZCwgb2Zmc2V0ICsgMSk7XG4gICAgdmFyIHBvc2l0aW9uID0gbnVsbDtcbiAgICB2YXIgbGVuID0gdm9pZCAwO1xuICAgIHZhciBjb21wYXJlUmVzdWx0ID0gY29tcGFyZU9mZnNldHMoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgaWYgKGNvbXBhcmVSZXN1bHQgPT09IERFTElNSVRFUl9FUVVBTCkge1xuICAgICAgY29tcGFyZVJlc3VsdCA9IGluc2lkZVRhZyA/IERFTElNSVRFUl9FTkQgOiBERUxJTUlURVJfU1RBUlQ7XG4gICAgfVxuICAgIHN3aXRjaCAoY29tcGFyZVJlc3VsdCkge1xuICAgICAgY2FzZSBERUxJTUlURVJfTk9ORTpcbiAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICBjYXNlIERFTElNSVRFUl9FTkQ6XG4gICAgICAgIGluc2lkZVRhZyA9IGZhbHNlO1xuICAgICAgICBvZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uID0gXCJlbmRcIjtcbiAgICAgICAgbGVuID0gZW5kLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERFTElNSVRFUl9TVEFSVDpcbiAgICAgICAgaW5zaWRlVGFnID0gdHJ1ZTtcbiAgICAgICAgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uID0gXCJzdGFydFwiO1xuICAgICAgICBsZW4gPSBzdGFydC5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvKlxuICAgICAqIElmIHRhZyBzdGFydHMgd2l0aCA9LCBzdWNoIGFzIHs9WyBdPX1cbiAgICAgKiB0aGVuIHRoZSBkZWxpbWl0ZXJzIHdpbGwgY2hhbmdlIHJpZ2h0IGFmdGVyIHRoYXQgdGFnLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdpdGggdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSA6XG4gICAgICpcbiAgICAgKiBIZWxsbyB7Zm9vfSwgez1bIF09fXdoYXQncyB1cCB3aXRoIFtuYW1lXSA/XG4gICAgICpcbiAgICAgKiBUaGUgXCJmb29cIiB0YWcgaXMgYSBub3JtYWwgdGFnLCB0aGUgXCI9WyBdPVwiIGlzIGEgdGFnIHRvIGNoYW5nZSB0aGVcbiAgICAgKiBkZWxpbWl0ZXJzIHRvIFwiW1wiIGFuZCBcIl1cIiwgYW5kIHRoZSBsYXN0IFwibmFtZVwiIGlzIGEgdGFnIHdpdGggdGhlIG5ld1xuICAgICAqIGRlbGltaXRlcnNcbiAgICAgKi9cbiAgICBpZiAoc3ludGF4T3B0aW9ucy5jaGFuZ2VEZWxpbWl0ZXJQcmVmaXggJiYgY29tcGFyZVJlc3VsdCA9PT0gREVMSU1JVEVSX1NUQVJUICYmIGZ1bGxUZXh0W29mZnNldCArIHN0YXJ0Lmxlbmd0aF0gPT09IHN5bnRheE9wdGlvbnMuY2hhbmdlRGVsaW1pdGVyUHJlZml4KSB7XG4gICAgICBpbmRleGVzLnB1c2goe1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbjogXCJzdGFydFwiLFxuICAgICAgICBsZW5ndGg6IHN0YXJ0Lmxlbmd0aCxcbiAgICAgICAgY2hhbmdlZGVsaW1pdGVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBuZXh0RXF1YWwgPSBmdWxsVGV4dC5pbmRleE9mKHN5bnRheE9wdGlvbnMuY2hhbmdlRGVsaW1pdGVyUHJlZml4LCBvZmZzZXQgKyBzdGFydC5sZW5ndGggKyAxKTtcbiAgICAgIHZhciBuZXh0RW5kT2Zmc2V0ID0gZnVsbFRleHQuaW5kZXhPZihlbmQsIG5leHRFcXVhbCArIDEpO1xuICAgICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgICAgb2Zmc2V0OiBuZXh0RW5kT2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbjogXCJlbmRcIixcbiAgICAgICAgbGVuZ3RoOiBlbmQubGVuZ3RoLFxuICAgICAgICBjaGFuZ2VkZWxpbWl0ZXI6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFyIF9pbnNpZGVUYWcgPSBmdWxsVGV4dC5zdWJzdHIob2Zmc2V0ICsgc3RhcnQubGVuZ3RoICsgMSwgbmV4dEVxdWFsIC0gb2Zmc2V0IC0gc3RhcnQubGVuZ3RoIC0gMSk7XG4gICAgICB2YXIgX3NwbGl0RGVsaW1pdGVycyA9IHNwbGl0RGVsaW1pdGVycyhfaW5zaWRlVGFnKTtcbiAgICAgIHZhciBfc3BsaXREZWxpbWl0ZXJzMiA9IF9zbGljZWRUb0FycmF5KF9zcGxpdERlbGltaXRlcnMsIDIpO1xuICAgICAgc3RhcnQgPSBfc3BsaXREZWxpbWl0ZXJzMlswXTtcbiAgICAgIGVuZCA9IF9zcGxpdERlbGltaXRlcnMyWzFdO1xuICAgICAgb2Zmc2V0ID0gbmV4dEVuZE9mZnNldDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbmRleGVzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICBsZW5ndGg6IGxlblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZURlbGltaXRlcnMoaW5uZXJDb250ZW50UGFydHMsIGRlbGltaXRlcnMsIHN5bnRheE9wdGlvbnMpIHtcbiAgdmFyIGZ1bGwgPSBpbm5lckNvbnRlbnRQYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC52YWx1ZTtcbiAgfSkuam9pbihcIlwiKTtcbiAgdmFyIGRlbGltaXRlck1hdGNoZXMgPSBnZXRBbGxEZWxpbWl0ZXJJbmRleGVzKGZ1bGwsIGRlbGltaXRlcnMsIHN5bnRheE9wdGlvbnMpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIHJhbmdlcyA9IGlubmVyQ29udGVudFBhcnRzLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgIG9mZnNldCArPSBwYXJ0LnZhbHVlLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBwYXJ0LnZhbHVlLmxlbmd0aCxcbiAgICAgIGxJbmRleDogcGFydC5sSW5kZXhcbiAgICB9O1xuICB9KTtcbiAgdmFyIF9nZXREZWxpbWl0ZXJFcnJvcnMgPSBnZXREZWxpbWl0ZXJFcnJvcnMoZGVsaW1pdGVyTWF0Y2hlcywgZnVsbCwgc3ludGF4T3B0aW9ucyksXG4gICAgZGVsaW1pdGVyV2l0aEVycm9ycyA9IF9nZXREZWxpbWl0ZXJFcnJvcnMuZGVsaW1pdGVyV2l0aEVycm9ycyxcbiAgICBlcnJvcnMgPSBfZ2V0RGVsaW1pdGVyRXJyb3JzLmVycm9ycztcbiAgdmFyIGN1dE5leHQgPSAwO1xuICB2YXIgZGVsaW1pdGVySW5kZXggPSAwO1xuICB2YXIgcGFyc2VkID0gcmFuZ2VzLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgIHZhciBvZmZzZXQgPSBwLm9mZnNldDtcbiAgICB2YXIgcmFuZ2UgPSBbb2Zmc2V0LCBvZmZzZXQgKyBpbm5lckNvbnRlbnRQYXJ0c1tpXS52YWx1ZS5sZW5ndGhdO1xuICAgIHZhciBwYXJ0Q29udGVudCA9IGlubmVyQ29udGVudFBhcnRzW2ldLnZhbHVlO1xuICAgIHZhciBkZWxpbWl0ZXJzSW5PZmZzZXQgPSBbXTtcbiAgICB3aGlsZSAoZGVsaW1pdGVySW5kZXggPCBkZWxpbWl0ZXJXaXRoRXJyb3JzLmxlbmd0aCAmJiBpblJhbmdlKHJhbmdlLCBkZWxpbWl0ZXJXaXRoRXJyb3JzW2RlbGltaXRlckluZGV4XSkpIHtcbiAgICAgIGRlbGltaXRlcnNJbk9mZnNldC5wdXNoKGRlbGltaXRlcldpdGhFcnJvcnNbZGVsaW1pdGVySW5kZXhdKTtcbiAgICAgIGRlbGltaXRlckluZGV4Kys7XG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBjdXJzb3IgPSAwO1xuICAgIGlmIChjdXROZXh0ID4gMCkge1xuICAgICAgY3Vyc29yID0gY3V0TmV4dDtcbiAgICAgIGN1dE5leHQgPSAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBkZWxpbWl0ZXJzSW5PZmZzZXQubGVuZ3RoOyBfaTYrKykge1xuICAgICAgdmFyIGRlbGltaXRlckluT2Zmc2V0ID0gZGVsaW1pdGVyc0luT2Zmc2V0W19pNl07XG4gICAgICB2YXIgX3ZhbHVlID0gcGFydENvbnRlbnQuc3Vic3RyKGN1cnNvciwgZGVsaW1pdGVySW5PZmZzZXQub2Zmc2V0IC0gb2Zmc2V0IC0gY3Vyc29yKTtcbiAgICAgIGlmIChkZWxpbWl0ZXJJbk9mZnNldC5jaGFuZ2VkZWxpbWl0ZXIpIHtcbiAgICAgICAgaWYgKGRlbGltaXRlckluT2Zmc2V0LnBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICBpZiAoX3ZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnNvciA9IGRlbGltaXRlckluT2Zmc2V0Lm9mZnNldCAtIG9mZnNldCArIGRlbGltaXRlckluT2Zmc2V0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChfdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJzb3IgKz0gX3ZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciBkZWxpbWl0ZXJQYXJ0ID0ge1xuICAgICAgICB0eXBlOiBcImRlbGltaXRlclwiLFxuICAgICAgICBwb3NpdGlvbjogZGVsaW1pdGVySW5PZmZzZXQucG9zaXRpb24sXG4gICAgICAgIG9mZnNldDogY3Vyc29yICsgb2Zmc2V0XG4gICAgICB9O1xuICAgICAgcGFydHMucHVzaChkZWxpbWl0ZXJQYXJ0KTtcbiAgICAgIGN1cnNvciA9IGRlbGltaXRlckluT2Zmc2V0Lm9mZnNldCAtIG9mZnNldCArIGRlbGltaXRlckluT2Zmc2V0Lmxlbmd0aDtcbiAgICB9XG4gICAgY3V0TmV4dCA9IGN1cnNvciAtIHBhcnRDb250ZW50Lmxlbmd0aDtcbiAgICB2YXIgdmFsdWUgPSBwYXJ0Q29udGVudC5zdWJzdHIoY3Vyc29yKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH0sIHRoaXMpO1xuICByZXR1cm4ge1xuICAgIHBhcnNlZDogcGFyc2VkLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBpc0luc2lkZUNvbnRlbnQocGFydCkge1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGUgcGFydC5wb3NpdGlvbiA9PT0gXCJpbnNpZGV0YWdcIiB3b3VsZCBiZSBlbm91Z2ggYnV0IHdlIHdhbnQgdG8gbWFrZSB0aGUgQVBJIGZ1dHVyZSBwcm9vZlxuICByZXR1cm4gcGFydC50eXBlID09PSBcImNvbnRlbnRcIiAmJiBwYXJ0LnBvc2l0aW9uID09PSBcImluc2lkZXRhZ1wiO1xuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG59XG5mdW5jdGlvbiBnZXRDb250ZW50UGFydHMoeG1scGFyc2VkKSB7XG4gIHJldHVybiB4bWxwYXJzZWQuZmlsdGVyKGlzSW5zaWRlQ29udGVudCk7XG59XG5mdW5jdGlvbiBkZWNvZGVDb250ZW50UGFydHMoeG1scGFyc2VkLCBmaWxlVHlwZSkge1xuICB2YXIgaW5UZXh0VGFnID0gZmFsc2U7XG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IHhtbHBhcnNlZC5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIHBhcnQgPSB4bWxwYXJzZWRbX2k4XTtcbiAgICBpblRleHRUYWcgPSB1cGRhdGVJblRleHRUYWcocGFydCwgaW5UZXh0VGFnKTtcbiAgICBpZiAocGFydC50eXBlID09PSBcImNvbnRlbnRcIikge1xuICAgICAgcGFydC5wb3NpdGlvbiA9IGluVGV4dFRhZyA/IFwiaW5zaWRldGFnXCIgOiBcIm91dHNpZGV0YWdcIjtcbiAgICB9XG4gICAgaWYgKGZpbGVUeXBlICE9PSBcInRleHRcIiAmJiBpc0luc2lkZUNvbnRlbnQocGFydCkpIHtcbiAgICAgIHBhcnQudmFsdWUgPSBwYXJ0LnZhbHVlLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlRGVsaW1pdGVyczogcGFyc2VEZWxpbWl0ZXJzLFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoeG1sbGV4ZWQsIGRlbGltaXRlcnMsIHN5bnRheCwgZmlsZVR5cGUpIHtcbiAgICBkZWNvZGVDb250ZW50UGFydHMoeG1sbGV4ZWQsIGZpbGVUeXBlKTtcbiAgICB2YXIgX3BhcnNlRGVsaW1pdGVycyA9IHBhcnNlRGVsaW1pdGVycyhnZXRDb250ZW50UGFydHMoeG1sbGV4ZWQpLCBkZWxpbWl0ZXJzLCBzeW50YXgpLFxuICAgICAgZGVsaW1pdGVyUGFyc2VkID0gX3BhcnNlRGVsaW1pdGVycy5wYXJzZWQsXG4gICAgICBlcnJvcnMgPSBfcGFyc2VEZWxpbWl0ZXJzLmVycm9ycztcbiAgICB2YXIgbGV4ZWQgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsSW5kZXggPSAwO1xuICAgIGZvciAodmFyIF9pMCA9IDA7IF9pMCA8IHhtbGxleGVkLmxlbmd0aDsgX2kwKyspIHtcbiAgICAgIHZhciBwYXJ0ID0geG1sbGV4ZWRbX2kwXTtcbiAgICAgIGlmIChpc0luc2lkZUNvbnRlbnQocGFydCkpIHtcbiAgICAgICAgZm9yICh2YXIgX2kxMCA9IDAsIF9kZWxpbWl0ZXJQYXJzZWQkaW5kZTIgPSBkZWxpbWl0ZXJQYXJzZWRbaW5kZXhdOyBfaTEwIDwgX2RlbGltaXRlclBhcnNlZCRpbmRlMi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgICAgIHZhciBwID0gX2RlbGltaXRlclBhcnNlZCRpbmRlMltfaTEwXTtcbiAgICAgICAgICBpZiAocC50eXBlID09PSBcImNvbnRlbnRcIikge1xuICAgICAgICAgICAgcC5wb3NpdGlvbiA9IFwiaW5zaWRldGFnXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHAubEluZGV4ID0gbEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaEFycmF5KGxleGVkLCBkZWxpbWl0ZXJQYXJzZWRbaW5kZXhdKTtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQubEluZGV4ID0gbEluZGV4Kys7XG4gICAgICAgIGxleGVkLnB1c2gocGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgIGxleGVkOiBsZXhlZFxuICAgIH07XG4gIH0sXG4gIHhtbHBhcnNlOiBmdW5jdGlvbiB4bWxwYXJzZShjb250ZW50LCB4bWx0YWdzKSB7XG4gICAgdmFyIG1hdGNoZXMgPSB0YWdNYXRjaGVyKGNvbnRlbnQsIHhtbHRhZ3MudGV4dCwgeG1sdGFncy5vdGhlcik7XG4gICAgdmFyIGN1cnNvciA9IDA7XG4gICAgdmFyIHBhcnNlZCA9IFtdO1xuICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbWF0Y2hlcy5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgdmFyIG1hdGNoID0gbWF0Y2hlc1tfaTEyXTtcbiAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA+IGN1cnNvciAmJiBtYXRjaC5vZmZzZXQgLSBjdXJzb3IgPiAwKSB7XG4gICAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgICB2YWx1ZTogY29udGVudC5zdWJzdHIoY3Vyc29yLCBtYXRjaC5vZmZzZXQgLSBjdXJzb3IpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY3Vyc29yID0gbWF0Y2gub2Zmc2V0ICsgbWF0Y2gudmFsdWUubGVuZ3RoO1xuICAgICAgZGVsZXRlIG1hdGNoLm9mZnNldDtcbiAgICAgIHBhcnNlZC5wdXNoKG1hdGNoKTtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID4gY3Vyc29yKSB7XG4gICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgICAgICB2YWx1ZTogY29udGVudC5zdWJzdHIoY3Vyc29yKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/lexer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/merge-sort.js":
/*!*****************************************************!*\
  !*** ./node_modules/docxtemplater/js/merge-sort.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\nfunction getMinFromArrays(arrays, state) {\n  var minIndex = -1;\n  for (var i = 0, l = arrays.length; i < l; i++) {\n    if (state[i] >= arrays[i].length) {\n      continue;\n    }\n    if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n}\nmodule.exports = function (arrays) {\n  var totalLength = 0;\n  for (var _i2 = 0, _arrays2 = arrays; _i2 < _arrays2.length; _i2++) {\n    var array = _arrays2[_i2];\n    totalLength += array.length;\n  }\n  arrays = arrays.filter(function (array) {\n    return array.length > 0;\n  });\n  var resultArray = new Array(totalLength);\n  var state = arrays.map(function () {\n    return 0;\n  });\n  for (var i = 0; i < totalLength; i++) {\n    var arrayIndex = getMinFromArrays(arrays, state);\n    resultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n    state[arrayIndex]++;\n  }\n  return resultArray;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tZXJnZS1zb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbWVyZ2Utc29ydC5qcz8xMDBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBnZXRNaW5Gcm9tQXJyYXlzKGFycmF5cywgc3RhdGUpIHtcbiAgdmFyIG1pbkluZGV4ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZVtpXSA+PSBhcnJheXNbaV0ubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1pbkluZGV4ID09PSAtMSB8fCBhcnJheXNbaV1bc3RhdGVbaV1dLm9mZnNldCA8IGFycmF5c1ttaW5JbmRleF1bc3RhdGVbbWluSW5kZXhdXS5vZmZzZXQpIHtcbiAgICAgIG1pbkluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbkluZGV4O1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXlzKSB7XG4gIHZhciB0b3RhbExlbmd0aCA9IDA7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9hcnJheXMyID0gYXJyYXlzOyBfaTIgPCBfYXJyYXlzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIGFycmF5ID0gX2FycmF5czJbX2kyXTtcbiAgICB0b3RhbExlbmd0aCArPSBhcnJheS5sZW5ndGg7XG4gIH1cbiAgYXJyYXlzID0gYXJyYXlzLmZpbHRlcihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkubGVuZ3RoID4gMDtcbiAgfSk7XG4gIHZhciByZXN1bHRBcnJheSA9IG5ldyBBcnJheSh0b3RhbExlbmd0aCk7XG4gIHZhciBzdGF0ZSA9IGFycmF5cy5tYXAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbExlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFycmF5SW5kZXggPSBnZXRNaW5Gcm9tQXJyYXlzKGFycmF5cywgc3RhdGUpO1xuICAgIHJlc3VsdEFycmF5W2ldID0gYXJyYXlzW2FycmF5SW5kZXhdW3N0YXRlW2FycmF5SW5kZXhdXTtcbiAgICBzdGF0ZVthcnJheUluZGV4XSsrO1xuICB9XG4gIHJldHVybiByZXN1bHRBcnJheTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/merge-sort.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/minizod.js":
/*!**************************************************!*\
  !*** ./node_modules/docxtemplater/js/minizod.js ***!
  \**************************************************/
/***/ ((module) => {

eval("\n\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar MiniZod = /*#__PURE__*/function () {\n  function MiniZod() {\n    _classCallCheck(this, MiniZod);\n  }\n  return _createClass(MiniZod, null, [{\n    key: \"createSchema\",\n    value: function createSchema(validateFn) {\n      var schema = {\n        validate: validateFn,\n        optional: function optional() {\n          return MiniZod.createSchema(function (value) {\n            return value === undefined ? {\n              success: true,\n              value: value\n            } : validateFn(value);\n          });\n        },\n        nullable: function nullable() {\n          return MiniZod.createSchema(function (value) {\n            return value == null ? {\n              success: true,\n              value: value\n            } : validateFn(value);\n          });\n        }\n      };\n      return schema;\n    }\n  }, {\n    key: \"string\",\n    value: function string() {\n      return MiniZod.createSchema(function (value) {\n        if (typeof value !== \"string\") {\n          return {\n            success: false,\n            error: \"Expected string, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"date\",\n    value: function date() {\n      return MiniZod.createSchema(function (value) {\n        if (!(value instanceof Date)) {\n          return {\n            success: false,\n            error: \"Expected date, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"boolean\",\n    value: function _boolean() {\n      return MiniZod.createSchema(function (value) {\n        if (typeof value !== \"boolean\") {\n          return {\n            success: false,\n            error: \"Expected boolean, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"number\",\n    value: function number() {\n      return MiniZod.createSchema(function (value) {\n        if (typeof value !== \"number\") {\n          return {\n            success: false,\n            error: \"Expected number, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"function\",\n    value: function _function() {\n      return MiniZod.createSchema(function (value) {\n        if (typeof value !== \"function\") {\n          return {\n            success: false,\n            error: \"Expected function, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"array\",\n    value: function array(itemSchema) {\n      return MiniZod.createSchema(function (value) {\n        if (!Array.isArray(value)) {\n          return {\n            success: false,\n            error: \"Expected array, received \".concat(_typeof(value))\n          };\n        }\n        for (var i = 0; i < value.length; i++) {\n          var result = itemSchema.validate(value[i]);\n          if (!result.success) {\n            return {\n              success: false,\n              error: \"\".concat(result.error, \" at index \").concat(i)\n            };\n          }\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"any\",\n    value: function any() {\n      return MiniZod.createSchema(function (value) {\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"isRegex\",\n    value: function isRegex() {\n      return MiniZod.createSchema(function (value) {\n        if (!(value instanceof RegExp)) {\n          return {\n            success: false,\n            error: \"Expected RegExp, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"union\",\n    value: function union(schemas) {\n      return MiniZod.createSchema(function (value) {\n        for (var _i2 = 0; _i2 < schemas.length; _i2++) {\n          var s = schemas[_i2];\n          var result = s.validate(value);\n          if (result.success) {\n            return result;\n          }\n        }\n        return {\n          success: false,\n          error: \"Value \".concat(value, \" does not match any schema in union\")\n        };\n      });\n    }\n  }, {\n    key: \"object\",\n    value: function object(shape) {\n      var schema = MiniZod.createSchema(function (value) {\n        if (value == null) {\n          return {\n            success: false,\n            error: \"Expected object, received \".concat(value)\n          };\n        }\n        if (_typeof(value) !== \"object\") {\n          return {\n            success: false,\n            error: \"Expected object, received \".concat(_typeof(value))\n          };\n        }\n        for (var _i4 = 0, _Object$entries2 = Object.entries(shape); _i4 < _Object$entries2.length; _i4++) {\n          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),\n            key = _Object$entries2$_i[0],\n            validator = _Object$entries2$_i[1];\n          var result = validator.validate(value[key]);\n          if (!result.success) {\n            return {\n              success: false,\n              error: \"\".concat(result.error, \" at \").concat(key)\n            };\n          }\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n      schema.strict = function () {\n        return MiniZod.createSchema(function (value) {\n          var baseResult = schema.validate(value);\n          if (!baseResult.success) {\n            return baseResult;\n          }\n          var extraKeys = Object.keys(value).filter(function (key) {\n            return !(key in shape);\n          });\n          if (extraKeys.length > 0) {\n            return {\n              success: false,\n              error: \"Unexpected properties: \".concat(extraKeys.join(\", \"))\n            };\n          }\n          return baseResult;\n        });\n      };\n      return schema;\n    }\n  }, {\n    key: \"record\",\n    value: function record(valueSchema) {\n      return MiniZod.createSchema(function (value) {\n        if (value === null) {\n          return {\n            success: false,\n            error: \"Expected object, received null\"\n          };\n        }\n        if (_typeof(value) !== \"object\") {\n          return {\n            success: false,\n            error: \"Expected object, received \".concat(_typeof(value))\n          };\n        }\n        for (var _i6 = 0, _Object$keys2 = Object.keys(value); _i6 < _Object$keys2.length; _i6++) {\n          var key = _Object$keys2[_i6];\n          if (typeof key !== \"string\") {\n            return {\n              success: false,\n              error: \"Expected string key, received \".concat(_typeof(key), \" at \").concat(key)\n            };\n          }\n          var result = valueSchema.validate(value[key]);\n          if (!result.success) {\n            return {\n              success: false,\n              error: \"\".concat(result.error, \" at key \").concat(key)\n            };\n          }\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }]);\n}();\nmodule.exports = MiniZod;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9taW5pem9kLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5QixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLCtCQUErQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDRCQUE0QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21pbml6b2QuanM/ZDVkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIE1pbmlab2QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNaW5pWm9kKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNaW5pWm9kKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE1pbmlab2QsIG51bGwsIFt7XG4gICAga2V5OiBcImNyZWF0ZVNjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTY2hlbWEodmFsaWRhdGVGbikge1xuICAgICAgdmFyIHNjaGVtYSA9IHtcbiAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlRm4sXG4gICAgICAgIG9wdGlvbmFsOiBmdW5jdGlvbiBvcHRpb25hbCgpIHtcbiAgICAgICAgICByZXR1cm4gTWluaVpvZC5jcmVhdGVTY2hlbWEoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9IDogdmFsaWRhdGVGbih2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG51bGxhYmxlOiBmdW5jdGlvbiBudWxsYWJsZSgpIHtcbiAgICAgICAgICByZXR1cm4gTWluaVpvZC5jcmVhdGVTY2hlbWEoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHtcbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9IDogdmFsaWRhdGVGbih2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyaW5nKCkge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgc3RyaW5nLCByZWNlaXZlZCBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRlKCkge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgZGF0ZSwgcmVjZWl2ZWQgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJvb2xlYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Jvb2xlYW4oKSB7XG4gICAgICByZXR1cm4gTWluaVpvZC5jcmVhdGVTY2hlbWEoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgYm9vbGVhbiwgcmVjZWl2ZWQgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm51bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBudW1iZXIoKSB7XG4gICAgICByZXR1cm4gTWluaVpvZC5jcmVhdGVTY2hlbWEoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJFeHBlY3RlZCBudW1iZXIsIHJlY2VpdmVkIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmdW5jdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWluaVpvZC5jcmVhdGVTY2hlbWEoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIGZ1bmN0aW9uLCByZWNlaXZlZCBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXJyYXkoaXRlbVNjaGVtYSkge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgYXJyYXksIHJlY2VpdmVkIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlbVNjaGVtYS52YWxpZGF0ZSh2YWx1ZVtpXSk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBcIlwiLmNvbmNhdChyZXN1bHQuZXJyb3IsIFwiIGF0IGluZGV4IFwiKS5jb25jYXQoaSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW55KCkge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSZWdleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1JlZ2V4KCkge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJFeHBlY3RlZCBSZWdFeHAsIHJlY2VpdmVkIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmlvbihzY2hlbWFzKSB7XG4gICAgICByZXR1cm4gTWluaVpvZC5jcmVhdGVTY2hlbWEoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHNjaGVtYXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBzID0gc2NoZW1hc1tfaTJdO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBzLnZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IFwiVmFsdWUgXCIuY29uY2F0KHZhbHVlLCBcIiBkb2VzIG5vdCBtYXRjaCBhbnkgc2NoZW1hIGluIHVuaW9uXCIpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9iamVjdChzaGFwZSkge1xuICAgICAgdmFyIHNjaGVtYSA9IE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIG9iamVjdCwgcmVjZWl2ZWQgXCIuY29uY2F0KHZhbHVlKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgb2JqZWN0LCByZWNlaXZlZCBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfT2JqZWN0JGVudHJpZXMyID0gT2JqZWN0LmVudHJpZXMoc2hhcGUpOyBfaTQgPCBfT2JqZWN0JGVudHJpZXMyLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICB2YXIgX09iamVjdCRlbnRyaWVzMiRfaSA9IF9zbGljZWRUb0FycmF5KF9PYmplY3QkZW50cmllczJbX2k0XSwgMiksXG4gICAgICAgICAgICBrZXkgPSBfT2JqZWN0JGVudHJpZXMyJF9pWzBdLFxuICAgICAgICAgICAgdmFsaWRhdG9yID0gX09iamVjdCRlbnRyaWVzMiRfaVsxXTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlW2tleV0pO1xuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogXCJcIi5jb25jYXQocmVzdWx0LmVycm9yLCBcIiBhdCBcIikuY29uY2F0KGtleSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgc2NoZW1hLnN0cmljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBiYXNlUmVzdWx0ID0gc2NoZW1hLnZhbGlkYXRlKHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWJhc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBleHRyYUtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAhKGtleSBpbiBzaGFwZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IFwiVW5leHBlY3RlZCBwcm9wZXJ0aWVzOiBcIi5jb25jYXQoZXh0cmFLZXlzLmpvaW4oXCIsIFwiKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWNvcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkKHZhbHVlU2NoZW1hKSB7XG4gICAgICByZXR1cm4gTWluaVpvZC5jcmVhdGVTY2hlbWEoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIG9iamVjdCwgcmVjZWl2ZWQgbnVsbFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3R5cGVvZih2YWx1ZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJFeHBlY3RlZCBvYmplY3QsIHJlY2VpdmVkIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pNiA9IDAsIF9PYmplY3Qka2V5czIgPSBPYmplY3Qua2V5cyh2YWx1ZSk7IF9pNiA8IF9PYmplY3Qka2V5czIubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBfT2JqZWN0JGtleXMyW19pNl07XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogXCJFeHBlY3RlZCBzdHJpbmcga2V5LCByZWNlaXZlZCBcIi5jb25jYXQoX3R5cGVvZihrZXkpLCBcIiBhdCBcIikuY29uY2F0KGtleSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZVNjaGVtYS52YWxpZGF0ZSh2YWx1ZVtrZXldKTtcbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IFwiXCIuY29uY2F0KHJlc3VsdC5lcnJvciwgXCIgYXQga2V5IFwiKS5jb25jYXQoa2V5KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IE1pbmlab2Q7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/minizod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/module-wrapper.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/module-wrapper.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  XTInternalError = _require.XTInternalError;\nfunction emptyFun() {}\nfunction identity(i) {\n  return i;\n}\nmodule.exports = function (module) {\n  var defaults = {\n    on: emptyFun,\n    set: emptyFun,\n    getFileType: emptyFun,\n    optionsTransformer: identity,\n    preparse: identity,\n    matchers: function matchers() {\n      return [];\n    },\n    parse: emptyFun,\n    getTraits: emptyFun,\n    postparse: identity,\n    errorsTransformer: identity,\n    preResolve: emptyFun,\n    resolve: emptyFun,\n    getRenderedMap: identity,\n    render: emptyFun,\n    nullGetter: emptyFun,\n    postrender: identity\n  };\n  if (Object.keys(defaults).every(function (key) {\n    return !module[key];\n  })) {\n    var err = new XTInternalError(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n    err.properties = {\n      id: \"module_cannot_be_wrapped\",\n      explanation: \"This module cannot be wrapped, because it doesn't define any of the necessary functions\"\n    };\n    throw err;\n  }\n  for (var key in defaults) {\n    module[key] || (module[key] = defaults[key]);\n  }\n  return module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGUtd3JhcHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZS13cmFwcGVyLmpzPzgzNWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgWFRJbnRlcm5hbEVycm9yID0gX3JlcXVpcmUuWFRJbnRlcm5hbEVycm9yO1xuZnVuY3Rpb24gZW1wdHlGdW4oKSB7fVxuZnVuY3Rpb24gaWRlbnRpdHkoaSkge1xuICByZXR1cm4gaTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgb246IGVtcHR5RnVuLFxuICAgIHNldDogZW1wdHlGdW4sXG4gICAgZ2V0RmlsZVR5cGU6IGVtcHR5RnVuLFxuICAgIG9wdGlvbnNUcmFuc2Zvcm1lcjogaWRlbnRpdHksXG4gICAgcHJlcGFyc2U6IGlkZW50aXR5LFxuICAgIG1hdGNoZXJzOiBmdW5jdGlvbiBtYXRjaGVycygpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHBhcnNlOiBlbXB0eUZ1bixcbiAgICBnZXRUcmFpdHM6IGVtcHR5RnVuLFxuICAgIHBvc3RwYXJzZTogaWRlbnRpdHksXG4gICAgZXJyb3JzVHJhbnNmb3JtZXI6IGlkZW50aXR5LFxuICAgIHByZVJlc29sdmU6IGVtcHR5RnVuLFxuICAgIHJlc29sdmU6IGVtcHR5RnVuLFxuICAgIGdldFJlbmRlcmVkTWFwOiBpZGVudGl0eSxcbiAgICByZW5kZXI6IGVtcHR5RnVuLFxuICAgIG51bGxHZXR0ZXI6IGVtcHR5RnVuLFxuICAgIHBvc3RyZW5kZXI6IGlkZW50aXR5XG4gIH07XG4gIGlmIChPYmplY3Qua2V5cyhkZWZhdWx0cykuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhbW9kdWxlW2tleV07XG4gIH0pKSB7XG4gICAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJUaGlzIG1vZHVsZSBjYW5ub3QgYmUgd3JhcHBlZCwgYmVjYXVzZSBpdCBkb2Vzbid0IGRlZmluZSBhbnkgb2YgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbnNcIik7XG4gICAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICBpZDogXCJtb2R1bGVfY2Fubm90X2JlX3dyYXBwZWRcIixcbiAgICAgIGV4cGxhbmF0aW9uOiBcIlRoaXMgbW9kdWxlIGNhbm5vdCBiZSB3cmFwcGVkLCBiZWNhdXNlIGl0IGRvZXNuJ3QgZGVmaW5lIGFueSBvZiB0aGUgbmVjZXNzYXJ5IGZ1bmN0aW9uc1wiXG4gICAgfTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgbW9kdWxlW2tleV0gfHwgKG1vZHVsZVtrZXldID0gZGVmYXVsdHNba2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/common.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/common.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(rsc)/./node_modules/docxtemplater/js/filetypes.js\");\nvar _require2 = __webpack_require__(/*! ../content-types.js */ \"(rsc)/./node_modules/docxtemplater/js/content-types.js\"),\n  settingsContentType = _require2.settingsContentType,\n  coreContentType = _require2.coreContentType,\n  appContentType = _require2.appContentType,\n  customContentType = _require2.customContentType,\n  diagramDataContentType = _require2.diagramDataContentType,\n  diagramDrawingContentType = _require2.diagramDrawingContentType;\nvar commonContentTypes = [settingsContentType, coreContentType, appContentType, customContentType, diagramDataContentType, diagramDrawingContentType];\nvar Common = /*#__PURE__*/function () {\n  function Common() {\n    _classCallCheck(this, Common);\n    this.name = \"Common\";\n  }\n  return _createClass(Common, [{\n    key: \"getFileType\",\n    value: function getFileType(_ref) {\n      var doc = _ref.doc;\n      var invertedContentTypes = doc.invertedContentTypes;\n      if (!invertedContentTypes) {\n        return;\n      }\n      for (var _i2 = 0; _i2 < commonContentTypes.length; _i2++) {\n        var ct = commonContentTypes[_i2];\n        if (invertedContentTypes[ct]) {\n          pushArray(doc.targets, invertedContentTypes[ct]);\n        }\n      }\n      var keys = [\"docx\", \"pptx\", \"xlsx\"];\n      var ftCandidate;\n      for (var _i4 = 0; _i4 < keys.length; _i4++) {\n        var key = keys[_i4];\n        var contentTypes = filetypes[key];\n        for (var _i6 = 0; _i6 < contentTypes.length; _i6++) {\n          var _ct = contentTypes[_i6];\n          if (invertedContentTypes[_ct]) {\n            for (var _i8 = 0, _invertedContentTypes2 = invertedContentTypes[_ct]; _i8 < _invertedContentTypes2.length; _i8++) {\n              var target = _invertedContentTypes2[_i8];\n              if (doc.relsTypes[target] && [\"http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument\", \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\"].indexOf(doc.relsTypes[target]) === -1) {\n                continue;\n              }\n              ftCandidate = key;\n              if (filetypes.main.indexOf(_ct) !== -1 || _ct === filetypes.pptx[0]) {\n                doc.textTarget || (doc.textTarget = target);\n              }\n              if (ftCandidate === \"xlsx\") {\n                continue;\n              }\n              doc.targets.push(target);\n            }\n          }\n        }\n        if (ftCandidate) {\n          continue;\n        }\n      }\n      return ftCandidate;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new Common());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLDJFQUFpQjtBQUN4QztBQUNBLGNBQWMsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQWlCO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBLGtGQUFrRixxQ0FBcUM7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvY29tbW9uLmpzPzQ0N2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheTtcbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIGZpbGV0eXBlcyA9IHJlcXVpcmUoXCIuLi9maWxldHlwZXMuanNcIik7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4uL2NvbnRlbnQtdHlwZXMuanNcIiksXG4gIHNldHRpbmdzQ29udGVudFR5cGUgPSBfcmVxdWlyZTIuc2V0dGluZ3NDb250ZW50VHlwZSxcbiAgY29yZUNvbnRlbnRUeXBlID0gX3JlcXVpcmUyLmNvcmVDb250ZW50VHlwZSxcbiAgYXBwQ29udGVudFR5cGUgPSBfcmVxdWlyZTIuYXBwQ29udGVudFR5cGUsXG4gIGN1c3RvbUNvbnRlbnRUeXBlID0gX3JlcXVpcmUyLmN1c3RvbUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRGF0YUNvbnRlbnRUeXBlID0gX3JlcXVpcmUyLmRpYWdyYW1EYXRhQ29udGVudFR5cGUsXG4gIGRpYWdyYW1EcmF3aW5nQ29udGVudFR5cGUgPSBfcmVxdWlyZTIuZGlhZ3JhbURyYXdpbmdDb250ZW50VHlwZTtcbnZhciBjb21tb25Db250ZW50VHlwZXMgPSBbc2V0dGluZ3NDb250ZW50VHlwZSwgY29yZUNvbnRlbnRUeXBlLCBhcHBDb250ZW50VHlwZSwgY3VzdG9tQ29udGVudFR5cGUsIGRpYWdyYW1EYXRhQ29udGVudFR5cGUsIGRpYWdyYW1EcmF3aW5nQ29udGVudFR5cGVdO1xudmFyIENvbW1vbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbW1vbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tbW9uKTtcbiAgICB0aGlzLm5hbWUgPSBcIkNvbW1vblwiO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ29tbW9uLCBbe1xuICAgIGtleTogXCJnZXRGaWxlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxlVHlwZShfcmVmKSB7XG4gICAgICB2YXIgZG9jID0gX3JlZi5kb2M7XG4gICAgICB2YXIgaW52ZXJ0ZWRDb250ZW50VHlwZXMgPSBkb2MuaW52ZXJ0ZWRDb250ZW50VHlwZXM7XG4gICAgICBpZiAoIWludmVydGVkQ29udGVudFR5cGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNvbW1vbkNvbnRlbnRUeXBlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBjdCA9IGNvbW1vbkNvbnRlbnRUeXBlc1tfaTJdO1xuICAgICAgICBpZiAoaW52ZXJ0ZWRDb250ZW50VHlwZXNbY3RdKSB7XG4gICAgICAgICAgcHVzaEFycmF5KGRvYy50YXJnZXRzLCBpbnZlcnRlZENvbnRlbnRUeXBlc1tjdF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIga2V5cyA9IFtcImRvY3hcIiwgXCJwcHR4XCIsIFwieGxzeFwiXTtcbiAgICAgIHZhciBmdENhbmRpZGF0ZTtcbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGtleXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tfaTRdO1xuICAgICAgICB2YXIgY29udGVudFR5cGVzID0gZmlsZXR5cGVzW2tleV07XG4gICAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNvbnRlbnRUeXBlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgICAgdmFyIF9jdCA9IGNvbnRlbnRUeXBlc1tfaTZdO1xuICAgICAgICAgIGlmIChpbnZlcnRlZENvbnRlbnRUeXBlc1tfY3RdKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBfaW52ZXJ0ZWRDb250ZW50VHlwZXMyID0gaW52ZXJ0ZWRDb250ZW50VHlwZXNbX2N0XTsgX2k4IDwgX2ludmVydGVkQ29udGVudFR5cGVzMi5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfaW52ZXJ0ZWRDb250ZW50VHlwZXMyW19pOF07XG4gICAgICAgICAgICAgIGlmIChkb2MucmVsc1R5cGVzW3RhcmdldF0gJiYgW1wiaHR0cDovL3B1cmwub2NsYy5vcmcvb294bWwvb2ZmaWNlRG9jdW1lbnQvcmVsYXRpb25zaGlwcy9vZmZpY2VEb2N1bWVudFwiLCBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvb2ZmaWNlRG9jdW1lbnRcIl0uaW5kZXhPZihkb2MucmVsc1R5cGVzW3RhcmdldF0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ0Q2FuZGlkYXRlID0ga2V5O1xuICAgICAgICAgICAgICBpZiAoZmlsZXR5cGVzLm1haW4uaW5kZXhPZihfY3QpICE9PSAtMSB8fCBfY3QgPT09IGZpbGV0eXBlcy5wcHR4WzBdKSB7XG4gICAgICAgICAgICAgICAgZG9jLnRleHRUYXJnZXQgfHwgKGRvYy50ZXh0VGFyZ2V0ID0gdGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZnRDYW5kaWRhdGUgPT09IFwieGxzeFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG9jLnRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnRDYW5kaWRhdGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ0Q2FuZGlkYXRlO1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBDb21tb24oKSk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js":
/*!********************************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/expand-pair-trait.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _readOnlyError(r) { throw new TypeError('\"' + r + '\" is read-only'); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar traitName = \"expandPair\";\nvar mergeSort = __webpack_require__(/*! ../merge-sort.js */ \"(rsc)/./node_modules/docxtemplater/js/merge-sort.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  getLeft = _require.getLeft,\n  getRight = _require.getRight,\n  pushArray = _require.pushArray;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require2 = __webpack_require__(/*! ../traits.js */ \"(rsc)/./node_modules/docxtemplater/js/traits.js\"),\n  getExpandToDefault = _require2.getExpandToDefault;\nvar _require3 = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  getUnmatchedLoopException = _require3.getUnmatchedLoopException,\n  getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag,\n  getUnbalancedLoopException = _require3.getUnbalancedLoopException;\nfunction getOpenCountChange(part) {\n  switch (part.location) {\n    case \"start\":\n      return 1;\n    case \"end\":\n      return -1;\n  }\n}\nfunction match(start, end) {\n  return start != null && end != null && (start.part.location === \"start\" && end.part.location === \"end\" && start.part.value === end.part.value || end.part.value === \"\");\n}\nfunction transformer(traits) {\n  var i = 0;\n  var errors = [];\n  while (i < traits.length) {\n    var part = traits[i].part;\n    if (part.location === \"end\") {\n      if (i === 0) {\n        traits.splice(0, 1);\n        errors.push(getUnmatchedLoopException(part));\n        return {\n          traits: traits,\n          errors: errors\n        };\n      }\n      var endIndex = i;\n      var startIndex = i - 1;\n      var offseter = 1;\n      if (match(traits[startIndex], traits[endIndex])) {\n        traits.splice(endIndex, 1);\n        traits.splice(startIndex, 1);\n        return {\n          errors: errors,\n          traits: traits\n        };\n      }\n      while (offseter < 50) {\n        var startCandidate = traits[startIndex - offseter];\n        var endCandidate = traits[endIndex + offseter];\n        if (match(startCandidate, traits[endIndex])) {\n          traits.splice(endIndex, 1);\n          traits.splice(startIndex - offseter, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        if (match(traits[startIndex], endCandidate)) {\n          traits.splice(endIndex + offseter, 1);\n          traits.splice(startIndex, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        offseter++;\n      }\n      errors.push(getClosingTagNotMatchOpeningTag({\n        tags: [traits[startIndex].part, traits[endIndex].part]\n      }));\n      traits.splice(endIndex, 1);\n      traits.splice(startIndex, 1);\n      return {\n        traits: traits,\n        errors: errors\n      };\n    }\n    i++;\n  }\n  for (var _i2 = 0; _i2 < traits.length; _i2++) {\n    var _part = traits[_i2].part;\n    errors.push(getUnmatchedLoopException(_part));\n  }\n  return {\n    traits: [],\n    errors: errors\n  };\n}\nfunction getPairs(traits) {\n  var levelTraits = {};\n  var errors = [];\n  var pairs = [];\n  var transformedTraits = [];\n  pushArray(transformedTraits, traits);\n  while (transformedTraits.length > 0) {\n    var result = transformer(transformedTraits);\n    pushArray(errors, result.errors);\n    transformedTraits = result.traits;\n  }\n\n  // Stryker disable all : because this check makes the function return quicker\n  if (errors.length > 0) {\n    return {\n      pairs: pairs,\n      errors: errors\n    };\n  }\n  // Stryker restore all\n  var countOpen = 0;\n  for (var _i4 = 0; _i4 < traits.length; _i4++) {\n    var currentTrait = traits[_i4];\n    var part = currentTrait.part;\n    var change = getOpenCountChange(part);\n    countOpen += change;\n    if (change === 1) {\n      levelTraits[countOpen] = currentTrait;\n    } else {\n      var startTrait = levelTraits[countOpen + 1];\n      if (countOpen === 0) {\n        pairs.push([startTrait, currentTrait]);\n      }\n    }\n    countOpen = countOpen >= 0 ? countOpen : 0;\n  }\n  return {\n    pairs: pairs,\n    errors: errors\n  };\n}\nvar ExpandPairTrait = /*#__PURE__*/function () {\n  function ExpandPairTrait() {\n    _classCallCheck(this, ExpandPairTrait);\n    this.name = \"ExpandPairTrait\";\n  }\n  return _createClass(ExpandPairTrait, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      if (docxtemplater.options.paragraphLoop) {\n        pushArray(docxtemplater.fileTypeConfig.expandTags, docxtemplater.fileTypeConfig.onParagraphLoop);\n      }\n      this.expandTags = docxtemplater.fileTypeConfig.expandTags;\n      return options;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, options) {\n      var _this = this;\n      var getTraits = options.getTraits,\n        postparse = options.postparse,\n        fileType = options.fileType;\n      var traits = getTraits(traitName, postparsed, options);\n      traits = traits.map(function (trait) {\n        return trait || [];\n      });\n      traits = mergeSort(traits);\n      var _getPairs = getPairs(traits),\n        pairs = _getPairs.pairs,\n        errors = _getPairs.errors;\n      var lastRight = 0;\n      var lastPair = null;\n      var expandedPairs = pairs.map(function (pair) {\n        var expandTo = pair[0].part.expandTo;\n        if (expandTo === \"auto\" && fileType !== \"text\") {\n          var result = getExpandToDefault(postparsed, pair, _this.expandTags);\n          if (result.error) {\n            errors.push(result.error);\n          }\n          expandTo = result.value;\n        }\n        if (!expandTo || fileType === \"text\") {\n          var _left = pair[0].offset;\n          var _right = pair[1].offset;\n          if (_left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n            errors.push(getUnbalancedLoopException(pair, lastPair));\n          }\n          lastPair = pair;\n          lastRight = _right;\n          return [_left, _right];\n        }\n        var left, right;\n        try {\n          left = getLeft(postparsed, expandTo, pair[0].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        try {\n          right = getRight(postparsed, expandTo, pair[1].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        if (left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n          errors.push(getUnbalancedLoopException(pair, lastPair));\n        }\n        lastRight = right;\n        lastPair = pair;\n        return [left, right];\n      });\n\n      // Stryker disable all : because this check makes the function return quicker\n      if (errors.length > 0) {\n        return {\n          postparsed: postparsed,\n          errors: errors\n        };\n      }\n      // Stryker restore all\n      var currentPairIndex = 0;\n      var innerParts;\n      var newParsed = postparsed.reduce(function (newParsed, part, i) {\n        var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i && i <= expandedPairs[currentPairIndex][1];\n        var pair = pairs[currentPairIndex];\n        var expandedPair = expandedPairs[currentPairIndex];\n        if (!inPair) {\n          newParsed.push(part);\n          return newParsed;\n        }\n        // We're inside the pair\n        if (expandedPair[0] === i) {\n          // Start pair\n          innerParts = [];\n        }\n        if (pair[0].offset !== i && pair[1].offset !== i) {\n          // Exclude inner pair indexes\n          innerParts.push(part);\n        }\n        if (expandedPair[1] === i) {\n          // End pair\n          var basePart = postparsed[pair[0].offset];\n          basePart.subparsed = postparse(innerParts, {\n            basePart: basePart\n          });\n          basePart.endLindex = pair[1].part.lIndex;\n          delete basePart.location;\n          delete basePart.expandTo;\n          newParsed.push(basePart);\n          currentPairIndex++;\n          var _expandedPair = expandedPairs[currentPairIndex];\n          while (_expandedPair && _expandedPair[0] < i) {\n            /*\n             * If we have :\n             * expandedPairs =[[5,72],[51,67],[90,106]]\n             * Then after treating [5,72], we need to treat [90,106]\n             * Fixed since v3.58.4\n             */\n            currentPairIndex++;\n            _expandedPair = expandedPairs[currentPairIndex];\n          }\n        }\n        return newParsed;\n      }, []);\n      return {\n        postparsed: newParsed,\n        errors: errors\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new ExpandPairTrait());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2V4cGFuZC1wYWlyLXRyYWl0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLDJFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMscUZBQXNCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLHFFQUFjO0FBQ3RDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMscUVBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9leHBhbmQtcGFpci10cmFpdC5qcz8zZDUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfcmVhZE9ubHlFcnJvcihyKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiJyArIHIgKyAnXCIgaXMgcmVhZC1vbmx5Jyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB0cmFpdE5hbWUgPSBcImV4cGFuZFBhaXJcIjtcbnZhciBtZXJnZVNvcnQgPSByZXF1aXJlKFwiLi4vbWVyZ2Utc29ydC5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGdldExlZnQgPSBfcmVxdWlyZS5nZXRMZWZ0LFxuICBnZXRSaWdodCA9IF9yZXF1aXJlLmdldFJpZ2h0LFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vdHJhaXRzLmpzXCIpLFxuICBnZXRFeHBhbmRUb0RlZmF1bHQgPSBfcmVxdWlyZTIuZ2V0RXhwYW5kVG9EZWZhdWx0O1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIiksXG4gIGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24gPSBfcmVxdWlyZTMuZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbixcbiAgZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyA9IF9yZXF1aXJlMy5nZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnLFxuICBnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbiA9IF9yZXF1aXJlMy5nZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGdldE9wZW5Db3VudENoYW5nZShwYXJ0KSB7XG4gIHN3aXRjaCAocGFydC5sb2NhdGlvbikge1xuICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBcImVuZFwiOlxuICAgICAgcmV0dXJuIC0xO1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaChzdGFydCwgZW5kKSB7XG4gIHJldHVybiBzdGFydCAhPSBudWxsICYmIGVuZCAhPSBudWxsICYmIChzdGFydC5wYXJ0LmxvY2F0aW9uID09PSBcInN0YXJ0XCIgJiYgZW5kLnBhcnQubG9jYXRpb24gPT09IFwiZW5kXCIgJiYgc3RhcnQucGFydC52YWx1ZSA9PT0gZW5kLnBhcnQudmFsdWUgfHwgZW5kLnBhcnQudmFsdWUgPT09IFwiXCIpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtZXIodHJhaXRzKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB3aGlsZSAoaSA8IHRyYWl0cy5sZW5ndGgpIHtcbiAgICB2YXIgcGFydCA9IHRyYWl0c1tpXS5wYXJ0O1xuICAgIGlmIChwYXJ0LmxvY2F0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICB0cmFpdHMuc3BsaWNlKDAsIDEpO1xuICAgICAgICBlcnJvcnMucHVzaChnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uKHBhcnQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFpdHM6IHRyYWl0cyxcbiAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGVuZEluZGV4ID0gaTtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gaSAtIDE7XG4gICAgICB2YXIgb2Zmc2V0ZXIgPSAxO1xuICAgICAgaWYgKG1hdGNoKHRyYWl0c1tzdGFydEluZGV4XSwgdHJhaXRzW2VuZEluZGV4XSkpIHtcbiAgICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCwgMSk7XG4gICAgICAgIHRyYWl0cy5zcGxpY2Uoc3RhcnRJbmRleCwgMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgdHJhaXRzOiB0cmFpdHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvZmZzZXRlciA8IDUwKSB7XG4gICAgICAgIHZhciBzdGFydENhbmRpZGF0ZSA9IHRyYWl0c1tzdGFydEluZGV4IC0gb2Zmc2V0ZXJdO1xuICAgICAgICB2YXIgZW5kQ2FuZGlkYXRlID0gdHJhaXRzW2VuZEluZGV4ICsgb2Zmc2V0ZXJdO1xuICAgICAgICBpZiAobWF0Y2goc3RhcnRDYW5kaWRhdGUsIHRyYWl0c1tlbmRJbmRleF0pKSB7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCwgMSk7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShzdGFydEluZGV4IC0gb2Zmc2V0ZXIsIDEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgIHRyYWl0czogdHJhaXRzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2godHJhaXRzW3N0YXJ0SW5kZXhdLCBlbmRDYW5kaWRhdGUpKSB7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCArIG9mZnNldGVyLCAxKTtcbiAgICAgICAgICB0cmFpdHMuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgIHRyYWl0czogdHJhaXRzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXRlcisrO1xuICAgICAgfVxuICAgICAgZXJyb3JzLnB1c2goZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyh7XG4gICAgICAgIHRhZ3M6IFt0cmFpdHNbc3RhcnRJbmRleF0ucGFydCwgdHJhaXRzW2VuZEluZGV4XS5wYXJ0XVxuICAgICAgfSkpO1xuICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCwgMSk7XG4gICAgICB0cmFpdHMuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhaXRzOiB0cmFpdHMsXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdHJhaXRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX3BhcnQgPSB0cmFpdHNbX2kyXS5wYXJ0O1xuICAgIGVycm9ycy5wdXNoKGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24oX3BhcnQpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRyYWl0czogW10sXG4gICAgZXJyb3JzOiBlcnJvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhaXJzKHRyYWl0cykge1xuICB2YXIgbGV2ZWxUcmFpdHMgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgdmFyIHRyYW5zZm9ybWVkVHJhaXRzID0gW107XG4gIHB1c2hBcnJheSh0cmFuc2Zvcm1lZFRyYWl0cywgdHJhaXRzKTtcbiAgd2hpbGUgKHRyYW5zZm9ybWVkVHJhaXRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtZXIodHJhbnNmb3JtZWRUcmFpdHMpO1xuICAgIHB1c2hBcnJheShlcnJvcnMsIHJlc3VsdC5lcnJvcnMpO1xuICAgIHRyYW5zZm9ybWVkVHJhaXRzID0gcmVzdWx0LnRyYWl0cztcbiAgfVxuXG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgY2hlY2sgbWFrZXMgdGhlIGZ1bmN0aW9uIHJldHVybiBxdWlja2VyXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYWlyczogcGFpcnMsXG4gICAgICBlcnJvcnM6IGVycm9yc1xuICAgIH07XG4gIH1cbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICB2YXIgY291bnRPcGVuID0gMDtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdHJhaXRzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgY3VycmVudFRyYWl0ID0gdHJhaXRzW19pNF07XG4gICAgdmFyIHBhcnQgPSBjdXJyZW50VHJhaXQucGFydDtcbiAgICB2YXIgY2hhbmdlID0gZ2V0T3BlbkNvdW50Q2hhbmdlKHBhcnQpO1xuICAgIGNvdW50T3BlbiArPSBjaGFuZ2U7XG4gICAgaWYgKGNoYW5nZSA9PT0gMSkge1xuICAgICAgbGV2ZWxUcmFpdHNbY291bnRPcGVuXSA9IGN1cnJlbnRUcmFpdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0VHJhaXQgPSBsZXZlbFRyYWl0c1tjb3VudE9wZW4gKyAxXTtcbiAgICAgIGlmIChjb3VudE9wZW4gPT09IDApIHtcbiAgICAgICAgcGFpcnMucHVzaChbc3RhcnRUcmFpdCwgY3VycmVudFRyYWl0XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvdW50T3BlbiA9IGNvdW50T3BlbiA+PSAwID8gY291bnRPcGVuIDogMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhaXJzOiBwYWlycyxcbiAgICBlcnJvcnM6IGVycm9yc1xuICB9O1xufVxudmFyIEV4cGFuZFBhaXJUcmFpdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cGFuZFBhaXJUcmFpdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwYW5kUGFpclRyYWl0KTtcbiAgICB0aGlzLm5hbWUgPSBcIkV4cGFuZFBhaXJUcmFpdFwiO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXhwYW5kUGFpclRyYWl0LCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIGlmIChkb2N4dGVtcGxhdGVyLm9wdGlvbnMucGFyYWdyYXBoTG9vcCkge1xuICAgICAgICBwdXNoQXJyYXkoZG9jeHRlbXBsYXRlci5maWxlVHlwZUNvbmZpZy5leHBhbmRUYWdzLCBkb2N4dGVtcGxhdGVyLmZpbGVUeXBlQ29uZmlnLm9uUGFyYWdyYXBoTG9vcCk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGFuZFRhZ3MgPSBkb2N4dGVtcGxhdGVyLmZpbGVUeXBlQ29uZmlnLmV4cGFuZFRhZ3M7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdHBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGdldFRyYWl0cyA9IG9wdGlvbnMuZ2V0VHJhaXRzLFxuICAgICAgICBwb3N0cGFyc2UgPSBvcHRpb25zLnBvc3RwYXJzZSxcbiAgICAgICAgZmlsZVR5cGUgPSBvcHRpb25zLmZpbGVUeXBlO1xuICAgICAgdmFyIHRyYWl0cyA9IGdldFRyYWl0cyh0cmFpdE5hbWUsIHBvc3RwYXJzZWQsIG9wdGlvbnMpO1xuICAgICAgdHJhaXRzID0gdHJhaXRzLm1hcChmdW5jdGlvbiAodHJhaXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYWl0IHx8IFtdO1xuICAgICAgfSk7XG4gICAgICB0cmFpdHMgPSBtZXJnZVNvcnQodHJhaXRzKTtcbiAgICAgIHZhciBfZ2V0UGFpcnMgPSBnZXRQYWlycyh0cmFpdHMpLFxuICAgICAgICBwYWlycyA9IF9nZXRQYWlycy5wYWlycyxcbiAgICAgICAgZXJyb3JzID0gX2dldFBhaXJzLmVycm9ycztcbiAgICAgIHZhciBsYXN0UmlnaHQgPSAwO1xuICAgICAgdmFyIGxhc3RQYWlyID0gbnVsbDtcbiAgICAgIHZhciBleHBhbmRlZFBhaXJzID0gcGFpcnMubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBleHBhbmRUbyA9IHBhaXJbMF0ucGFydC5leHBhbmRUbztcbiAgICAgICAgaWYgKGV4cGFuZFRvID09PSBcImF1dG9cIiAmJiBmaWxlVHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0RXhwYW5kVG9EZWZhdWx0KHBvc3RwYXJzZWQsIHBhaXIsIF90aGlzLmV4cGFuZFRhZ3MpO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cGFuZFRvID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhwYW5kVG8gfHwgZmlsZVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdmFyIF9sZWZ0ID0gcGFpclswXS5vZmZzZXQ7XG4gICAgICAgICAgdmFyIF9yaWdodCA9IHBhaXJbMV0ub2Zmc2V0O1xuICAgICAgICAgIGlmIChfbGVmdCA8IGxhc3RSaWdodCAmJiAhX3RoaXMuZG9jeHRlbXBsYXRlci5vcHRpb25zLnN5bnRheC5hbGxvd1VuYmFsYW5jZWRMb29wcykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24ocGFpciwgbGFzdFBhaXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdFBhaXIgPSBwYWlyO1xuICAgICAgICAgIGxhc3RSaWdodCA9IF9yaWdodDtcbiAgICAgICAgICByZXR1cm4gW19sZWZ0LCBfcmlnaHRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0LCByaWdodDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZWZ0ID0gZ2V0TGVmdChwb3N0cGFyc2VkLCBleHBhbmRUbywgcGFpclswXS5vZmZzZXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByaWdodCA9IGdldFJpZ2h0KHBvc3RwYXJzZWQsIGV4cGFuZFRvLCBwYWlyWzFdLm9mZnNldCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCA8IGxhc3RSaWdodCAmJiAhX3RoaXMuZG9jeHRlbXBsYXRlci5vcHRpb25zLnN5bnRheC5hbGxvd1VuYmFsYW5jZWRMb29wcykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uKHBhaXIsIGxhc3RQYWlyKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIGxhc3RQYWlyID0gcGFpcjtcbiAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBjaGVjayBtYWtlcyB0aGUgZnVuY3Rpb24gcmV0dXJuIHF1aWNrZXJcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWQsXG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcbiAgICAgIHZhciBjdXJyZW50UGFpckluZGV4ID0gMDtcbiAgICAgIHZhciBpbm5lclBhcnRzO1xuICAgICAgdmFyIG5ld1BhcnNlZCA9IHBvc3RwYXJzZWQucmVkdWNlKGZ1bmN0aW9uIChuZXdQYXJzZWQsIHBhcnQsIGkpIHtcbiAgICAgICAgdmFyIGluUGFpciA9IGN1cnJlbnRQYWlySW5kZXggPCBwYWlycy5sZW5ndGggJiYgZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XVswXSA8PSBpICYmIGkgPD0gZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XVsxXTtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tjdXJyZW50UGFpckluZGV4XTtcbiAgICAgICAgdmFyIGV4cGFuZGVkUGFpciA9IGV4cGFuZGVkUGFpcnNbY3VycmVudFBhaXJJbmRleF07XG4gICAgICAgIGlmICghaW5QYWlyKSB7XG4gICAgICAgICAgbmV3UGFyc2VkLnB1c2gocGFydCk7XG4gICAgICAgICAgcmV0dXJuIG5ld1BhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdyZSBpbnNpZGUgdGhlIHBhaXJcbiAgICAgICAgaWYgKGV4cGFuZGVkUGFpclswXSA9PT0gaSkge1xuICAgICAgICAgIC8vIFN0YXJ0IHBhaXJcbiAgICAgICAgICBpbm5lclBhcnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhaXJbMF0ub2Zmc2V0ICE9PSBpICYmIHBhaXJbMV0ub2Zmc2V0ICE9PSBpKSB7XG4gICAgICAgICAgLy8gRXhjbHVkZSBpbm5lciBwYWlyIGluZGV4ZXNcbiAgICAgICAgICBpbm5lclBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGFuZGVkUGFpclsxXSA9PT0gaSkge1xuICAgICAgICAgIC8vIEVuZCBwYWlyXG4gICAgICAgICAgdmFyIGJhc2VQYXJ0ID0gcG9zdHBhcnNlZFtwYWlyWzBdLm9mZnNldF07XG4gICAgICAgICAgYmFzZVBhcnQuc3VicGFyc2VkID0gcG9zdHBhcnNlKGlubmVyUGFydHMsIHtcbiAgICAgICAgICAgIGJhc2VQYXJ0OiBiYXNlUGFydFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJhc2VQYXJ0LmVuZExpbmRleCA9IHBhaXJbMV0ucGFydC5sSW5kZXg7XG4gICAgICAgICAgZGVsZXRlIGJhc2VQYXJ0LmxvY2F0aW9uO1xuICAgICAgICAgIGRlbGV0ZSBiYXNlUGFydC5leHBhbmRUbztcbiAgICAgICAgICBuZXdQYXJzZWQucHVzaChiYXNlUGFydCk7XG4gICAgICAgICAgY3VycmVudFBhaXJJbmRleCsrO1xuICAgICAgICAgIHZhciBfZXhwYW5kZWRQYWlyID0gZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XTtcbiAgICAgICAgICB3aGlsZSAoX2V4cGFuZGVkUGFpciAmJiBfZXhwYW5kZWRQYWlyWzBdIDwgaSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgOlxuICAgICAgICAgICAgICogZXhwYW5kZWRQYWlycyA9W1s1LDcyXSxbNTEsNjddLFs5MCwxMDZdXVxuICAgICAgICAgICAgICogVGhlbiBhZnRlciB0cmVhdGluZyBbNSw3Ml0sIHdlIG5lZWQgdG8gdHJlYXQgWzkwLDEwNl1cbiAgICAgICAgICAgICAqIEZpeGVkIHNpbmNlIHYzLjU4LjRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY3VycmVudFBhaXJJbmRleCsrO1xuICAgICAgICAgICAgX2V4cGFuZGVkUGFpciA9IGV4cGFuZGVkUGFpcnNbY3VycmVudFBhaXJJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQYXJzZWQ7XG4gICAgICB9LCBbXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3N0cGFyc2VkOiBuZXdQYXJzZWQsXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBFeHBhbmRQYWlyVHJhaXQoKSk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/loop.js":
/*!*******************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/loop.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  chunkBy = _require.chunkBy,\n  last = _require.last,\n  isParagraphStart = _require.isParagraphStart,\n  isModule = _require.isModule,\n  pushArray = _require.pushArray,\n  isParagraphEnd = _require.isParagraphEnd,\n  isContent = _require.isContent,\n  startsWith = _require.startsWith,\n  isTagEnd = _require.isTagEnd,\n  isTagStart = _require.isTagStart,\n  getSingleAttribute = _require.getSingleAttribute,\n  setSingleAttribute = _require.setSingleAttribute;\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(rsc)/./node_modules/docxtemplater/js/filetypes.js\");\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"loop\";\nfunction hasContent(parts) {\n  for (var _i2 = 0; _i2 < parts.length; _i2++) {\n    var part = parts[_i2];\n    if (isContent(part)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getFirstMeaningFulPart(parsed) {\n  for (var _i4 = 0; _i4 < parsed.length; _i4++) {\n    var part = parsed[_i4];\n    if (part.type !== \"content\") {\n      return part;\n    }\n  }\n  return null;\n}\nfunction isInsideParagraphLoop(part) {\n  var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);\n  return firstMeaningfulPart != null && firstMeaningfulPart.tag !== \"w:t\";\n}\nfunction getPageBreakIfApplies(part) {\n  return part.hasPageBreak && isInsideParagraphLoop(part) ? '<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>' : \"\";\n}\nfunction isEnclosedByParagraphs(parsed) {\n  return parsed.length && isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\n}\nfunction getOffset(chunk) {\n  return hasContent(chunk) ? 0 : chunk.length;\n}\nfunction addPageBreakAtEnd(subRendered) {\n  var j = subRendered.parts.length - 1;\n  if (subRendered.parts[j] === \"</w:p>\") {\n    subRendered.parts.splice(j, 0, '<w:r><w:br w:type=\"page\"/></w:r>');\n  } else {\n    subRendered.parts.push('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n  }\n}\nfunction addPageBreakAtBeginning(subRendered) {\n  subRendered.parts.unshift('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n}\nfunction isContinuous(parts) {\n  for (var _i6 = 0; _i6 < parts.length; _i6++) {\n    var part = parts[_i6];\n    if (isTagStart(\"w:type\", part) && part.value.indexOf(\"continuous\") !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isNextPage(parts) {\n  for (var _i8 = 0; _i8 < parts.length; _i8++) {\n    var part = parts[_i8];\n    if (isTagStart(\"w:type\", part) && part.value.indexOf('w:val=\"nextPage\"') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction addSectionBefore(parts, sect) {\n  parts.unshift(\"<w:p><w:pPr>\".concat(sect.map(function (_ref) {\n    var value = _ref.value;\n    return value;\n  }).join(\"\"), \"</w:pPr></w:p>\"));\n}\nfunction addContinuousType(parts) {\n  var stop = false;\n  var inSectPr = false;\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i];\n    if (!stop && startsWith(part, \"<w:sectPr\")) {\n      inSectPr = true;\n    }\n    if (inSectPr) {\n      if (startsWith(part, \"<w:type\")) {\n        stop = true;\n      }\n      if (!stop && startsWith(part, \"</w:sectPr\")) {\n        parts.splice(i, 0, '<w:type w:val=\"continuous\"/>');\n        i++; // Skip re-processing the now-shifted closing tag to avoid infinite insertion\n      }\n    }\n  }\n  return parts;\n}\nfunction dropHeaderFooterRefs(parts) {\n  var writeIndex = 0;\n  for (var readIndex = 0; readIndex < parts.length; readIndex++) {\n    if (!startsWith(parts[readIndex], \"<w:headerReference\") && !startsWith(parts[readIndex], \"<w:footerReference\")) {\n      parts[writeIndex] = parts[readIndex];\n      writeIndex++;\n    }\n  }\n  parts.length = writeIndex;\n  return parts;\n}\nfunction hasPageBreak(chunk) {\n  for (var _i0 = 0; _i0 < chunk.length; _i0++) {\n    var part = chunk[_i0];\n    if (part.tag === \"w:br\" && part.value.indexOf('w:type=\"page\"') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction hasImage(chunk) {\n  for (var _i10 = 0; _i10 < chunk.length; _i10++) {\n    var el = chunk[_i10];\n    if (el.tag === \"w:drawing\") {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getSectPr(chunks) {\n  var sectPrs = [];\n  var currentSectPr = null;\n  for (var _i12 = 0; _i12 < chunks.length; _i12++) {\n    var part = chunks[_i12];\n    if (isTagStart(\"w:sectPr\", part)) {\n      currentSectPr = [];\n      sectPrs.push(currentSectPr);\n    }\n    if (currentSectPr !== null) {\n      currentSectPr.push(part);\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      currentSectPr = null;\n    }\n  }\n  return sectPrs;\n}\nfunction getSectPrHeaderFooterChangeCount(chunks) {\n  var collectSectPr = false;\n  var sectPrCount = 0;\n  for (var _i14 = 0; _i14 < chunks.length; _i14++) {\n    var part = chunks[_i14];\n    if (isTagStart(\"w:sectPr\", part)) {\n      collectSectPr = true;\n    }\n    if (collectSectPr) {\n      if (part.tag === \"w:headerReference\" || part.tag === \"w:footerReference\") {\n        sectPrCount++;\n        collectSectPr = false;\n      }\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      collectSectPr = false;\n    }\n  }\n  return sectPrCount;\n}\nfunction getLastSectPr(parsed) {\n  var sectPr = [];\n  var inSectPr = false;\n  for (var i = parsed.length - 1; i >= 0; i--) {\n    var part = parsed[i];\n\n    /*\n     * Since we try to get the last sectPr, we traverse the parsed array\n     * from the end to beginning, this is why inSectPr becomes true when we\n     * we see a </w:sectPr> closing tag\n     */\n    if (isTagEnd(\"w:sectPr\", part)) {\n      inSectPr = true;\n    }\n    if (isTagStart(\"w:sectPr\", part)) {\n      sectPr.unshift(part.value);\n      inSectPr = false;\n    }\n    if (inSectPr) {\n      sectPr.unshift(part.value);\n    }\n    if (isParagraphStart(part)) {\n      if (sectPr.length > 0) {\n        return sectPr.join(\"\");\n      }\n      break;\n    }\n  }\n  return \"\";\n}\nvar LoopModule = /*#__PURE__*/function () {\n  function LoopModule() {\n    _classCallCheck(this, LoopModule);\n    this.name = \"LoopModule\";\n    this.inXfrm = false;\n    this.totalSectPr = 0;\n    this.prefix = {\n      start: \"#\",\n      end: \"/\",\n      dash: /^-([^\\s]+)\\s(.+)/,\n      inverted: \"^\"\n    };\n  }\n  return _createClass(LoopModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(opts, docxtemplater) {\n      this.docxtemplater = docxtemplater;\n      return opts;\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse(parsed, _ref2) {\n      var contentType = _ref2.contentType;\n      if (filetypes.main.indexOf(contentType) !== -1) {\n        this.sects = getSectPr(parsed);\n      }\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      var module = moduleName;\n      return [[this.prefix.start, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: false\n      }], [this.prefix.inverted, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: true\n      }], [this.prefix.end, module, {\n        location: \"end\"\n      }], [this.prefix.dash, module, function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 3),\n          expandTo = _ref4[1],\n          value = _ref4[2];\n        return {\n          location: \"start\",\n          inverted: false,\n          expandTo: expandTo,\n          value: value\n        };\n      }]];\n    }\n  }, {\n    key: \"getTraits\",\n    value: function getTraits(traitName, parsed) {\n      // Stryker disable all : because getTraits should disappear in v4\n      if (traitName !== \"expandPair\") {\n        return;\n      }\n      // Stryker restore all\n\n      var tags = [];\n      for (var offset = 0, len = parsed.length; offset < len; offset++) {\n        var part = parsed[offset];\n        if (isModule(part, moduleName) && part.subparsed == null) {\n          tags.push({\n            part: part,\n            offset: offset\n          });\n        }\n      }\n      return tags;\n    }\n\n    /* eslint-disable-next-line complexity */\n  }, {\n    key: \"postparse\",\n    value: function postparse(parsed, _ref5) {\n      var basePart = _ref5.basePart;\n      if (basePart && this.docxtemplater.fileType === \"docx\" && parsed.length > 0) {\n        basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);\n        this.totalSectPr += basePart.sectPrCount;\n        var sects = this.sects;\n        for (var index = 0, len = sects.length; index < len; index++) {\n          var sect = sects[index];\n          if (basePart.lIndex < sect[0].lIndex) {\n            if (index + 1 < sects.length && isContinuous(sects[index + 1])) {\n              basePart.addContinuousType = true;\n            }\n            break;\n          }\n          if (parsed[0].lIndex < sect[0].lIndex && sect[0].lIndex < basePart.lIndex) {\n            if (isNextPage(sects[index])) {\n              basePart.addNextPage = {\n                index: index\n              };\n            }\n            break;\n          }\n        }\n        basePart.lastParagrapSectPr = getLastSectPr(parsed);\n      }\n      if (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {\n        return parsed;\n      }\n      basePart.paragraphLoop = true;\n      var level = 0;\n      var chunks = chunkBy(parsed, function (p) {\n        if (isParagraphStart(p)) {\n          level++;\n          if (level === 1) {\n            return \"start\";\n          }\n        }\n        if (isParagraphEnd(p)) {\n          level--;\n          if (level === 0) {\n            return \"end\";\n          }\n        }\n        return null;\n      });\n      var firstChunk = chunks[0];\n      var lastChunk = last(chunks);\n      var firstOffset = getOffset(firstChunk);\n      var lastOffset = getOffset(lastChunk);\n      basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);\n      basePart.hasPageBreak = hasPageBreak(lastChunk);\n      if (hasImage(firstChunk)) {\n        firstOffset = 0;\n      }\n      if (hasImage(lastChunk)) {\n        lastOffset = 0;\n      }\n      return parsed.slice(firstOffset, parsed.length - lastOffset);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(part, options) {\n      var self = this;\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var sm = options.scopeManager;\n      var promisedValue = sm.getValueAsync(part.value, {\n        part: part\n      });\n      var promises = [];\n      var lastPromise;\n      if (self.resolveSerially) {\n        lastPromise = Promise.resolve(null);\n      }\n      function loopOver(scope, i, length) {\n        var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);\n        if (self.resolveSerially) {\n          lastPromise = lastPromise.then(function () {\n            return options.resolve(_objectSpread(_objectSpread({}, options), {}, {\n              compiled: part.subparsed,\n              tags: {},\n              scopeManager: scopeManager\n            }));\n          });\n          promises.push(lastPromise);\n        } else {\n          promises.push(options.resolve(_objectSpread(_objectSpread({}, options), {}, {\n            compiled: part.subparsed,\n            tags: {},\n            scopeManager: scopeManager\n          })));\n        }\n      }\n      var errorList = [];\n      return promisedValue.then(function (values) {\n        values !== null && values !== void 0 ? values : values = options.nullGetter(part);\n        if (values instanceof Promise) {\n          return values.then(function (values) {\n            if (values instanceof Array) {\n              return Promise.all(values);\n            }\n            return values;\n          });\n        }\n        if (values instanceof Array) {\n          return Promise.all(values);\n        }\n        return values;\n      }).then(function (values) {\n        sm.loopOverValue(values, loopOver, part.inverted);\n        return Promise.all(promises).then(function (r) {\n          return r.map(function (_ref6) {\n            var resolved = _ref6.resolved,\n              errors = _ref6.errors;\n            pushArray(errorList, errors);\n            return resolved;\n          });\n        }).then(function (value) {\n          if (errorList.length > 0) {\n            throw errorList;\n          }\n          return value;\n        });\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      var self = this;\n      if (part.tag === \"p:xfrm\") {\n        self.inXfrm = part.position === \"start\";\n      }\n      if (part.tag === \"a:ext\" && self.inXfrm) {\n        self.lastExt = part;\n        return part;\n      }\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var totalValue = [];\n      var errors = [];\n      var heightOffset = 0;\n      var firstTag = part.subparsed[0];\n      var tagHeight = 0;\n      if ((firstTag === null || firstTag === void 0 ? void 0 : firstTag.tag) === \"a:tr\") {\n        tagHeight = +getSingleAttribute(firstTag.value, \"h\");\n      }\n      heightOffset -= tagHeight;\n      var a16RowIdOffset = 0;\n      var insideParagraphLoop = isInsideParagraphLoop(part);\n      function loopOver(scope, i, length) {\n        heightOffset += tagHeight;\n        var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i, part, length);\n        for (var _i16 = 0, _part$subparsed2 = part.subparsed; _i16 < _part$subparsed2.length; _i16++) {\n          var pp = _part$subparsed2[_i16];\n          if (isTagStart(\"a16:rowId\", pp)) {\n            var val = +getSingleAttribute(pp.value, \"val\") + a16RowIdOffset;\n            a16RowIdOffset = 1;\n            pp.value = setSingleAttribute(pp.value, \"val\", val);\n          }\n        }\n        var subRendered = options.render(_objectSpread(_objectSpread({}, options), {}, {\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        }));\n        if (part.hasPageBreak && i === length - 1 && insideParagraphLoop) {\n          addPageBreakAtEnd(subRendered);\n        }\n        var isNotFirst = scopeManager.scopePathItem.some(function (i) {\n          return i !== 0;\n        });\n        if (isNotFirst) {\n          if (part.sectPrCount === 1) {\n            subRendered.parts = dropHeaderFooterRefs(subRendered.parts);\n          }\n          if (part.addContinuousType) {\n            subRendered.parts = addContinuousType(subRendered.parts);\n          }\n        } else if (part.addNextPage) {\n          addSectionBefore(subRendered.parts, self.sects[part.addNextPage.index]);\n        }\n        if (part.addNextPage) {\n          addPageBreakAtEnd(subRendered);\n        }\n        if (part.hasPageBreakBeginning && insideParagraphLoop) {\n          addPageBreakAtBeginning(subRendered);\n        }\n        for (var _i18 = 0, _subRendered$parts2 = subRendered.parts; _i18 < _subRendered$parts2.length; _i18++) {\n          var _val = _subRendered$parts2[_i18];\n          totalValue.push(_val);\n        }\n        pushArray(errors, subRendered.errors);\n      }\n      var value = options.scopeManager.getValue(part.value, {\n        part: part\n      });\n      value !== null && value !== void 0 ? value : value = options.nullGetter(part);\n      var result = options.scopeManager.loopOverValue(value, loopOver, part.inverted);\n      // if the loop is showing empty content\n      if (result === false) {\n        if (part.lastParagrapSectPr) {\n          if (part.paragraphLoop) {\n            return {\n              value: \"<w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr></w:p>\")\n            };\n          }\n          return {\n            value: \"</w:t></w:r></w:p><w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr><w:r><w:t>\")\n          };\n        }\n        return {\n          value: getPageBreakIfApplies(part) || \"\",\n          errors: errors\n        };\n      }\n      if (heightOffset !== 0) {\n        var cy = +getSingleAttribute(self.lastExt.value, \"cy\");\n        /*\n         * We do edit the value of a previous result here\n         * #edit-value-backwards\n         */\n        self.lastExt.value = setSingleAttribute(self.lastExt.value, \"cy\", cy + heightOffset);\n      }\n      return {\n        value: options.joinUncorrupt(totalValue, _objectSpread(_objectSpread({}, options), {}, {\n          basePart: part\n        })),\n        errors: errors\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new LoopModule());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2xvb3AuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLDJFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBaUI7QUFDekMsY0FBYyxtQkFBTyxDQUFDLHFGQUFzQjtBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGNBQWM7QUFDL0U7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWLHNFQUFzRSxjQUFjO0FBQ3BGO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQ0FBZ0M7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsbUNBQW1DO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGNBQWM7QUFDN0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvbG9vcC5qcz82ZjcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2RvYy11dGlscy5qc1wiKSxcbiAgY2h1bmtCeSA9IF9yZXF1aXJlLmNodW5rQnksXG4gIGxhc3QgPSBfcmVxdWlyZS5sYXN0LFxuICBpc1BhcmFncmFwaFN0YXJ0ID0gX3JlcXVpcmUuaXNQYXJhZ3JhcGhTdGFydCxcbiAgaXNNb2R1bGUgPSBfcmVxdWlyZS5pc01vZHVsZSxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUucHVzaEFycmF5LFxuICBpc1BhcmFncmFwaEVuZCA9IF9yZXF1aXJlLmlzUGFyYWdyYXBoRW5kLFxuICBpc0NvbnRlbnQgPSBfcmVxdWlyZS5pc0NvbnRlbnQsXG4gIHN0YXJ0c1dpdGggPSBfcmVxdWlyZS5zdGFydHNXaXRoLFxuICBpc1RhZ0VuZCA9IF9yZXF1aXJlLmlzVGFnRW5kLFxuICBpc1RhZ1N0YXJ0ID0gX3JlcXVpcmUuaXNUYWdTdGFydCxcbiAgZ2V0U2luZ2xlQXR0cmlidXRlID0gX3JlcXVpcmUuZ2V0U2luZ2xlQXR0cmlidXRlLFxuICBzZXRTaW5nbGVBdHRyaWJ1dGUgPSBfcmVxdWlyZS5zZXRTaW5nbGVBdHRyaWJ1dGU7XG52YXIgZmlsZXR5cGVzID0gcmVxdWlyZShcIi4uL2ZpbGV0eXBlcy5qc1wiKTtcbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIG1vZHVsZU5hbWUgPSBcImxvb3BcIjtcbmZ1bmN0aW9uIGhhc0NvbnRlbnQocGFydHMpIHtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcGFydHMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBwYXJ0ID0gcGFydHNbX2kyXTtcbiAgICBpZiAoaXNDb250ZW50KHBhcnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RNZWFuaW5nRnVsUGFydChwYXJzZWQpIHtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgcGFyc2VkLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtfaTRdO1xuICAgIGlmIChwYXJ0LnR5cGUgIT09IFwiY29udGVudFwiKSB7XG4gICAgICByZXR1cm4gcGFydDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0luc2lkZVBhcmFncmFwaExvb3AocGFydCkge1xuICB2YXIgZmlyc3RNZWFuaW5nZnVsUGFydCA9IGdldEZpcnN0TWVhbmluZ0Z1bFBhcnQocGFydC5zdWJwYXJzZWQpO1xuICByZXR1cm4gZmlyc3RNZWFuaW5nZnVsUGFydCAhPSBudWxsICYmIGZpcnN0TWVhbmluZ2Z1bFBhcnQudGFnICE9PSBcInc6dFwiO1xufVxuZnVuY3Rpb24gZ2V0UGFnZUJyZWFrSWZBcHBsaWVzKHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQuaGFzUGFnZUJyZWFrICYmIGlzSW5zaWRlUGFyYWdyYXBoTG9vcChwYXJ0KSA/ICc8dzpwPjx3OnI+PHc6YnIgdzp0eXBlPVwicGFnZVwiLz48L3c6cj48L3c6cD4nIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGlzRW5jbG9zZWRCeVBhcmFncmFwaHMocGFyc2VkKSB7XG4gIHJldHVybiBwYXJzZWQubGVuZ3RoICYmIGlzUGFyYWdyYXBoU3RhcnQocGFyc2VkWzBdKSAmJiBpc1BhcmFncmFwaEVuZChsYXN0KHBhcnNlZCkpO1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGNodW5rKSB7XG4gIHJldHVybiBoYXNDb250ZW50KGNodW5rKSA/IDAgOiBjaHVuay5sZW5ndGg7XG59XG5mdW5jdGlvbiBhZGRQYWdlQnJlYWtBdEVuZChzdWJSZW5kZXJlZCkge1xuICB2YXIgaiA9IHN1YlJlbmRlcmVkLnBhcnRzLmxlbmd0aCAtIDE7XG4gIGlmIChzdWJSZW5kZXJlZC5wYXJ0c1tqXSA9PT0gXCI8L3c6cD5cIikge1xuICAgIHN1YlJlbmRlcmVkLnBhcnRzLnNwbGljZShqLCAwLCAnPHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPicpO1xuICB9IGVsc2Uge1xuICAgIHN1YlJlbmRlcmVkLnBhcnRzLnB1c2goJzx3OnA+PHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPjwvdzpwPicpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRQYWdlQnJlYWtBdEJlZ2lubmluZyhzdWJSZW5kZXJlZCkge1xuICBzdWJSZW5kZXJlZC5wYXJ0cy51bnNoaWZ0KCc8dzpwPjx3OnI+PHc6YnIgdzp0eXBlPVwicGFnZVwiLz48L3c6cj48L3c6cD4nKTtcbn1cbmZ1bmN0aW9uIGlzQ29udGludW91cyhwYXJ0cykge1xuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBwYXJ0cy5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tfaTZdO1xuICAgIGlmIChpc1RhZ1N0YXJ0KFwidzp0eXBlXCIsIHBhcnQpICYmIHBhcnQudmFsdWUuaW5kZXhPZihcImNvbnRpbnVvdXNcIikgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOZXh0UGFnZShwYXJ0cykge1xuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBwYXJ0cy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tfaThdO1xuICAgIGlmIChpc1RhZ1N0YXJ0KFwidzp0eXBlXCIsIHBhcnQpICYmIHBhcnQudmFsdWUuaW5kZXhPZigndzp2YWw9XCJuZXh0UGFnZVwiJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWRkU2VjdGlvbkJlZm9yZShwYXJ0cywgc2VjdCkge1xuICBwYXJ0cy51bnNoaWZ0KFwiPHc6cD48dzpwUHI+XCIuY29uY2F0KHNlY3QubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pLmpvaW4oXCJcIiksIFwiPC93OnBQcj48L3c6cD5cIikpO1xufVxuZnVuY3Rpb24gYWRkQ29udGludW91c1R5cGUocGFydHMpIHtcbiAgdmFyIHN0b3AgPSBmYWxzZTtcbiAgdmFyIGluU2VjdFByID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmICghc3RvcCAmJiBzdGFydHNXaXRoKHBhcnQsIFwiPHc6c2VjdFByXCIpKSB7XG4gICAgICBpblNlY3RQciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpblNlY3RQcikge1xuICAgICAgaWYgKHN0YXJ0c1dpdGgocGFydCwgXCI8dzp0eXBlXCIpKSB7XG4gICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFzdG9wICYmIHN0YXJ0c1dpdGgocGFydCwgXCI8L3c6c2VjdFByXCIpKSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAwLCAnPHc6dHlwZSB3OnZhbD1cImNvbnRpbnVvdXNcIi8+Jyk7XG4gICAgICAgIGkrKzsgLy8gU2tpcCByZS1wcm9jZXNzaW5nIHRoZSBub3ctc2hpZnRlZCBjbG9zaW5nIHRhZyB0byBhdm9pZCBpbmZpbml0ZSBpbnNlcnRpb25cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuZnVuY3Rpb24gZHJvcEhlYWRlckZvb3RlclJlZnMocGFydHMpIHtcbiAgdmFyIHdyaXRlSW5kZXggPSAwO1xuICBmb3IgKHZhciByZWFkSW5kZXggPSAwOyByZWFkSW5kZXggPCBwYXJ0cy5sZW5ndGg7IHJlYWRJbmRleCsrKSB7XG4gICAgaWYgKCFzdGFydHNXaXRoKHBhcnRzW3JlYWRJbmRleF0sIFwiPHc6aGVhZGVyUmVmZXJlbmNlXCIpICYmICFzdGFydHNXaXRoKHBhcnRzW3JlYWRJbmRleF0sIFwiPHc6Zm9vdGVyUmVmZXJlbmNlXCIpKSB7XG4gICAgICBwYXJ0c1t3cml0ZUluZGV4XSA9IHBhcnRzW3JlYWRJbmRleF07XG4gICAgICB3cml0ZUluZGV4Kys7XG4gICAgfVxuICB9XG4gIHBhcnRzLmxlbmd0aCA9IHdyaXRlSW5kZXg7XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIGhhc1BhZ2VCcmVhayhjaHVuaykge1xuICBmb3IgKHZhciBfaTAgPSAwOyBfaTAgPCBjaHVuay5sZW5ndGg7IF9pMCsrKSB7XG4gICAgdmFyIHBhcnQgPSBjaHVua1tfaTBdO1xuICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJ3OmJyXCIgJiYgcGFydC52YWx1ZS5pbmRleE9mKCd3OnR5cGU9XCJwYWdlXCInKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYXNJbWFnZShjaHVuaykge1xuICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IGNodW5rLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgdmFyIGVsID0gY2h1bmtbX2kxMF07XG4gICAgaWYgKGVsLnRhZyA9PT0gXCJ3OmRyYXdpbmdcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFNlY3RQcihjaHVua3MpIHtcbiAgdmFyIHNlY3RQcnMgPSBbXTtcbiAgdmFyIGN1cnJlbnRTZWN0UHIgPSBudWxsO1xuICBmb3IgKHZhciBfaTEyID0gMDsgX2kxMiA8IGNodW5rcy5sZW5ndGg7IF9pMTIrKykge1xuICAgIHZhciBwYXJ0ID0gY2h1bmtzW19pMTJdO1xuICAgIGlmIChpc1RhZ1N0YXJ0KFwidzpzZWN0UHJcIiwgcGFydCkpIHtcbiAgICAgIGN1cnJlbnRTZWN0UHIgPSBbXTtcbiAgICAgIHNlY3RQcnMucHVzaChjdXJyZW50U2VjdFByKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRTZWN0UHIgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRTZWN0UHIucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgaWYgKGlzVGFnRW5kKFwidzpzZWN0UHJcIiwgcGFydCkpIHtcbiAgICAgIGN1cnJlbnRTZWN0UHIgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VjdFBycztcbn1cbmZ1bmN0aW9uIGdldFNlY3RQckhlYWRlckZvb3RlckNoYW5nZUNvdW50KGNodW5rcykge1xuICB2YXIgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICB2YXIgc2VjdFByQ291bnQgPSAwO1xuICBmb3IgKHZhciBfaTE0ID0gMDsgX2kxNCA8IGNodW5rcy5sZW5ndGg7IF9pMTQrKykge1xuICAgIHZhciBwYXJ0ID0gY2h1bmtzW19pMTRdO1xuICAgIGlmIChpc1RhZ1N0YXJ0KFwidzpzZWN0UHJcIiwgcGFydCkpIHtcbiAgICAgIGNvbGxlY3RTZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdFNlY3RQcikge1xuICAgICAgaWYgKHBhcnQudGFnID09PSBcInc6aGVhZGVyUmVmZXJlbmNlXCIgfHwgcGFydC50YWcgPT09IFwidzpmb290ZXJSZWZlcmVuY2VcIikge1xuICAgICAgICBzZWN0UHJDb3VudCsrO1xuICAgICAgICBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1RhZ0VuZChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWN0UHJDb3VudDtcbn1cbmZ1bmN0aW9uIGdldExhc3RTZWN0UHIocGFyc2VkKSB7XG4gIHZhciBzZWN0UHIgPSBbXTtcbiAgdmFyIGluU2VjdFByID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBwYXJzZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcblxuICAgIC8qXG4gICAgICogU2luY2Ugd2UgdHJ5IHRvIGdldCB0aGUgbGFzdCBzZWN0UHIsIHdlIHRyYXZlcnNlIHRoZSBwYXJzZWQgYXJyYXlcbiAgICAgKiBmcm9tIHRoZSBlbmQgdG8gYmVnaW5uaW5nLCB0aGlzIGlzIHdoeSBpblNlY3RQciBiZWNvbWVzIHRydWUgd2hlbiB3ZVxuICAgICAqIHdlIHNlZSBhIDwvdzpzZWN0UHI+IGNsb3NpbmcgdGFnXG4gICAgICovXG4gICAgaWYgKGlzVGFnRW5kKFwidzpzZWN0UHJcIiwgcGFydCkpIHtcbiAgICAgIGluU2VjdFByID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzVGFnU3RhcnQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgc2VjdFByLnVuc2hpZnQocGFydC52YWx1ZSk7XG4gICAgICBpblNlY3RQciA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5TZWN0UHIpIHtcbiAgICAgIHNlY3RQci51bnNoaWZ0KHBhcnQudmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNQYXJhZ3JhcGhTdGFydChwYXJ0KSkge1xuICAgICAgaWYgKHNlY3RQci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzZWN0UHIuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbnZhciBMb29wTW9kdWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9vcE1vZHVsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9vcE1vZHVsZSk7XG4gICAgdGhpcy5uYW1lID0gXCJMb29wTW9kdWxlXCI7XG4gICAgdGhpcy5pblhmcm0gPSBmYWxzZTtcbiAgICB0aGlzLnRvdGFsU2VjdFByID0gMDtcbiAgICB0aGlzLnByZWZpeCA9IHtcbiAgICAgIHN0YXJ0OiBcIiNcIixcbiAgICAgIGVuZDogXCIvXCIsXG4gICAgICBkYXNoOiAvXi0oW15cXHNdKylcXHMoLispLyxcbiAgICAgIGludmVydGVkOiBcIl5cIlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMb29wTW9kdWxlLCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdHMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIHRoaXMuZG9jeHRlbXBsYXRlciA9IGRvY3h0ZW1wbGF0ZXI7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyc2UocGFyc2VkLCBfcmVmMikge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gX3JlZjIuY29udGVudFR5cGU7XG4gICAgICBpZiAoZmlsZXR5cGVzLm1haW4uaW5kZXhPZihjb250ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2VjdHMgPSBnZXRTZWN0UHIocGFyc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICB2YXIgbW9kdWxlID0gbW9kdWxlTmFtZTtcbiAgICAgIHJldHVybiBbW3RoaXMucHJlZml4LnN0YXJ0LCBtb2R1bGUsIHtcbiAgICAgICAgZXhwYW5kVG86IFwiYXV0b1wiLFxuICAgICAgICBsb2NhdGlvbjogXCJzdGFydFwiLFxuICAgICAgICBpbnZlcnRlZDogZmFsc2VcbiAgICAgIH1dLCBbdGhpcy5wcmVmaXguaW52ZXJ0ZWQsIG1vZHVsZSwge1xuICAgICAgICBleHBhbmRUbzogXCJhdXRvXCIsXG4gICAgICAgIGxvY2F0aW9uOiBcInN0YXJ0XCIsXG4gICAgICAgIGludmVydGVkOiB0cnVlXG4gICAgICB9XSwgW3RoaXMucHJlZml4LmVuZCwgbW9kdWxlLCB7XG4gICAgICAgIGxvY2F0aW9uOiBcImVuZFwiXG4gICAgICB9XSwgW3RoaXMucHJlZml4LmRhc2gsIG1vZHVsZSwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAzKSxcbiAgICAgICAgICBleHBhbmRUbyA9IF9yZWY0WzFdLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjRbMl07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG9jYXRpb246IFwic3RhcnRcIixcbiAgICAgICAgICBpbnZlcnRlZDogZmFsc2UsXG4gICAgICAgICAgZXhwYW5kVG86IGV4cGFuZFRvLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfV1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFpdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhaXRzKHRyYWl0TmFtZSwgcGFyc2VkKSB7XG4gICAgICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSBnZXRUcmFpdHMgc2hvdWxkIGRpc2FwcGVhciBpbiB2NFxuICAgICAgaWYgKHRyYWl0TmFtZSAhPT0gXCJleHBhbmRQYWlyXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuXG4gICAgICB2YXIgdGFncyA9IFtdO1xuICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMCwgbGVuID0gcGFyc2VkLmxlbmd0aDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnNlZFtvZmZzZXRdO1xuICAgICAgICBpZiAoaXNNb2R1bGUocGFydCwgbW9kdWxlTmFtZSkgJiYgcGFydC5zdWJwYXJzZWQgPT0gbnVsbCkge1xuICAgICAgICAgIHRhZ3MucHVzaCh7XG4gICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHkgKi9cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBhcnNlZCwgX3JlZjUpIHtcbiAgICAgIHZhciBiYXNlUGFydCA9IF9yZWY1LmJhc2VQYXJ0O1xuICAgICAgaWYgKGJhc2VQYXJ0ICYmIHRoaXMuZG9jeHRlbXBsYXRlci5maWxlVHlwZSA9PT0gXCJkb2N4XCIgJiYgcGFyc2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmFzZVBhcnQuc2VjdFByQ291bnQgPSBnZXRTZWN0UHJIZWFkZXJGb290ZXJDaGFuZ2VDb3VudChwYXJzZWQpO1xuICAgICAgICB0aGlzLnRvdGFsU2VjdFByICs9IGJhc2VQYXJ0LnNlY3RQckNvdW50O1xuICAgICAgICB2YXIgc2VjdHMgPSB0aGlzLnNlY3RzO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbiA9IHNlY3RzLmxlbmd0aDsgaW5kZXggPCBsZW47IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgc2VjdCA9IHNlY3RzW2luZGV4XTtcbiAgICAgICAgICBpZiAoYmFzZVBhcnQubEluZGV4IDwgc2VjdFswXS5sSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCArIDEgPCBzZWN0cy5sZW5ndGggJiYgaXNDb250aW51b3VzKHNlY3RzW2luZGV4ICsgMV0pKSB7XG4gICAgICAgICAgICAgIGJhc2VQYXJ0LmFkZENvbnRpbnVvdXNUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyc2VkWzBdLmxJbmRleCA8IHNlY3RbMF0ubEluZGV4ICYmIHNlY3RbMF0ubEluZGV4IDwgYmFzZVBhcnQubEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaXNOZXh0UGFnZShzZWN0c1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGJhc2VQYXJ0LmFkZE5leHRQYWdlID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJhc2VQYXJ0Lmxhc3RQYXJhZ3JhcFNlY3RQciA9IGdldExhc3RTZWN0UHIocGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIGlmICghYmFzZVBhcnQgfHwgYmFzZVBhcnQuZXhwYW5kVG8gIT09IFwiYXV0b1wiIHx8IGJhc2VQYXJ0Lm1vZHVsZSAhPT0gbW9kdWxlTmFtZSB8fCAhaXNFbmNsb3NlZEJ5UGFyYWdyYXBocyhwYXJzZWQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBiYXNlUGFydC5wYXJhZ3JhcGhMb29wID0gdHJ1ZTtcbiAgICAgIHZhciBsZXZlbCA9IDA7XG4gICAgICB2YXIgY2h1bmtzID0gY2h1bmtCeShwYXJzZWQsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmIChpc1BhcmFncmFwaFN0YXJ0KHApKSB7XG4gICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcInN0YXJ0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhcmFncmFwaEVuZChwKSkge1xuICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlbmRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaXJzdENodW5rID0gY2h1bmtzWzBdO1xuICAgICAgdmFyIGxhc3RDaHVuayA9IGxhc3QoY2h1bmtzKTtcbiAgICAgIHZhciBmaXJzdE9mZnNldCA9IGdldE9mZnNldChmaXJzdENodW5rKTtcbiAgICAgIHZhciBsYXN0T2Zmc2V0ID0gZ2V0T2Zmc2V0KGxhc3RDaHVuayk7XG4gICAgICBiYXNlUGFydC5oYXNQYWdlQnJlYWtCZWdpbm5pbmcgPSBoYXNQYWdlQnJlYWsoZmlyc3RDaHVuayk7XG4gICAgICBiYXNlUGFydC5oYXNQYWdlQnJlYWsgPSBoYXNQYWdlQnJlYWsobGFzdENodW5rKTtcbiAgICAgIGlmIChoYXNJbWFnZShmaXJzdENodW5rKSkge1xuICAgICAgICBmaXJzdE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoaGFzSW1hZ2UobGFzdENodW5rKSkge1xuICAgICAgICBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQuc2xpY2UoZmlyc3RPZmZzZXQsIHBhcnNlZC5sZW5ndGggLSBsYXN0T2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKHBhcnQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmICghaXNNb2R1bGUocGFydCwgbW9kdWxlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc20gPSBvcHRpb25zLnNjb3BlTWFuYWdlcjtcbiAgICAgIHZhciBwcm9taXNlZFZhbHVlID0gc20uZ2V0VmFsdWVBc3luYyhwYXJ0LnZhbHVlLCB7XG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICB2YXIgbGFzdFByb21pc2U7XG4gICAgICBpZiAoc2VsZi5yZXNvbHZlU2VyaWFsbHkpIHtcbiAgICAgICAgbGFzdFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsb29wT3ZlcihzY29wZSwgaSwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzY29wZU1hbmFnZXIgPSBzbS5jcmVhdGVTdWJTY29wZU1hbmFnZXIoc2NvcGUsIHBhcnQudmFsdWUsIGksIHBhcnQsIGxlbmd0aCk7XG4gICAgICAgIGlmIChzZWxmLnJlc29sdmVTZXJpYWxseSkge1xuICAgICAgICAgIGxhc3RQcm9taXNlID0gbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZXNvbHZlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgIGNvbXBpbGVkOiBwYXJ0LnN1YnBhcnNlZCxcbiAgICAgICAgICAgICAgdGFnczoge30sXG4gICAgICAgICAgICAgIHNjb3BlTWFuYWdlcjogc2NvcGVNYW5hZ2VyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChsYXN0UHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChvcHRpb25zLnJlc29sdmUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgIGNvbXBpbGVkOiBwYXJ0LnN1YnBhcnNlZCxcbiAgICAgICAgICAgIHRhZ3M6IHt9LFxuICAgICAgICAgICAgc2NvcGVNYW5hZ2VyOiBzY29wZU1hbmFnZXJcbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3JMaXN0ID0gW107XG4gICAgICByZXR1cm4gcHJvbWlzZWRWYWx1ZS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzICE9PSBudWxsICYmIHZhbHVlcyAhPT0gdm9pZCAwID8gdmFsdWVzIDogdmFsdWVzID0gb3B0aW9ucy5udWxsR2V0dGVyKHBhcnQpO1xuICAgICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZXMudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgc20ubG9vcE92ZXJWYWx1ZSh2YWx1ZXMsIGxvb3BPdmVyLCBwYXJ0LmludmVydGVkKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgcmV0dXJuIHIubWFwKGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gX3JlZjYucmVzb2x2ZWQsXG4gICAgICAgICAgICAgIGVycm9ycyA9IF9yZWY2LmVycm9ycztcbiAgICAgICAgICAgIHB1c2hBcnJheShlcnJvckxpc3QsIGVycm9ycyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGVycm9yTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvckxpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihwYXJ0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAocGFydC50YWcgPT09IFwicDp4ZnJtXCIpIHtcbiAgICAgICAgc2VsZi5pblhmcm0gPSBwYXJ0LnBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG4gICAgICB9XG4gICAgICBpZiAocGFydC50YWcgPT09IFwiYTpleHRcIiAmJiBzZWxmLmluWGZybSkge1xuICAgICAgICBzZWxmLmxhc3RFeHQgPSBwYXJ0O1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNNb2R1bGUocGFydCwgbW9kdWxlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgdG90YWxWYWx1ZSA9IFtdO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIGhlaWdodE9mZnNldCA9IDA7XG4gICAgICB2YXIgZmlyc3RUYWcgPSBwYXJ0LnN1YnBhcnNlZFswXTtcbiAgICAgIHZhciB0YWdIZWlnaHQgPSAwO1xuICAgICAgaWYgKChmaXJzdFRhZyA9PT0gbnVsbCB8fCBmaXJzdFRhZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3RUYWcudGFnKSA9PT0gXCJhOnRyXCIpIHtcbiAgICAgICAgdGFnSGVpZ2h0ID0gK2dldFNpbmdsZUF0dHJpYnV0ZShmaXJzdFRhZy52YWx1ZSwgXCJoXCIpO1xuICAgICAgfVxuICAgICAgaGVpZ2h0T2Zmc2V0IC09IHRhZ0hlaWdodDtcbiAgICAgIHZhciBhMTZSb3dJZE9mZnNldCA9IDA7XG4gICAgICB2YXIgaW5zaWRlUGFyYWdyYXBoTG9vcCA9IGlzSW5zaWRlUGFyYWdyYXBoTG9vcChwYXJ0KTtcbiAgICAgIGZ1bmN0aW9uIGxvb3BPdmVyKHNjb3BlLCBpLCBsZW5ndGgpIHtcbiAgICAgICAgaGVpZ2h0T2Zmc2V0ICs9IHRhZ0hlaWdodDtcbiAgICAgICAgdmFyIHNjb3BlTWFuYWdlciA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyLmNyZWF0ZVN1YlNjb3BlTWFuYWdlcihzY29wZSwgcGFydC52YWx1ZSwgaSwgcGFydCwgbGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgX2kxNiA9IDAsIF9wYXJ0JHN1YnBhcnNlZDIgPSBwYXJ0LnN1YnBhcnNlZDsgX2kxNiA8IF9wYXJ0JHN1YnBhcnNlZDIubGVuZ3RoOyBfaTE2KyspIHtcbiAgICAgICAgICB2YXIgcHAgPSBfcGFydCRzdWJwYXJzZWQyW19pMTZdO1xuICAgICAgICAgIGlmIChpc1RhZ1N0YXJ0KFwiYTE2OnJvd0lkXCIsIHBwKSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9ICtnZXRTaW5nbGVBdHRyaWJ1dGUocHAudmFsdWUsIFwidmFsXCIpICsgYTE2Um93SWRPZmZzZXQ7XG4gICAgICAgICAgICBhMTZSb3dJZE9mZnNldCA9IDE7XG4gICAgICAgICAgICBwcC52YWx1ZSA9IHNldFNpbmdsZUF0dHJpYnV0ZShwcC52YWx1ZSwgXCJ2YWxcIiwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YlJlbmRlcmVkID0gb3B0aW9ucy5yZW5kZXIoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICBjb21waWxlZDogcGFydC5zdWJwYXJzZWQsXG4gICAgICAgICAgdGFnczoge30sXG4gICAgICAgICAgc2NvcGVNYW5hZ2VyOiBzY29wZU1hbmFnZXJcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAocGFydC5oYXNQYWdlQnJlYWsgJiYgaSA9PT0gbGVuZ3RoIC0gMSAmJiBpbnNpZGVQYXJhZ3JhcGhMb29wKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRFbmQoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc05vdEZpcnN0ID0gc2NvcGVNYW5hZ2VyLnNjb3BlUGF0aEl0ZW0uc29tZShmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpICE9PSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzTm90Rmlyc3QpIHtcbiAgICAgICAgICBpZiAocGFydC5zZWN0UHJDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgc3ViUmVuZGVyZWQucGFydHMgPSBkcm9wSGVhZGVyRm9vdGVyUmVmcyhzdWJSZW5kZXJlZC5wYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0LmFkZENvbnRpbnVvdXNUeXBlKSB7XG4gICAgICAgICAgICBzdWJSZW5kZXJlZC5wYXJ0cyA9IGFkZENvbnRpbnVvdXNUeXBlKHN1YlJlbmRlcmVkLnBhcnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFydC5hZGROZXh0UGFnZSkge1xuICAgICAgICAgIGFkZFNlY3Rpb25CZWZvcmUoc3ViUmVuZGVyZWQucGFydHMsIHNlbGYuc2VjdHNbcGFydC5hZGROZXh0UGFnZS5pbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LmFkZE5leHRQYWdlKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRFbmQoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0Lmhhc1BhZ2VCcmVha0JlZ2lubmluZyAmJiBpbnNpZGVQYXJhZ3JhcGhMb29wKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRCZWdpbm5pbmcoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMTggPSAwLCBfc3ViUmVuZGVyZWQkcGFydHMyID0gc3ViUmVuZGVyZWQucGFydHM7IF9pMTggPCBfc3ViUmVuZGVyZWQkcGFydHMyLmxlbmd0aDsgX2kxOCsrKSB7XG4gICAgICAgICAgdmFyIF92YWwgPSBfc3ViUmVuZGVyZWQkcGFydHMyW19pMThdO1xuICAgICAgICAgIHRvdGFsVmFsdWUucHVzaChfdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoQXJyYXkoZXJyb3JzLCBzdWJSZW5kZXJlZC5lcnJvcnMpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy5zY29wZU1hbmFnZXIuZ2V0VmFsdWUocGFydC52YWx1ZSwge1xuICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICB9KTtcbiAgICAgIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IHZhbHVlID0gb3B0aW9ucy5udWxsR2V0dGVyKHBhcnQpO1xuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyLmxvb3BPdmVyVmFsdWUodmFsdWUsIGxvb3BPdmVyLCBwYXJ0LmludmVydGVkKTtcbiAgICAgIC8vIGlmIHRoZSBsb29wIGlzIHNob3dpbmcgZW1wdHkgY29udGVudFxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHBhcnQubGFzdFBhcmFncmFwU2VjdFByKSB7XG4gICAgICAgICAgaWYgKHBhcnQucGFyYWdyYXBoTG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFwiPHc6cD48dzpwUHI+XCIuY29uY2F0KHBhcnQubGFzdFBhcmFncmFwU2VjdFByLCBcIjwvdzpwUHI+PC93OnA+XCIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IFwiPC93OnQ+PC93OnI+PC93OnA+PHc6cD48dzpwUHI+XCIuY29uY2F0KHBhcnQubGFzdFBhcmFncmFwU2VjdFByLCBcIjwvdzpwUHI+PHc6cj48dzp0PlwiKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogZ2V0UGFnZUJyZWFrSWZBcHBsaWVzKHBhcnQpIHx8IFwiXCIsXG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgdmFyIGN5ID0gK2dldFNpbmdsZUF0dHJpYnV0ZShzZWxmLmxhc3RFeHQudmFsdWUsIFwiY3lcIik7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdlIGRvIGVkaXQgdGhlIHZhbHVlIG9mIGEgcHJldmlvdXMgcmVzdWx0IGhlcmVcbiAgICAgICAgICogI2VkaXQtdmFsdWUtYmFja3dhcmRzXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmxhc3RFeHQudmFsdWUgPSBzZXRTaW5nbGVBdHRyaWJ1dGUoc2VsZi5sYXN0RXh0LnZhbHVlLCBcImN5XCIsIGN5ICsgaGVpZ2h0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBvcHRpb25zLmpvaW5VbmNvcnJ1cHQodG90YWxWYWx1ZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICBiYXNlUGFydDogcGFydFxuICAgICAgICB9KSksXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBMb29wTW9kdWxlKCkpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/loop.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/rawxml.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/rawxml.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar traits = __webpack_require__(/*! ../traits.js */ \"(rsc)/./node_modules/docxtemplater/js/traits.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  isContent = _require.isContent;\nvar _require2 = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph,\n  getInvalidRawXMLValueException = _require2.getInvalidRawXMLValueException;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"rawxml\";\nfunction getInner(_ref) {\n  var part = _ref.part,\n    left = _ref.left,\n    right = _ref.right,\n    postparsed = _ref.postparsed,\n    index = _ref.index;\n  var paragraphParts = postparsed.slice(left + 1, right);\n  for (var i = 0, len = paragraphParts.length; i < len; i++) {\n    if (i === index - left - 1) {\n      continue;\n    }\n    var p = paragraphParts[i];\n    if (isContent(p)) {\n      throwRawTagShouldBeOnlyTextInParagraph({\n        paragraphParts: paragraphParts,\n        part: part\n      });\n    }\n  }\n  return part;\n}\nvar RawXmlModule = /*#__PURE__*/function () {\n  function RawXmlModule() {\n    _classCallCheck(this, RawXmlModule);\n    this.name = \"RawXmlModule\";\n    this.prefix = \"@\";\n  }\n  return _createClass(RawXmlModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.fileTypeConfig = docxtemplater.fileTypeConfig;\n      return options;\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      return [[this.prefix, moduleName]];\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed) {\n      return traits.expandToOne(postparsed, {\n        moduleName: moduleName,\n        getInner: getInner,\n        expandTo: this.fileTypeConfig.tagRawXml,\n        error: {\n          message: \"Raw tag not in paragraph\",\n          id: \"raw_tag_outerxml_invalid\",\n          explanation: function explanation(part) {\n            return \"The tag \\\"\".concat(part.value, \"\\\" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.\");\n          }\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.module !== moduleName) {\n        return null;\n      }\n      var value;\n      var errors = [];\n      try {\n        value = options.scopeManager.getValue(part.value, {\n          part: part\n        });\n        value !== null && value !== void 0 ? value : value = options.nullGetter(part);\n      } catch (e) {\n        errors.push(e);\n        return {\n          errors: errors\n        };\n      }\n      value = value ? value : \"\";\n      if (typeof value === \"string\") {\n        return {\n          value: value\n        };\n      }\n      return {\n        errors: [getInvalidRawXMLValueException({\n          tag: part.value,\n          value: value,\n          offset: part.offset\n        })]\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new RawXmlModule());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3Jhd3htbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsYUFBYSxtQkFBTyxDQUFDLHFFQUFjO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQywyRUFBaUI7QUFDeEM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBYztBQUN0QztBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHFGQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvcmF3eG1sLmpzPzViZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB0cmFpdHMgPSByZXF1aXJlKFwiLi4vdHJhaXRzLmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2RvYy11dGlscy5qc1wiKSxcbiAgaXNDb250ZW50ID0gX3JlcXVpcmUuaXNDb250ZW50O1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIiksXG4gIHRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoID0gX3JlcXVpcmUyLnRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoLFxuICBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24gPSBfcmVxdWlyZTIuZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uO1xudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgbW9kdWxlTmFtZSA9IFwicmF3eG1sXCI7XG5mdW5jdGlvbiBnZXRJbm5lcihfcmVmKSB7XG4gIHZhciBwYXJ0ID0gX3JlZi5wYXJ0LFxuICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgcmlnaHQgPSBfcmVmLnJpZ2h0LFxuICAgIHBvc3RwYXJzZWQgPSBfcmVmLnBvc3RwYXJzZWQsXG4gICAgaW5kZXggPSBfcmVmLmluZGV4O1xuICB2YXIgcGFyYWdyYXBoUGFydHMgPSBwb3N0cGFyc2VkLnNsaWNlKGxlZnQgKyAxLCByaWdodCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJhZ3JhcGhQYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpID09PSBpbmRleCAtIGxlZnQgLSAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHAgPSBwYXJhZ3JhcGhQYXJ0c1tpXTtcbiAgICBpZiAoaXNDb250ZW50KHApKSB7XG4gICAgICB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCh7XG4gICAgICAgIHBhcmFncmFwaFBhcnRzOiBwYXJhZ3JhcGhQYXJ0cyxcbiAgICAgICAgcGFydDogcGFydFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0O1xufVxudmFyIFJhd1htbE1vZHVsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJhd1htbE1vZHVsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF3WG1sTW9kdWxlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlJhd1htbE1vZHVsZVwiO1xuICAgIHRoaXMucHJlZml4ID0gXCJAXCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSYXdYbWxNb2R1bGUsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0aW9ucywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgdGhpcy5maWxlVHlwZUNvbmZpZyA9IGRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVDb25maWc7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICByZXR1cm4gW1t0aGlzLnByZWZpeCwgbW9kdWxlTmFtZV1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQpIHtcbiAgICAgIHJldHVybiB0cmFpdHMuZXhwYW5kVG9PbmUocG9zdHBhcnNlZCwge1xuICAgICAgICBtb2R1bGVOYW1lOiBtb2R1bGVOYW1lLFxuICAgICAgICBnZXRJbm5lcjogZ2V0SW5uZXIsXG4gICAgICAgIGV4cGFuZFRvOiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ1Jhd1htbCxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBtZXNzYWdlOiBcIlJhdyB0YWcgbm90IGluIHBhcmFncmFwaFwiLFxuICAgICAgICAgIGlkOiBcInJhd190YWdfb3V0ZXJ4bWxfaW52YWxpZFwiLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBmdW5jdGlvbiBleHBsYW5hdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgdGFnIFxcXCJcIi5jb25jYXQocGFydC52YWx1ZSwgXCJcXFwiIGlzIG5vdCBpbnNpZGUgYSBwYXJhZ3JhcGgsIHB1dHRpbmcgcmF3IHRhZ3MgaW5zaWRlIGFuIGlubGluZSBsb29wIGlzIGRpc2FsbG93ZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFydCwgb3B0aW9ucykge1xuICAgICAgaWYgKHBhcnQubW9kdWxlICE9PSBtb2R1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnNjb3BlTWFuYWdlci5nZXRWYWx1ZShwYXJ0LnZhbHVlLCB7XG4gICAgICAgICAgcGFydDogcGFydFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogdmFsdWUgPSBvcHRpb25zLm51bGxHZXR0ZXIocGFydCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JzOiBbZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uKHtcbiAgICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG9mZnNldDogcGFydC5vZmZzZXRcbiAgICAgICAgfSldXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBSYXdYbWxNb2R1bGUoKSk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/rawxml.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/render.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/render.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  getScopeCompilationError = _require.getScopeCompilationError,\n  getCorruptCharactersException = _require.getCorruptCharactersException;\nvar _require2 = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  utf8ToWord = _require2.utf8ToWord,\n  hasCorruptCharacters = _require2.hasCorruptCharacters,\n  removeCorruptCharacters = _require2.removeCorruptCharacters;\nvar _require3 = __webpack_require__(/*! ../content-types.js */ \"(rsc)/./node_modules/docxtemplater/js/content-types.js\"),\n  settingsContentType = _require3.settingsContentType,\n  coreContentType = _require3.coreContentType,\n  appContentType = _require3.appContentType,\n  customContentType = _require3.customContentType;\nvar NON_LINE_BREAKS_CONTENT_TYPE = [settingsContentType, coreContentType, appContentType, customContentType];\nvar ftprefix = {\n  docx: \"w\",\n  pptx: \"a\"\n};\nvar Render = /*#__PURE__*/function () {\n  function Render() {\n    _classCallCheck(this, Render);\n    this.name = \"Render\";\n    this.recordRun = false;\n    this.recordedRun = [];\n  }\n  return _createClass(Render, [{\n    key: \"set\",\n    value: function set(obj) {\n      if (obj.compiled) {\n        this.compiled = obj.compiled;\n      }\n      if (obj.data != null) {\n        this.data = obj.data;\n      }\n    }\n  }, {\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.docxtemplater = docxtemplater;\n      this.brTag = docxtemplater.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\n      this.prefix = ftprefix[docxtemplater.fileType];\n      this.runStartTag = \"\".concat(this.prefix, \":r\");\n      this.runPropsStartTag = \"\".concat(this.prefix, \":rPr\");\n      return options;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, options) {\n      var errors = [];\n      for (var _i2 = 0; _i2 < postparsed.length; _i2++) {\n        var p = postparsed[_i2];\n        if (p.type === \"placeholder\") {\n          var tag = p.value;\n          try {\n            options.cachedParsers[p.lIndex] = this.docxtemplater.parser(tag, {\n              tag: p\n            });\n          } catch (rootError) {\n            errors.push(getScopeCompilationError({\n              tag: tag,\n              rootError: rootError,\n              offset: p.offset\n            }));\n          }\n        }\n      }\n      return {\n        postparsed: postparsed,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"getRenderedMap\",\n    value: function getRenderedMap(mapper) {\n      for (var from in this.compiled) {\n        mapper[from] = {\n          from: from,\n          data: this.data\n        };\n      }\n      return mapper;\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, _ref) {\n      var contentType = _ref.contentType,\n        scopeManager = _ref.scopeManager,\n        linebreaks = _ref.linebreaks,\n        nullGetter = _ref.nullGetter,\n        fileType = _ref.fileType,\n        stripInvalidXMLChars = _ref.stripInvalidXMLChars;\n      if (NON_LINE_BREAKS_CONTENT_TYPE.indexOf(contentType) !== -1) {\n        // Fixes issue tested in #docprops-linebreak\n        linebreaks = false;\n      }\n      if (linebreaks) {\n        this.recordRuns(part);\n      }\n      if (part.type !== \"placeholder\" || part.module) {\n        return;\n      }\n      var value;\n      try {\n        value = scopeManager.getValue(part.value, {\n          part: part\n        });\n      } catch (e) {\n        return {\n          errors: [e]\n        };\n      }\n      value !== null && value !== void 0 ? value : value = nullGetter(part);\n      if (typeof value === \"string\") {\n        if (stripInvalidXMLChars) {\n          value = removeCorruptCharacters(value);\n        } else if ([\"docx\", \"pptx\", \"xlsx\"].indexOf(fileType) !== -1 && hasCorruptCharacters(value)) {\n          return {\n            errors: [getCorruptCharactersException({\n              tag: part.value,\n              value: value,\n              offset: part.offset\n            })]\n          };\n        }\n      }\n      if (fileType === \"text\") {\n        return {\n          value: value\n        };\n      }\n      return {\n        value: linebreaks && typeof value === \"string\" ? this.renderLineBreaks(value) : utf8ToWord(value)\n      };\n    }\n  }, {\n    key: \"recordRuns\",\n    value: function recordRuns(part) {\n      if (part.tag === this.runStartTag) {\n        this.recordedRun = \"\";\n      } else if (part.tag === this.runPropsStartTag) {\n        if (part.position === \"start\") {\n          this.recordRun = true;\n          this.recordedRun += part.value;\n        }\n        if (part.position === \"end\" || part.position === \"selfclosing\") {\n          this.recordedRun += part.value;\n          this.recordRun = false;\n        }\n      } else if (this.recordRun) {\n        this.recordedRun += part.value;\n      }\n    }\n  }, {\n    key: \"renderLineBreaks\",\n    value: function renderLineBreaks(value) {\n      var result = [];\n      var lines = value.split(\"\\n\");\n      for (var i = 0, len = lines.length; i < len; i++) {\n        result.push(utf8ToWord(lines[i]));\n        if (i < lines.length - 1) {\n          result.push(\"</\".concat(this.prefix, \":t></\").concat(this.prefix, \":r>\").concat(this.brTag, \"<\").concat(this.prefix, \":r>\").concat(this.recordedRun, \"<\").concat(this.prefix, \":t\").concat(this.docxtemplater.fileType === \"docx\" ? ' xml:space=\"preserve\"' : \"\", \">\"));\n        }\n      }\n      return result;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new Render());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3JlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsY0FBYyxtQkFBTyxDQUFDLHFGQUFzQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMscUVBQWM7QUFDckM7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3JlbmRlci5qcz82NzE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIiksXG4gIGdldFNjb3BlQ29tcGlsYXRpb25FcnJvciA9IF9yZXF1aXJlLmdldFNjb3BlQ29tcGlsYXRpb25FcnJvcixcbiAgZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICB1dGY4VG9Xb3JkID0gX3JlcXVpcmUyLnV0ZjhUb1dvcmQsXG4gIGhhc0NvcnJ1cHRDaGFyYWN0ZXJzID0gX3JlcXVpcmUyLmhhc0NvcnJ1cHRDaGFyYWN0ZXJzLFxuICByZW1vdmVDb3JydXB0Q2hhcmFjdGVycyA9IF9yZXF1aXJlMi5yZW1vdmVDb3JydXB0Q2hhcmFjdGVycztcbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKFwiLi4vY29udGVudC10eXBlcy5qc1wiKSxcbiAgc2V0dGluZ3NDb250ZW50VHlwZSA9IF9yZXF1aXJlMy5zZXR0aW5nc0NvbnRlbnRUeXBlLFxuICBjb3JlQ29udGVudFR5cGUgPSBfcmVxdWlyZTMuY29yZUNvbnRlbnRUeXBlLFxuICBhcHBDb250ZW50VHlwZSA9IF9yZXF1aXJlMy5hcHBDb250ZW50VHlwZSxcbiAgY3VzdG9tQ29udGVudFR5cGUgPSBfcmVxdWlyZTMuY3VzdG9tQ29udGVudFR5cGU7XG52YXIgTk9OX0xJTkVfQlJFQUtTX0NPTlRFTlRfVFlQRSA9IFtzZXR0aW5nc0NvbnRlbnRUeXBlLCBjb3JlQ29udGVudFR5cGUsIGFwcENvbnRlbnRUeXBlLCBjdXN0b21Db250ZW50VHlwZV07XG52YXIgZnRwcmVmaXggPSB7XG4gIGRvY3g6IFwid1wiLFxuICBwcHR4OiBcImFcIlxufTtcbnZhciBSZW5kZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZW5kZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlcik7XG4gICAgdGhpcy5uYW1lID0gXCJSZW5kZXJcIjtcbiAgICB0aGlzLnJlY29yZFJ1biA9IGZhbHNlO1xuICAgIHRoaXMucmVjb3JkZWRSdW4gPSBbXTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlbmRlciwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvYmopIHtcbiAgICAgIGlmIChvYmouY29tcGlsZWQpIHtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IG9iai5jb21waWxlZDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9iai5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIHRoaXMuZG9jeHRlbXBsYXRlciA9IGRvY3h0ZW1wbGF0ZXI7XG4gICAgICB0aGlzLmJyVGFnID0gZG9jeHRlbXBsYXRlci5maWxlVHlwZSA9PT0gXCJkb2N4XCIgPyBcIjx3OnI+PHc6YnIvPjwvdzpyPlwiIDogXCI8YTpici8+XCI7XG4gICAgICB0aGlzLnByZWZpeCA9IGZ0cHJlZml4W2RvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVdO1xuICAgICAgdGhpcy5ydW5TdGFydFRhZyA9IFwiXCIuY29uY2F0KHRoaXMucHJlZml4LCBcIjpyXCIpO1xuICAgICAgdGhpcy5ydW5Qcm9wc1N0YXJ0VGFnID0gXCJcIi5jb25jYXQodGhpcy5wcmVmaXgsIFwiOnJQclwiKTtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBvc3RwYXJzZWQubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgcCA9IHBvc3RwYXJzZWRbX2kyXTtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHAudmFsdWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FjaGVkUGFyc2Vyc1twLmxJbmRleF0gPSB0aGlzLmRvY3h0ZW1wbGF0ZXIucGFyc2VyKHRhZywge1xuICAgICAgICAgICAgICB0YWc6IHBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKHJvb3RFcnJvcikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgIHJvb3RFcnJvcjogcm9vdEVycm9yLFxuICAgICAgICAgICAgICBvZmZzZXQ6IHAub2Zmc2V0XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVuZGVyZWRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVuZGVyZWRNYXAobWFwcGVyKSB7XG4gICAgICBmb3IgKHZhciBmcm9tIGluIHRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgbWFwcGVyW2Zyb21dID0ge1xuICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcnQsIF9yZWYpIHtcbiAgICAgIHZhciBjb250ZW50VHlwZSA9IF9yZWYuY29udGVudFR5cGUsXG4gICAgICAgIHNjb3BlTWFuYWdlciA9IF9yZWYuc2NvcGVNYW5hZ2VyLFxuICAgICAgICBsaW5lYnJlYWtzID0gX3JlZi5saW5lYnJlYWtzLFxuICAgICAgICBudWxsR2V0dGVyID0gX3JlZi5udWxsR2V0dGVyLFxuICAgICAgICBmaWxlVHlwZSA9IF9yZWYuZmlsZVR5cGUsXG4gICAgICAgIHN0cmlwSW52YWxpZFhNTENoYXJzID0gX3JlZi5zdHJpcEludmFsaWRYTUxDaGFycztcbiAgICAgIGlmIChOT05fTElORV9CUkVBS1NfQ09OVEVOVF9UWVBFLmluZGV4T2YoY29udGVudFR5cGUpICE9PSAtMSkge1xuICAgICAgICAvLyBGaXhlcyBpc3N1ZSB0ZXN0ZWQgaW4gI2RvY3Byb3BzLWxpbmVicmVha1xuICAgICAgICBsaW5lYnJlYWtzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobGluZWJyZWFrcykge1xuICAgICAgICB0aGlzLnJlY29yZFJ1bnMocGFydCk7XG4gICAgICB9XG4gICAgICBpZiAocGFydC50eXBlICE9PSBcInBsYWNlaG9sZGVyXCIgfHwgcGFydC5tb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBzY29wZU1hbmFnZXIuZ2V0VmFsdWUocGFydC52YWx1ZSwge1xuICAgICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyb3JzOiBbZV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IHZhbHVlID0gbnVsbEdldHRlcihwYXJ0KTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHN0cmlwSW52YWxpZFhNTENoYXJzKSB7XG4gICAgICAgICAgdmFsdWUgPSByZW1vdmVDb3JydXB0Q2hhcmFjdGVycyh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoW1wiZG9jeFwiLCBcInBwdHhcIiwgXCJ4bHN4XCJdLmluZGV4T2YoZmlsZVR5cGUpICE9PSAtMSAmJiBoYXNDb3JydXB0Q2hhcmFjdGVycyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBbZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb24oe1xuICAgICAgICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJ0Lm9mZnNldFxuICAgICAgICAgICAgfSldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbGVUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGxpbmVicmVha3MgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdGhpcy5yZW5kZXJMaW5lQnJlYWtzKHZhbHVlKSA6IHV0ZjhUb1dvcmQodmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWNvcmRSdW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29yZFJ1bnMocGFydCkge1xuICAgICAgaWYgKHBhcnQudGFnID09PSB0aGlzLnJ1blN0YXJ0VGFnKSB7XG4gICAgICAgIHRoaXMucmVjb3JkZWRSdW4gPSBcIlwiO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0LnRhZyA9PT0gdGhpcy5ydW5Qcm9wc1N0YXJ0VGFnKSB7XG4gICAgICAgIGlmIChwYXJ0LnBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICB0aGlzLnJlY29yZFJ1biA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yZWNvcmRlZFJ1biArPSBwYXJ0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnBvc2l0aW9uID09PSBcImVuZFwiIHx8IHBhcnQucG9zaXRpb24gPT09IFwic2VsZmNsb3NpbmdcIikge1xuICAgICAgICAgIHRoaXMucmVjb3JkZWRSdW4gKz0gcGFydC52YWx1ZTtcbiAgICAgICAgICB0aGlzLnJlY29yZFJ1biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVjb3JkUnVuKSB7XG4gICAgICAgIHRoaXMucmVjb3JkZWRSdW4gKz0gcGFydC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTGluZUJyZWFrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMaW5lQnJlYWtzKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgbGluZXMgPSB2YWx1ZS5zcGxpdChcIlxcblwiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaCh1dGY4VG9Xb3JkKGxpbmVzW2ldKSk7XG4gICAgICAgIGlmIChpIDwgbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFwiPC9cIi5jb25jYXQodGhpcy5wcmVmaXgsIFwiOnQ+PC9cIikuY29uY2F0KHRoaXMucHJlZml4LCBcIjpyPlwiKS5jb25jYXQodGhpcy5iclRhZywgXCI8XCIpLmNvbmNhdCh0aGlzLnByZWZpeCwgXCI6cj5cIikuY29uY2F0KHRoaXMucmVjb3JkZWRSdW4sIFwiPFwiKS5jb25jYXQodGhpcy5wcmVmaXgsIFwiOnRcIikuY29uY2F0KHRoaXMuZG9jeHRlbXBsYXRlci5maWxlVHlwZSA9PT0gXCJkb2N4XCIgPyAnIHhtbDpzcGFjZT1cInByZXNlcnZlXCInIDogXCJcIiwgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd3JhcHBlcihuZXcgUmVuZGVyKCkpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/render.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/space-preserve.js":
/*!*****************************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/space-preserve.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  isTextStart = _require.isTextStart,\n  isTextEnd = _require.isTextEnd,\n  endsWith = _require.endsWith,\n  startsWith = _require.startsWith,\n  pushArray = _require.pushArray;\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\nvar wTpreservelen = wTpreserve.length;\nvar wtEnd = \"</w:t>\";\nvar wtEndlen = wtEnd.length;\nfunction isWtStart(part) {\n  return isTextStart(part) && part.tag === \"w:t\";\n}\nfunction addXMLPreserve(chunk, index) {\n  var tag = chunk[index].value;\n  if (chunk[index + 1].value === \"</w:t>\") {\n    return tag;\n  }\n  if (tag.indexOf('xml:space=\"preserve\"') !== -1) {\n    return tag;\n  }\n  return tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\n}\nfunction isInsideLoop(meta, chunk) {\n  return meta && meta.basePart && chunk.length > 1;\n}\n\n// This module is used only for `docx` files\nvar SpacePreserve = /*#__PURE__*/function () {\n  function SpacePreserve() {\n    _classCallCheck(this, SpacePreserve);\n    this.name = \"SpacePreserveModule\";\n  }\n  return _createClass(SpacePreserve, [{\n    key: \"postparse\",\n    value: function postparse(postparsed, meta) {\n      var chunk = [],\n        inTextTag = false,\n        endLindex = 0,\n        lastTextTag = 0;\n      function isStartingPlaceHolder(part, chunk) {\n        return part.type === \"placeholder\" && chunk.length > 1;\n      }\n      var result = postparsed.reduce(function (postparsed, part) {\n        if (isWtStart(part)) {\n          inTextTag = true;\n          lastTextTag = chunk.length;\n        }\n        if (!inTextTag) {\n          postparsed.push(part);\n          return postparsed;\n        }\n        chunk.push(part);\n        if (isInsideLoop(meta, chunk)) {\n          endLindex = meta.basePart.endLindex;\n          chunk[0].value = addXMLPreserve(chunk, 0);\n        }\n        if (isStartingPlaceHolder(part, chunk)) {\n          chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          endLindex = part.endLindex;\n        }\n        if (isTextEnd(part) && part.lIndex > endLindex) {\n          if (endLindex !== 0) {\n            chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          }\n          pushArray(postparsed, chunk);\n          chunk = [];\n          inTextTag = false;\n          endLindex = 0;\n          lastTextTag = 0;\n        }\n        return postparsed;\n      }, []);\n      pushArray(result, chunk);\n      return result;\n    }\n  }, {\n    key: \"postrender\",\n    value: function postrender(parts) {\n      var lastNonEmpty = \"\";\n      var lastNonEmptyIndex = 0;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        var p = parts[i];\n        if (p === \"\") {\n          continue;\n        }\n        if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {\n          parts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + \"<w:t/>\";\n          p = p.substr(wtEndlen);\n        }\n        lastNonEmpty = p;\n        lastNonEmptyIndex = i;\n        parts[i] = p;\n      }\n      return parts;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new SpacePreserve());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3NwYWNlLXByZXNlcnZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxjQUFjLG1CQUFPLENBQUMscUZBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywyRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9zcGFjZS1wcmVzZXJ2ZS5qcz81MmI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGlzVGV4dFN0YXJ0ID0gX3JlcXVpcmUuaXNUZXh0U3RhcnQsXG4gIGlzVGV4dEVuZCA9IF9yZXF1aXJlLmlzVGV4dEVuZCxcbiAgZW5kc1dpdGggPSBfcmVxdWlyZS5lbmRzV2l0aCxcbiAgc3RhcnRzV2l0aCA9IF9yZXF1aXJlLnN0YXJ0c1dpdGgsXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheTtcbnZhciB3VHByZXNlcnZlID0gJzx3OnQgeG1sOnNwYWNlPVwicHJlc2VydmVcIj4nO1xudmFyIHdUcHJlc2VydmVsZW4gPSB3VHByZXNlcnZlLmxlbmd0aDtcbnZhciB3dEVuZCA9IFwiPC93OnQ+XCI7XG52YXIgd3RFbmRsZW4gPSB3dEVuZC5sZW5ndGg7XG5mdW5jdGlvbiBpc1d0U3RhcnQocGFydCkge1xuICByZXR1cm4gaXNUZXh0U3RhcnQocGFydCkgJiYgcGFydC50YWcgPT09IFwidzp0XCI7XG59XG5mdW5jdGlvbiBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgaW5kZXgpIHtcbiAgdmFyIHRhZyA9IGNodW5rW2luZGV4XS52YWx1ZTtcbiAgaWYgKGNodW5rW2luZGV4ICsgMV0udmFsdWUgPT09IFwiPC93OnQ+XCIpIHtcbiAgICByZXR1cm4gdGFnO1xuICB9XG4gIGlmICh0YWcuaW5kZXhPZigneG1sOnNwYWNlPVwicHJlc2VydmVcIicpICE9PSAtMSkge1xuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgcmV0dXJuIHRhZy5zdWJzdHIoMCwgdGFnLmxlbmd0aCAtIDEpICsgJyB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPic7XG59XG5mdW5jdGlvbiBpc0luc2lkZUxvb3AobWV0YSwgY2h1bmspIHtcbiAgcmV0dXJuIG1ldGEgJiYgbWV0YS5iYXNlUGFydCAmJiBjaHVuay5sZW5ndGggPiAxO1xufVxuXG4vLyBUaGlzIG1vZHVsZSBpcyB1c2VkIG9ubHkgZm9yIGBkb2N4YCBmaWxlc1xudmFyIFNwYWNlUHJlc2VydmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTcGFjZVByZXNlcnZlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGFjZVByZXNlcnZlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNwYWNlUHJlc2VydmVNb2R1bGVcIjtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNwYWNlUHJlc2VydmUsIFt7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UocG9zdHBhcnNlZCwgbWV0YSkge1xuICAgICAgdmFyIGNodW5rID0gW10sXG4gICAgICAgIGluVGV4dFRhZyA9IGZhbHNlLFxuICAgICAgICBlbmRMaW5kZXggPSAwLFxuICAgICAgICBsYXN0VGV4dFRhZyA9IDA7XG4gICAgICBmdW5jdGlvbiBpc1N0YXJ0aW5nUGxhY2VIb2xkZXIocGFydCwgY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiICYmIGNodW5rLmxlbmd0aCA+IDE7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gcG9zdHBhcnNlZC5yZWR1Y2UoZnVuY3Rpb24gKHBvc3RwYXJzZWQsIHBhcnQpIHtcbiAgICAgICAgaWYgKGlzV3RTdGFydChwYXJ0KSkge1xuICAgICAgICAgIGluVGV4dFRhZyA9IHRydWU7XG4gICAgICAgICAgbGFzdFRleHRUYWcgPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpblRleHRUYWcpIHtcbiAgICAgICAgICBwb3N0cGFyc2VkLnB1c2gocGFydCk7XG4gICAgICAgICAgcmV0dXJuIHBvc3RwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmsucHVzaChwYXJ0KTtcbiAgICAgICAgaWYgKGlzSW5zaWRlTG9vcChtZXRhLCBjaHVuaykpIHtcbiAgICAgICAgICBlbmRMaW5kZXggPSBtZXRhLmJhc2VQYXJ0LmVuZExpbmRleDtcbiAgICAgICAgICBjaHVua1swXS52YWx1ZSA9IGFkZFhNTFByZXNlcnZlKGNodW5rLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdGFydGluZ1BsYWNlSG9sZGVyKHBhcnQsIGNodW5rKSkge1xuICAgICAgICAgIGNodW5rW2xhc3RUZXh0VGFnXS52YWx1ZSA9IGFkZFhNTFByZXNlcnZlKGNodW5rLCBsYXN0VGV4dFRhZyk7XG4gICAgICAgICAgZW5kTGluZGV4ID0gcGFydC5lbmRMaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGV4dEVuZChwYXJ0KSAmJiBwYXJ0LmxJbmRleCA+IGVuZExpbmRleCkge1xuICAgICAgICAgIGlmIChlbmRMaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIGNodW5rW2xhc3RUZXh0VGFnXS52YWx1ZSA9IGFkZFhNTFByZXNlcnZlKGNodW5rLCBsYXN0VGV4dFRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHB1c2hBcnJheShwb3N0cGFyc2VkLCBjaHVuayk7XG4gICAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgICBpblRleHRUYWcgPSBmYWxzZTtcbiAgICAgICAgICBlbmRMaW5kZXggPSAwO1xuICAgICAgICAgIGxhc3RUZXh0VGFnID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zdHBhcnNlZDtcbiAgICAgIH0sIFtdKTtcbiAgICAgIHB1c2hBcnJheShyZXN1bHQsIGNodW5rKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHJlbmRlcihwYXJ0cykge1xuICAgICAgdmFyIGxhc3ROb25FbXB0eSA9IFwiXCI7XG4gICAgICB2YXIgbGFzdE5vbkVtcHR5SW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcGFydHNbaV07XG4gICAgICAgIGlmIChwID09PSBcIlwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZHNXaXRoKGxhc3ROb25FbXB0eSwgd1RwcmVzZXJ2ZSkgJiYgc3RhcnRzV2l0aChwLCB3dEVuZCkpIHtcbiAgICAgICAgICBwYXJ0c1tsYXN0Tm9uRW1wdHlJbmRleF0gPSBsYXN0Tm9uRW1wdHkuc3Vic3RyKDAsIGxhc3ROb25FbXB0eS5sZW5ndGggLSB3VHByZXNlcnZlbGVuKSArIFwiPHc6dC8+XCI7XG4gICAgICAgICAgcCA9IHAuc3Vic3RyKHd0RW5kbGVuKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Tm9uRW1wdHkgPSBwO1xuICAgICAgICBsYXN0Tm9uRW1wdHlJbmRleCA9IGk7XG4gICAgICAgIHBhcnRzW2ldID0gcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd3JhcHBlcihuZXcgU3BhY2VQcmVzZXJ2ZSgpKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/space-preserve.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/parser.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/parser.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  wordToUtf8 = _require.wordToUtf8,\n  pushArray = _require.pushArray;\nvar _require2 = __webpack_require__(/*! ./prefix-matcher.js */ \"(rsc)/./node_modules/docxtemplater/js/prefix-matcher.js\"),\n  match = _require2.match,\n  getValue = _require2.getValue,\n  getValues = _require2.getValues;\nfunction getMatchers(modules, options) {\n  var allMatchers = [];\n  for (var _i2 = 0; _i2 < modules.length; _i2++) {\n    var _module = modules[_i2];\n    if (_module.matchers) {\n      var matchers = _module.matchers(options);\n      if (!(matchers instanceof Array)) {\n        throw new Error(\"module matcher returns a non array\");\n      }\n      pushArray(allMatchers, matchers);\n    }\n  }\n  return allMatchers;\n}\nfunction getMatches(matchers, placeHolderContent, options) {\n  var matches = [];\n  for (var _i4 = 0; _i4 < matchers.length; _i4++) {\n    var matcher = matchers[_i4];\n    var _matcher = _slicedToArray(matcher, 2),\n      prefix = _matcher[0],\n      _module2 = _matcher[1];\n    var properties = matcher[2] || {};\n    if (options.match(prefix, placeHolderContent)) {\n      var values = options.getValues(prefix, placeHolderContent);\n      if (typeof properties === \"function\") {\n        properties = properties(values);\n      }\n      if (!properties.value) {\n        var _values = _slicedToArray(values, 2);\n        properties.value = _values[1];\n      }\n      matches.push(_objectSpread({\n        type: \"placeholder\",\n        prefix: prefix,\n        module: _module2,\n        onMatch: properties.onMatch,\n        priority: properties.priority\n      }, properties));\n    }\n  }\n  return matches;\n}\nfunction moduleParse(placeHolderContent, options) {\n  var modules = options.modules,\n    startOffset = options.startOffset;\n  var endLindex = options.lIndex;\n  var moduleParsed;\n  options.offset = startOffset;\n  options.match = match;\n  options.getValue = getValue;\n  options.getValues = getValues;\n  var matchers = getMatchers(modules, options);\n  var matches = getMatches(matchers, placeHolderContent, options);\n  if (matches.length > 0) {\n    var bestMatch = null;\n    for (var _i6 = 0; _i6 < matches.length; _i6++) {\n      var _match = matches[_i6];\n      _match.priority || (_match.priority = -_match.value.length);\n      if (!bestMatch || _match.priority > bestMatch.priority) {\n        bestMatch = _match;\n      }\n    }\n    bestMatch.offset = startOffset;\n    delete bestMatch.priority;\n    bestMatch.endLindex = endLindex;\n    bestMatch.lIndex = endLindex;\n    bestMatch.raw = placeHolderContent;\n    if (bestMatch.onMatch) {\n      bestMatch.onMatch(bestMatch);\n    }\n    delete bestMatch.onMatch;\n    delete bestMatch.prefix;\n    return bestMatch;\n  }\n  for (var _i8 = 0; _i8 < modules.length; _i8++) {\n    var _module3 = modules[_i8];\n    moduleParsed = _module3.parse(placeHolderContent, options);\n    if (moduleParsed) {\n      moduleParsed.offset = startOffset;\n      moduleParsed.endLindex = endLindex;\n      moduleParsed.lIndex = endLindex;\n      moduleParsed.raw = placeHolderContent;\n      return moduleParsed;\n    }\n  }\n  return {\n    type: \"placeholder\",\n    value: placeHolderContent,\n    offset: startOffset,\n    endLindex: endLindex,\n    lIndex: endLindex\n  };\n}\nvar parser = {\n  preparse: function preparse(parsed, modules, options) {\n    function preparse(parsed, options) {\n      for (var _i0 = 0; _i0 < modules.length; _i0++) {\n        var _module4 = modules[_i0];\n        parsed = _module4.preparse(parsed, options) || parsed;\n      }\n      return parsed;\n    }\n    return preparse(parsed, options);\n  },\n  parse: function parse(lexed, modules, options) {\n    var inPlaceHolder = false;\n    var placeHolderContent = \"\";\n    var startOffset;\n    var tailParts = [];\n    var droppedTags = options.fileTypeConfig.droppedTagsInsidePlaceholder || [];\n    return lexed.reduce(function (parsed, token) {\n      if (token.type === \"delimiter\") {\n        inPlaceHolder = token.position === \"start\";\n        if (token.position === \"end\") {\n          options.parse = function (placeHolderContent) {\n            return moduleParse(placeHolderContent, _objectSpread(_objectSpread(_objectSpread({}, options), token), {}, {\n              startOffset: startOffset,\n              modules: modules\n            }));\n          };\n          parsed.push(options.parse(wordToUtf8(placeHolderContent)));\n          pushArray(parsed, tailParts);\n          tailParts = [];\n        }\n        if (token.position === \"start\") {\n          tailParts = [];\n          startOffset = token.offset;\n        }\n        placeHolderContent = \"\";\n        return parsed;\n      }\n      if (!inPlaceHolder) {\n        parsed.push(token);\n        return parsed;\n      }\n      if (token.type !== \"content\" || token.position !== \"insidetag\") {\n        if (droppedTags.indexOf(token.tag) !== -1) {\n          return parsed;\n        }\n        tailParts.push(token);\n        return parsed;\n      }\n      placeHolderContent += token.value;\n      return parsed;\n    }, []);\n  },\n  postparse: function postparse(postparsed, modules, options) {\n    function getTraits(traitName, postparsed, options) {\n      var result = [];\n      for (var _i10 = 0; _i10 < modules.length; _i10++) {\n        var _module5 = modules[_i10];\n        result.push(_module5.getTraits(traitName, postparsed, options));\n      }\n      return result;\n    }\n    var errors = [];\n    function _postparse(postparsed, options) {\n      var newPostparsed = postparsed;\n      for (var _i12 = 0; _i12 < modules.length; _i12++) {\n        var _module6 = modules[_i12];\n        var postparseResult = _module6.postparse(newPostparsed, _objectSpread(_objectSpread({}, options), {}, {\n          postparse: function postparse(parsed, opts) {\n            return _postparse(parsed, _objectSpread(_objectSpread({}, options), opts));\n          },\n          getTraits: getTraits\n        }));\n        if (postparseResult == null) {\n          continue;\n        }\n        if (postparseResult.errors) {\n          pushArray(errors, postparseResult.errors);\n          newPostparsed = postparseResult.postparsed;\n          continue;\n        }\n        newPostparsed = postparseResult;\n      }\n      return newPostparsed;\n    }\n    return {\n      postparsed: _postparse(postparsed, options),\n      errors: errors\n    };\n  }\n};\nmodule.exports = parser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5QixlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLHNCQUFzQjtBQUNySDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EsOEZBQThGLGNBQWM7QUFDNUc7QUFDQSxvRUFBb0U7QUFDcEUsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wYXJzZXIuanM/MzJiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHdvcmRUb1V0ZjggPSBfcmVxdWlyZS53b3JkVG9VdGY4LFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vcHJlZml4LW1hdGNoZXIuanNcIiksXG4gIG1hdGNoID0gX3JlcXVpcmUyLm1hdGNoLFxuICBnZXRWYWx1ZSA9IF9yZXF1aXJlMi5nZXRWYWx1ZSxcbiAgZ2V0VmFsdWVzID0gX3JlcXVpcmUyLmdldFZhbHVlcztcbmZ1bmN0aW9uIGdldE1hdGNoZXJzKG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgdmFyIGFsbE1hdGNoZXJzID0gW107XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG1vZHVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfbW9kdWxlID0gbW9kdWxlc1tfaTJdO1xuICAgIGlmIChfbW9kdWxlLm1hdGNoZXJzKSB7XG4gICAgICB2YXIgbWF0Y2hlcnMgPSBfbW9kdWxlLm1hdGNoZXJzKG9wdGlvbnMpO1xuICAgICAgaWYgKCEobWF0Y2hlcnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kdWxlIG1hdGNoZXIgcmV0dXJucyBhIG5vbiBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIHB1c2hBcnJheShhbGxNYXRjaGVycywgbWF0Y2hlcnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVzKG1hdGNoZXJzLCBwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbWF0Y2hlcnMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBtYXRjaGVyID0gbWF0Y2hlcnNbX2k0XTtcbiAgICB2YXIgX21hdGNoZXIgPSBfc2xpY2VkVG9BcnJheShtYXRjaGVyLCAyKSxcbiAgICAgIHByZWZpeCA9IF9tYXRjaGVyWzBdLFxuICAgICAgX21vZHVsZTIgPSBfbWF0Y2hlclsxXTtcbiAgICB2YXIgcHJvcGVydGllcyA9IG1hdGNoZXJbMl0gfHwge307XG4gICAgaWYgKG9wdGlvbnMubWF0Y2gocHJlZml4LCBwbGFjZUhvbGRlckNvbnRlbnQpKSB7XG4gICAgICB2YXIgdmFsdWVzID0gb3B0aW9ucy5nZXRWYWx1ZXMocHJlZml4LCBwbGFjZUhvbGRlckNvbnRlbnQpO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXModmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmICghcHJvcGVydGllcy52YWx1ZSkge1xuICAgICAgICB2YXIgX3ZhbHVlcyA9IF9zbGljZWRUb0FycmF5KHZhbHVlcywgMik7XG4gICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSBfdmFsdWVzWzFdO1xuICAgICAgfVxuICAgICAgbWF0Y2hlcy5wdXNoKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBtb2R1bGU6IF9tb2R1bGUyLFxuICAgICAgICBvbk1hdGNoOiBwcm9wZXJ0aWVzLm9uTWF0Y2gsXG4gICAgICAgIHByaW9yaXR5OiBwcm9wZXJ0aWVzLnByaW9yaXR5XG4gICAgICB9LCBwcm9wZXJ0aWVzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gbW9kdWxlUGFyc2UocGxhY2VIb2xkZXJDb250ZW50LCBvcHRpb25zKSB7XG4gIHZhciBtb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzLFxuICAgIHN0YXJ0T2Zmc2V0ID0gb3B0aW9ucy5zdGFydE9mZnNldDtcbiAgdmFyIGVuZExpbmRleCA9IG9wdGlvbnMubEluZGV4O1xuICB2YXIgbW9kdWxlUGFyc2VkO1xuICBvcHRpb25zLm9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICBvcHRpb25zLm1hdGNoID0gbWF0Y2g7XG4gIG9wdGlvbnMuZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcbiAgb3B0aW9ucy5nZXRWYWx1ZXMgPSBnZXRWYWx1ZXM7XG4gIHZhciBtYXRjaGVycyA9IGdldE1hdGNoZXJzKG1vZHVsZXMsIG9wdGlvbnMpO1xuICB2YXIgbWF0Y2hlcyA9IGdldE1hdGNoZXMobWF0Y2hlcnMsIHBsYWNlSG9sZGVyQ29udGVudCwgb3B0aW9ucyk7XG4gIGlmIChtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgYmVzdE1hdGNoID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBtYXRjaGVzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgIHZhciBfbWF0Y2ggPSBtYXRjaGVzW19pNl07XG4gICAgICBfbWF0Y2gucHJpb3JpdHkgfHwgKF9tYXRjaC5wcmlvcml0eSA9IC1fbWF0Y2gudmFsdWUubGVuZ3RoKTtcbiAgICAgIGlmICghYmVzdE1hdGNoIHx8IF9tYXRjaC5wcmlvcml0eSA+IGJlc3RNYXRjaC5wcmlvcml0eSkge1xuICAgICAgICBiZXN0TWF0Y2ggPSBfbWF0Y2g7XG4gICAgICB9XG4gICAgfVxuICAgIGJlc3RNYXRjaC5vZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICBkZWxldGUgYmVzdE1hdGNoLnByaW9yaXR5O1xuICAgIGJlc3RNYXRjaC5lbmRMaW5kZXggPSBlbmRMaW5kZXg7XG4gICAgYmVzdE1hdGNoLmxJbmRleCA9IGVuZExpbmRleDtcbiAgICBiZXN0TWF0Y2gucmF3ID0gcGxhY2VIb2xkZXJDb250ZW50O1xuICAgIGlmIChiZXN0TWF0Y2gub25NYXRjaCkge1xuICAgICAgYmVzdE1hdGNoLm9uTWF0Y2goYmVzdE1hdGNoKTtcbiAgICB9XG4gICAgZGVsZXRlIGJlc3RNYXRjaC5vbk1hdGNoO1xuICAgIGRlbGV0ZSBiZXN0TWF0Y2gucHJlZml4O1xuICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gIH1cbiAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbW9kdWxlcy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIF9tb2R1bGUzID0gbW9kdWxlc1tfaThdO1xuICAgIG1vZHVsZVBhcnNlZCA9IF9tb2R1bGUzLnBhcnNlKHBsYWNlSG9sZGVyQ29udGVudCwgb3B0aW9ucyk7XG4gICAgaWYgKG1vZHVsZVBhcnNlZCkge1xuICAgICAgbW9kdWxlUGFyc2VkLm9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgbW9kdWxlUGFyc2VkLmVuZExpbmRleCA9IGVuZExpbmRleDtcbiAgICAgIG1vZHVsZVBhcnNlZC5sSW5kZXggPSBlbmRMaW5kZXg7XG4gICAgICBtb2R1bGVQYXJzZWQucmF3ID0gcGxhY2VIb2xkZXJDb250ZW50O1xuICAgICAgcmV0dXJuIG1vZHVsZVBhcnNlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgdmFsdWU6IHBsYWNlSG9sZGVyQ29udGVudCxcbiAgICBvZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZExpbmRleDogZW5kTGluZGV4LFxuICAgIGxJbmRleDogZW5kTGluZGV4XG4gIH07XG59XG52YXIgcGFyc2VyID0ge1xuICBwcmVwYXJzZTogZnVuY3Rpb24gcHJlcGFyc2UocGFyc2VkLCBtb2R1bGVzLCBvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gcHJlcGFyc2UocGFyc2VkLCBvcHRpb25zKSB7XG4gICAgICBmb3IgKHZhciBfaTAgPSAwOyBfaTAgPCBtb2R1bGVzLmxlbmd0aDsgX2kwKyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU0ID0gbW9kdWxlc1tfaTBdO1xuICAgICAgICBwYXJzZWQgPSBfbW9kdWxlNC5wcmVwYXJzZShwYXJzZWQsIG9wdGlvbnMpIHx8IHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIHJldHVybiBwcmVwYXJzZShwYXJzZWQsIG9wdGlvbnMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UobGV4ZWQsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5QbGFjZUhvbGRlciA9IGZhbHNlO1xuICAgIHZhciBwbGFjZUhvbGRlckNvbnRlbnQgPSBcIlwiO1xuICAgIHZhciBzdGFydE9mZnNldDtcbiAgICB2YXIgdGFpbFBhcnRzID0gW107XG4gICAgdmFyIGRyb3BwZWRUYWdzID0gb3B0aW9ucy5maWxlVHlwZUNvbmZpZy5kcm9wcGVkVGFnc0luc2lkZVBsYWNlaG9sZGVyIHx8IFtdO1xuICAgIHJldHVybiBsZXhlZC5yZWR1Y2UoZnVuY3Rpb24gKHBhcnNlZCwgdG9rZW4pIHtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBcImRlbGltaXRlclwiKSB7XG4gICAgICAgIGluUGxhY2VIb2xkZXIgPSB0b2tlbi5wb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xuICAgICAgICBpZiAodG9rZW4ucG9zaXRpb24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICBvcHRpb25zLnBhcnNlID0gZnVuY3Rpb24gKHBsYWNlSG9sZGVyQ29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVBhcnNlKHBsYWNlSG9sZGVyQ29udGVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB0b2tlbiksIHt9LCB7XG4gICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgbW9kdWxlczogbW9kdWxlc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcGFyc2VkLnB1c2gob3B0aW9ucy5wYXJzZSh3b3JkVG9VdGY4KHBsYWNlSG9sZGVyQ29udGVudCkpKTtcbiAgICAgICAgICBwdXNoQXJyYXkocGFyc2VkLCB0YWlsUGFydHMpO1xuICAgICAgICAgIHRhaWxQYXJ0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5wb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgdGFpbFBhcnRzID0gW107XG4gICAgICAgICAgc3RhcnRPZmZzZXQgPSB0b2tlbi5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VIb2xkZXJDb250ZW50ID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGlmICghaW5QbGFjZUhvbGRlcikge1xuICAgICAgICBwYXJzZWQucHVzaCh0b2tlbik7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJjb250ZW50XCIgfHwgdG9rZW4ucG9zaXRpb24gIT09IFwiaW5zaWRldGFnXCIpIHtcbiAgICAgICAgaWYgKGRyb3BwZWRUYWdzLmluZGV4T2YodG9rZW4udGFnKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIHRhaWxQYXJ0cy5wdXNoKHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIHBsYWNlSG9sZGVyQ29udGVudCArPSB0b2tlbi52YWx1ZTtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSwgW10pO1xuICB9LFxuICBwb3N0cGFyc2U6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkLCBtb2R1bGVzLCBvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gZ2V0VHJhaXRzKHRyYWl0TmFtZSwgcG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBtb2R1bGVzLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlNSA9IG1vZHVsZXNbX2kxMF07XG4gICAgICAgIHJlc3VsdC5wdXNoKF9tb2R1bGU1LmdldFRyYWl0cyh0cmFpdE5hbWUsIHBvc3RwYXJzZWQsIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBmdW5jdGlvbiBfcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBuZXdQb3N0cGFyc2VkID0gcG9zdHBhcnNlZDtcbiAgICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbW9kdWxlcy5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgICB2YXIgX21vZHVsZTYgPSBtb2R1bGVzW19pMTJdO1xuICAgICAgICB2YXIgcG9zdHBhcnNlUmVzdWx0ID0gX21vZHVsZTYucG9zdHBhcnNlKG5ld1Bvc3RwYXJzZWQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgcG9zdHBhcnNlOiBmdW5jdGlvbiBwb3N0cGFyc2UocGFyc2VkLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Bvc3RwYXJzZShwYXJzZWQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIG9wdHMpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFRyYWl0czogZ2V0VHJhaXRzXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHBvc3RwYXJzZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc3RwYXJzZVJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICBwdXNoQXJyYXkoZXJyb3JzLCBwb3N0cGFyc2VSZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICBuZXdQb3N0cGFyc2VkID0gcG9zdHBhcnNlUmVzdWx0LnBvc3RwYXJzZWQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3UG9zdHBhcnNlZCA9IHBvc3RwYXJzZVJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdQb3N0cGFyc2VkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zdHBhcnNlZDogX3Bvc3RwYXJzZShwb3N0cGFyc2VkLCBvcHRpb25zKSxcbiAgICAgIGVycm9yczogZXJyb3JzXG4gICAgfTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/postrender.js":
/*!*****************************************************!*\
  !*** ./node_modules/docxtemplater/js/postrender.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n * Convert string to array (typed, when possible)\n * Stryker disable all : because this is a utility function that was copied\n * from\n * https://github.com/open-xml-templating/pizzip/blob/34a840553c604980859dc6d0dcd1f89b6e5527b3/es6/utf8.js#L33\n */\nfunction string2buf(str) {\n  var c,\n    c2,\n    mPos,\n    i,\n    bufLen = 0;\n  var strLen = str.length;\n\n  // count binary size\n  for (mPos = 0; mPos < strLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    bufLen += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  var buf = new Uint8Array(bufLen);\n\n  // convert\n  for (i = 0, mPos = 0; i < bufLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xc0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xe0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n  return buf;\n}\n// Stryker restore all\n\nfunction postrender(parts, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    parts = _module.postrender(parts, options);\n  }\n  var fullLength = 0;\n  var newParts = options.joinUncorrupt(parts, options);\n  var longStr = \"\";\n  var lenStr = 0;\n  var maxCompact = 65536;\n  var uintArrays = [];\n  for (var i = 0, len = newParts.length; i < len; i++) {\n    var part = newParts[i];\n\n    /*\n     * This condition should be hit in the integration test at :\n     * it(\"should not regress with long file (hit maxCompact value of 65536)\", function () {\n     * Stryker disable all : because this is an optimisation that won't make any tests fail\n     */\n    if (part.length + lenStr > maxCompact) {\n      var _arr = string2buf(longStr);\n      fullLength += _arr.length;\n      uintArrays.push(_arr);\n      longStr = \"\";\n    }\n    // Stryker restore all\n\n    longStr += part;\n    lenStr += part.length;\n    delete newParts[i];\n  }\n  var arr = string2buf(longStr);\n  fullLength += arr.length;\n  uintArrays.push(arr);\n  var array = new Uint8Array(fullLength);\n  var j = 0;\n\n  // Stryker disable all : because this is an optimisation that won't make any tests fail\n  for (var _i4 = 0; _i4 < uintArrays.length; _i4++) {\n    var buf = uintArrays[_i4];\n    for (var _i5 = 0; _i5 < buf.length; ++_i5) {\n      array[_i5 + j] = buf[_i5];\n    }\n    j += buf.length;\n  } // Stryker restore all\n  return array;\n}\nmodule.exports = postrender;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wb3N0cmVuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELGdDQUFnQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcG9zdHJlbmRlci5qcz9kMTI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICogQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuICogU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCB3YXMgY29waWVkXG4gKiBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi14bWwtdGVtcGxhdGluZy9waXp6aXAvYmxvYi8zNGE4NDA1NTNjNjA0OTgwODU5ZGM2ZDBkY2QxZjg5YjZlNTUyN2IzL2VzNi91dGY4LmpzI0wzM1xuICovXG5mdW5jdGlvbiBzdHJpbmcyYnVmKHN0cikge1xuICB2YXIgYyxcbiAgICBjMixcbiAgICBtUG9zLFxuICAgIGksXG4gICAgYnVmTGVuID0gMDtcbiAgdmFyIHN0ckxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtUG9zID0gMDsgbVBvcyA8IHN0ckxlbjsgbVBvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1Qb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiBtUG9zICsgMSA8IHN0ckxlbikge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtUG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKGMgLSAweGQ4MDAgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbVBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZMZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zkxlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtUG9zID0gMDsgaSA8IGJ1ZkxlbjsgbVBvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1Qb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiBtUG9zICsgMSA8IHN0ckxlbikge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtUG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKGMgLSAweGQ4MDAgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbVBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGMwIHwgYyA+Pj4gNjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZTAgfCBjID4+PiAxMjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgPj4+IDYgJiAweDNmO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IGMgPj4+IDE4O1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyA+Pj4gMTIgJiAweDNmO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyA+Pj4gNiAmIDB4M2Y7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbi8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcblxuZnVuY3Rpb24gcG9zdHJlbmRlcihwYXJ0cywgb3B0aW9ucykge1xuICBmb3IgKHZhciBfaTIgPSAwLCBfb3B0aW9ucyRtb2R1bGVzMiA9IG9wdGlvbnMubW9kdWxlczsgX2kyIDwgX29wdGlvbnMkbW9kdWxlczIubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfbW9kdWxlID0gX29wdGlvbnMkbW9kdWxlczJbX2kyXTtcbiAgICBwYXJ0cyA9IF9tb2R1bGUucG9zdHJlbmRlcihwYXJ0cywgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGZ1bGxMZW5ndGggPSAwO1xuICB2YXIgbmV3UGFydHMgPSBvcHRpb25zLmpvaW5VbmNvcnJ1cHQocGFydHMsIG9wdGlvbnMpO1xuICB2YXIgbG9uZ1N0ciA9IFwiXCI7XG4gIHZhciBsZW5TdHIgPSAwO1xuICB2YXIgbWF4Q29tcGFjdCA9IDY1NTM2O1xuICB2YXIgdWludEFycmF5cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbmV3UGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IG5ld1BhcnRzW2ldO1xuXG4gICAgLypcbiAgICAgKiBUaGlzIGNvbmRpdGlvbiBzaG91bGQgYmUgaGl0IGluIHRoZSBpbnRlZ3JhdGlvbiB0ZXN0IGF0IDpcbiAgICAgKiBpdChcInNob3VsZCBub3QgcmVncmVzcyB3aXRoIGxvbmcgZmlsZSAoaGl0IG1heENvbXBhY3QgdmFsdWUgb2YgNjU1MzYpXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgKiBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGFuIG9wdGltaXNhdGlvbiB0aGF0IHdvbid0IG1ha2UgYW55IHRlc3RzIGZhaWxcbiAgICAgKi9cbiAgICBpZiAocGFydC5sZW5ndGggKyBsZW5TdHIgPiBtYXhDb21wYWN0KSB7XG4gICAgICB2YXIgX2FyciA9IHN0cmluZzJidWYobG9uZ1N0cik7XG4gICAgICBmdWxsTGVuZ3RoICs9IF9hcnIubGVuZ3RoO1xuICAgICAgdWludEFycmF5cy5wdXNoKF9hcnIpO1xuICAgICAgbG9uZ1N0ciA9IFwiXCI7XG4gICAgfVxuICAgIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcblxuICAgIGxvbmdTdHIgKz0gcGFydDtcbiAgICBsZW5TdHIgKz0gcGFydC5sZW5ndGg7XG4gICAgZGVsZXRlIG5ld1BhcnRzW2ldO1xuICB9XG4gIHZhciBhcnIgPSBzdHJpbmcyYnVmKGxvbmdTdHIpO1xuICBmdWxsTGVuZ3RoICs9IGFyci5sZW5ndGg7XG4gIHVpbnRBcnJheXMucHVzaChhcnIpO1xuICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShmdWxsTGVuZ3RoKTtcbiAgdmFyIGogPSAwO1xuXG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIHRoYXQgd29uJ3QgbWFrZSBhbnkgdGVzdHMgZmFpbFxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCB1aW50QXJyYXlzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgYnVmID0gdWludEFycmF5c1tfaTRdO1xuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGJ1Zi5sZW5ndGg7ICsrX2k1KSB7XG4gICAgICBhcnJheVtfaTUgKyBqXSA9IGJ1ZltfaTVdO1xuICAgIH1cbiAgICBqICs9IGJ1Zi5sZW5ndGg7XG4gIH0gLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICByZXR1cm4gYXJyYXk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHBvc3RyZW5kZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/postrender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/prefix-matcher.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/prefix-matcher.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar nbspRegex = new RegExp(String.fromCharCode(160), \"g\");\nfunction replaceNbsps(str) {\n  return str.replace(nbspRegex, \" \");\n}\nfunction match(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return replaceNbsps(placeHolderContent.substr(0, condition.length)) === condition;\n  }\n  if (condition instanceof RegExp) {\n    return condition.test(replaceNbsps(placeHolderContent));\n  }\n  if (type === \"function\") {\n    return !!condition(placeHolderContent);\n  }\n}\nfunction getValue(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return replaceNbsps(placeHolderContent).substr(condition.length);\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition)[1];\n  }\n  if (type === \"function\") {\n    return condition(placeHolderContent);\n  }\n}\nfunction getValues(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return [placeHolderContent, replaceNbsps(placeHolderContent).substr(condition.length)];\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition);\n  }\n  if (type === \"function\") {\n    return [placeHolderContent, condition(placeHolderContent)];\n  }\n}\nmodule.exports = {\n  match: match,\n  getValue: getValue,\n  getValues: getValues\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wcmVmaXgtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rcmFiaS1vdXRhZ2UtdHJhY2tlci8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3ByZWZpeC1tYXRjaGVyLmpzPzk4M2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbnZhciBuYnNwUmVnZXggPSBuZXcgUmVnRXhwKFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSwgXCJnXCIpO1xuZnVuY3Rpb24gcmVwbGFjZU5ic3BzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmJzcFJlZ2V4LCBcIiBcIik7XG59XG5mdW5jdGlvbiBtYXRjaChjb25kaXRpb24sIHBsYWNlSG9sZGVyQ29udGVudCkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YoY29uZGl0aW9uKTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudC5zdWJzdHIoMCwgY29uZGl0aW9uLmxlbmd0aCkpID09PSBjb25kaXRpb247XG4gIH1cbiAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBjb25kaXRpb24udGVzdChyZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiAhIWNvbmRpdGlvbihwbGFjZUhvbGRlckNvbnRlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShjb25kaXRpb24sIHBsYWNlSG9sZGVyQ29udGVudCkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YoY29uZGl0aW9uKTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkuc3Vic3RyKGNvbmRpdGlvbi5sZW5ndGgpO1xuICB9XG4gIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkubWF0Y2goY29uZGl0aW9uKVsxXTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbihwbGFjZUhvbGRlckNvbnRlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZXMoY29uZGl0aW9uLCBwbGFjZUhvbGRlckNvbnRlbnQpIHtcbiAgdmFyIHR5cGUgPSBfdHlwZW9mKGNvbmRpdGlvbik7XG4gIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtwbGFjZUhvbGRlckNvbnRlbnQsIHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQpLnN1YnN0cihjb25kaXRpb24ubGVuZ3RoKV07XG4gIH1cbiAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KS5tYXRjaChjb25kaXRpb24pO1xuICB9XG4gIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gW3BsYWNlSG9sZGVyQ29udGVudCwgY29uZGl0aW9uKHBsYWNlSG9sZGVyQ29udGVudCldO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF0Y2g6IG1hdGNoLFxuICBnZXRWYWx1ZTogZ2V0VmFsdWUsXG4gIGdldFZhbHVlczogZ2V0VmFsdWVzXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/prefix-matcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/render.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/render.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  throwUnimplementedTagType = _require.throwUnimplementedTagType,\n  XTScopeParserError = _require.XTScopeParserError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require2.pushArray;\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(rsc)/./node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleRender(part, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    var moduleRendered = _module.render(part, options);\n    if (moduleRendered) {\n      return moduleRendered;\n    }\n  }\n  return false;\n}\nfunction render(options) {\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n    scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  var errors = [];\n  var parts = [];\n  for (var i = 0, len = compiled.length; i < len; i++) {\n    var part = compiled[i];\n    options.index = i;\n    options.resolvedId = getResolvedId(part, options);\n    var moduleRendered = void 0;\n    try {\n      moduleRendered = moduleRender(part, options);\n    } catch (e) {\n      if (e instanceof XTScopeParserError) {\n        errors.push(e);\n        parts.push(part);\n        continue;\n      }\n      throw e;\n    }\n    if (moduleRendered) {\n      if (moduleRendered.errors) {\n        pushArray(errors, moduleRendered.errors);\n      }\n      parts.push(moduleRendered);\n      continue;\n    }\n    if (part.type === \"content\" || part.type === \"tag\") {\n      parts.push(part);\n      continue;\n    }\n    throwUnimplementedTagType(part, i);\n  }\n\n  // This is done in two steps because for some files, it is possible to #edit-value-backwards\n  var totalParts = [];\n  for (var _i4 = 0; _i4 < parts.length; _i4++) {\n    var value = parts[_i4].value;\n    if (value instanceof Array) {\n      pushArray(totalParts, value);\n    } else if (value) {\n      totalParts.push(value);\n    }\n  }\n  return {\n    errors: errors,\n    parts: totalParts\n  };\n}\nmodule.exports = render;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9FQUFhO0FBQ3BDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDeEM7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDbEQ7QUFDQSx5REFBeUQsZ0NBQWdDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZW5kZXIuanM/YTcwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlID0gX3JlcXVpcmUudGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZSxcbiAgWFRTY29wZVBhcnNlckVycm9yID0gX3JlcXVpcmUuWFRTY29wZVBhcnNlckVycm9yO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUyLnB1c2hBcnJheTtcbnZhciBnZXRSZXNvbHZlZElkID0gcmVxdWlyZShcIi4vZ2V0LXJlc29sdmVkLWlkLmpzXCIpO1xuZnVuY3Rpb24gbW9kdWxlUmVuZGVyKHBhcnQsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgX2kyID0gMCwgX29wdGlvbnMkbW9kdWxlczIgPSBvcHRpb25zLm1vZHVsZXM7IF9pMiA8IF9vcHRpb25zJG1vZHVsZXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX21vZHVsZSA9IF9vcHRpb25zJG1vZHVsZXMyW19pMl07XG4gICAgdmFyIG1vZHVsZVJlbmRlcmVkID0gX21vZHVsZS5yZW5kZXIocGFydCwgb3B0aW9ucyk7XG4gICAgaWYgKG1vZHVsZVJlbmRlcmVkKSB7XG4gICAgICByZXR1cm4gbW9kdWxlUmVuZGVyZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihvcHRpb25zKSB7XG4gIHZhciBiYXNlTnVsbEdldHRlciA9IG9wdGlvbnMuYmFzZU51bGxHZXR0ZXI7XG4gIHZhciBjb21waWxlZCA9IG9wdGlvbnMuY29tcGlsZWQsXG4gICAgc2NvcGVNYW5hZ2VyID0gb3B0aW9ucy5zY29wZU1hbmFnZXI7XG4gIG9wdGlvbnMubnVsbEdldHRlciA9IGZ1bmN0aW9uIChwYXJ0LCBzbSkge1xuICAgIHJldHVybiBiYXNlTnVsbEdldHRlcihwYXJ0LCBzbSB8fCBzY29wZU1hbmFnZXIpO1xuICB9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBwYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcGlsZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IGNvbXBpbGVkW2ldO1xuICAgIG9wdGlvbnMuaW5kZXggPSBpO1xuICAgIG9wdGlvbnMucmVzb2x2ZWRJZCA9IGdldFJlc29sdmVkSWQocGFydCwgb3B0aW9ucyk7XG4gICAgdmFyIG1vZHVsZVJlbmRlcmVkID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICBtb2R1bGVSZW5kZXJlZCA9IG1vZHVsZVJlbmRlcihwYXJ0LCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFhUU2NvcGVQYXJzZXJFcnJvcikge1xuICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlUmVuZGVyZWQpIHtcbiAgICAgIGlmIChtb2R1bGVSZW5kZXJlZC5lcnJvcnMpIHtcbiAgICAgICAgcHVzaEFycmF5KGVycm9ycywgbW9kdWxlUmVuZGVyZWQuZXJyb3JzKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gobW9kdWxlUmVuZGVyZWQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiY29udGVudFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0YWdcIikge1xuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlKHBhcnQsIGkpO1xuICB9XG5cbiAgLy8gVGhpcyBpcyBkb25lIGluIHR3byBzdGVwcyBiZWNhdXNlIGZvciBzb21lIGZpbGVzLCBpdCBpcyBwb3NzaWJsZSB0byAjZWRpdC12YWx1ZS1iYWNrd2FyZHNcbiAgdmFyIHRvdGFsUGFydHMgPSBbXTtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgcGFydHMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciB2YWx1ZSA9IHBhcnRzW19pNF0udmFsdWU7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHB1c2hBcnJheSh0b3RhbFBhcnRzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdG90YWxQYXJ0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlcnJvcnM6IGVycm9ycyxcbiAgICBwYXJ0czogdG90YWxQYXJ0c1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/render.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/resolve.js":
/*!**************************************************!*\
  !*** ./node_modules/docxtemplater/js/resolve.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray;\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(rsc)/./node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleResolve(part, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    var moduleResolved = _module.resolve(part, options);\n    if (moduleResolved) {\n      return moduleResolved;\n    }\n  }\n  return false;\n}\nfunction resolvePart(part, resolved, errors, options) {\n  var moduleResolved = moduleResolve(part, _objectSpread(_objectSpread({}, options), {}, {\n    resolvedId: getResolvedId(part, options)\n  }));\n  if (moduleResolved) {\n    return moduleResolved.then(function (value) {\n      resolved.push({\n        tag: part.value,\n        lIndex: part.lIndex,\n        value: value\n      });\n    })[\"catch\"](function (e) {\n      if (e instanceof Array) {\n        pushArray(errors, e);\n      } else {\n        errors.push(e);\n      }\n    });\n  }\n  if (part.type === \"placeholder\") {\n    return options.scopeManager.getValueAsync(part.value, {\n      part: part\n    }).then(function (value) {\n      return value == null ? options.nullGetter(part) : value;\n    }).then(function (value) {\n      resolved.push({\n        tag: part.value,\n        lIndex: part.lIndex,\n        value: value\n      });\n    })[\"catch\"](function (e) {\n      if (e instanceof Array) {\n        pushArray(errors, e);\n      } else {\n        errors.push(e);\n      }\n    });\n  }\n}\nfunction resolve(options) {\n  var resolved = [];\n  var errors = [];\n  var baseNullGetter = options.baseNullGetter;\n  var scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  options.resolved = resolved;\n  var p = resolveSerial(options, errors, resolved);\n  if (p) {\n    return p.then(function () {\n      return resolveParallel(options, errors, resolved);\n    });\n  }\n  return resolveParallel(options, errors, resolved);\n}\nfunction resolveSerial(options, errors, resolved) {\n  var p = null;\n  var _loop = function _loop() {\n    var part = _options$compiled2[_i4];\n    if ([\"content\", \"tag\"].indexOf(part.type) !== -1) {\n      return 1; // continue\n    }\n    if (part.resolveFirst) {\n      p !== null && p !== void 0 ? p : p = Promise.resolve(null);\n      p = p.then(function () {\n        return resolvePart(part, resolved, errors, options);\n      });\n    }\n  };\n  for (var _i4 = 0, _options$compiled2 = options.compiled; _i4 < _options$compiled2.length; _i4++) {\n    if (_loop()) continue;\n  }\n  return p;\n}\nfunction resolveParallel(options, errors, resolved) {\n  var promises = [];\n  for (var _i6 = 0, _options$compiled4 = options.compiled; _i6 < _options$compiled4.length; _i6++) {\n    var part = _options$compiled4[_i6];\n    if ([\"content\", \"tag\"].indexOf(part.type) !== -1) {\n      continue;\n    }\n    if (!part.resolveFirst) {\n      promises.push(resolvePart(part, resolved, errors, options));\n    }\n  }\n  return Promise.all(promises).then(function () {\n    return {\n      errors: errors,\n      resolved: resolved\n    };\n  });\n}\nmodule.exports = resolve;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZXNvbHZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ2xEO0FBQ0EseURBQXlELGdDQUFnQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsY0FBYztBQUN2RjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJEQUEyRCxpQ0FBaUM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGlDQUFpQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZXNvbHZlLmpzP2JlOTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgZ2V0UmVzb2x2ZWRJZCA9IHJlcXVpcmUoXCIuL2dldC1yZXNvbHZlZC1pZC5qc1wiKTtcbmZ1bmN0aW9uIG1vZHVsZVJlc29sdmUocGFydCwgb3B0aW9ucykge1xuICBmb3IgKHZhciBfaTIgPSAwLCBfb3B0aW9ucyRtb2R1bGVzMiA9IG9wdGlvbnMubW9kdWxlczsgX2kyIDwgX29wdGlvbnMkbW9kdWxlczIubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfbW9kdWxlID0gX29wdGlvbnMkbW9kdWxlczJbX2kyXTtcbiAgICB2YXIgbW9kdWxlUmVzb2x2ZWQgPSBfbW9kdWxlLnJlc29sdmUocGFydCwgb3B0aW9ucyk7XG4gICAgaWYgKG1vZHVsZVJlc29sdmVkKSB7XG4gICAgICByZXR1cm4gbW9kdWxlUmVzb2x2ZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXJ0KHBhcnQsIHJlc29sdmVkLCBlcnJvcnMsIG9wdGlvbnMpIHtcbiAgdmFyIG1vZHVsZVJlc29sdmVkID0gbW9kdWxlUmVzb2x2ZShwYXJ0LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgIHJlc29sdmVkSWQ6IGdldFJlc29sdmVkSWQocGFydCwgb3B0aW9ucylcbiAgfSkpO1xuICBpZiAobW9kdWxlUmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gbW9kdWxlUmVzb2x2ZWQudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJlc29sdmVkLnB1c2goe1xuICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgIGxJbmRleDogcGFydC5sSW5kZXgsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBwdXNoQXJyYXkoZXJyb3JzLCBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmIChwYXJ0LnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIikge1xuICAgIHJldHVybiBvcHRpb25zLnNjb3BlTWFuYWdlci5nZXRWYWx1ZUFzeW5jKHBhcnQudmFsdWUsIHtcbiAgICAgIHBhcnQ6IHBhcnRcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBvcHRpb25zLm51bGxHZXR0ZXIocGFydCkgOiB2YWx1ZTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZWQucHVzaCh7XG4gICAgICAgIHRhZzogcGFydC52YWx1ZSxcbiAgICAgICAgbEluZGV4OiBwYXJ0LmxJbmRleCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHB1c2hBcnJheShlcnJvcnMsIGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmUob3B0aW9ucykge1xuICB2YXIgcmVzb2x2ZWQgPSBbXTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgYmFzZU51bGxHZXR0ZXIgPSBvcHRpb25zLmJhc2VOdWxsR2V0dGVyO1xuICB2YXIgc2NvcGVNYW5hZ2VyID0gb3B0aW9ucy5zY29wZU1hbmFnZXI7XG4gIG9wdGlvbnMubnVsbEdldHRlciA9IGZ1bmN0aW9uIChwYXJ0LCBzbSkge1xuICAgIHJldHVybiBiYXNlTnVsbEdldHRlcihwYXJ0LCBzbSB8fCBzY29wZU1hbmFnZXIpO1xuICB9O1xuICBvcHRpb25zLnJlc29sdmVkID0gcmVzb2x2ZWQ7XG4gIHZhciBwID0gcmVzb2x2ZVNlcmlhbChvcHRpb25zLCBlcnJvcnMsIHJlc29sdmVkKTtcbiAgaWYgKHApIHtcbiAgICByZXR1cm4gcC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlUGFyYWxsZWwob3B0aW9ucywgZXJyb3JzLCByZXNvbHZlZCk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVQYXJhbGxlbChvcHRpb25zLCBlcnJvcnMsIHJlc29sdmVkKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTZXJpYWwob3B0aW9ucywgZXJyb3JzLCByZXNvbHZlZCkge1xuICB2YXIgcCA9IG51bGw7XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBwYXJ0ID0gX29wdGlvbnMkY29tcGlsZWQyW19pNF07XG4gICAgaWYgKFtcImNvbnRlbnRcIiwgXCJ0YWdcIl0uaW5kZXhPZihwYXJ0LnR5cGUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIDE7IC8vIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChwYXJ0LnJlc29sdmVGaXJzdCkge1xuICAgICAgcCAhPT0gbnVsbCAmJiBwICE9PSB2b2lkIDAgPyBwIDogcCA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVBhcnQocGFydCwgcmVzb2x2ZWQsIGVycm9ycywgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIF9pNCA9IDAsIF9vcHRpb25zJGNvbXBpbGVkMiA9IG9wdGlvbnMuY29tcGlsZWQ7IF9pNCA8IF9vcHRpb25zJGNvbXBpbGVkMi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgaWYgKF9sb29wKCkpIGNvbnRpbnVlO1xuICB9XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhcmFsbGVsKG9wdGlvbnMsIGVycm9ycywgcmVzb2x2ZWQpIHtcbiAgdmFyIHByb21pc2VzID0gW107XG4gIGZvciAodmFyIF9pNiA9IDAsIF9vcHRpb25zJGNvbXBpbGVkNCA9IG9wdGlvbnMuY29tcGlsZWQ7IF9pNiA8IF9vcHRpb25zJGNvbXBpbGVkNC5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIHBhcnQgPSBfb3B0aW9ucyRjb21waWxlZDRbX2k2XTtcbiAgICBpZiAoW1wiY29udGVudFwiLCBcInRhZ1wiXS5pbmRleE9mKHBhcnQudHlwZSkgIT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFwYXJ0LnJlc29sdmVGaXJzdCkge1xuICAgICAgcHJvbWlzZXMucHVzaChyZXNvbHZlUGFydChwYXJ0LCByZXNvbHZlZCwgZXJyb3JzLCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgcmVzb2x2ZWQ6IHJlc29sdmVkXG4gICAgfTtcbiAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/resolve.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/scope-manager.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/scope-manager.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  getScopeParserExecutionError = _require.getScopeParserExecutionError;\nvar _require2 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/docxtemplater/js/utils.js\"),\n  last = _require2.last;\nvar _require3 = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  concatArrays = _require3.concatArrays;\nfunction find(list, fn) {\n  var length = list.length >>> 0;\n  var value;\n  for (var i = 0; i < length; i++) {\n    value = list[i];\n    if (fn.call(this, value, i, list)) {\n      return value;\n    }\n  }\n  return undefined;\n}\nfunction _getValue(tag, meta, num) {\n  var _this = this;\n  var scope = this.scopeList[num];\n  if (this.root.finishedResolving) {\n    var w = this.resolved;\n    var _loop = function _loop() {\n      var lIndex = _this.scopeLindex[i];\n      w = find(w, function (r) {\n        return r.lIndex === lIndex;\n      });\n      w = w.value[_this.scopePathItem[i]];\n    };\n    for (var i = this.resolveOffset, len = this.scopePath.length; i < len; i++) {\n      _loop();\n    }\n    return find(w, function (r) {\n      return meta.part.lIndex === r.lIndex;\n    }).value;\n  }\n  // search in the scopes (in reverse order) and keep the first defined value\n  var result;\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  }\n  try {\n    result = parser.get(scope, this.getContext(meta, num));\n  } catch (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }\n  if (result == null && num > 0) {\n    return _getValue.call(this, tag, meta, num - 1);\n  }\n  return result;\n}\nfunction _getValueAsync(tag, meta, num) {\n  var _this2 = this;\n  var scope = this.scopeList[num];\n  // search in the scopes (in reverse order) and keep the first defined value\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  }\n  return Promise.resolve().then(function () {\n    return parser.get(scope, _this2.getContext(meta, num));\n  })[\"catch\"](function (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }).then(function (result) {\n    if (result == null && num > 0) {\n      return _getValueAsync.call(_this2, tag, meta, num - 1);\n    }\n    return result;\n  });\n}\nvar ScopeManager = /*#__PURE__*/function () {\n  function ScopeManager(options) {\n    _classCallCheck(this, ScopeManager);\n    this.root = options.root || this;\n    this.resolveOffset = options.resolveOffset || 0;\n    this.scopePath = options.scopePath;\n    this.scopePathItem = options.scopePathItem;\n    this.scopePathLength = options.scopePathLength;\n    this.scopeList = options.scopeList;\n    this.scopeType = \"\";\n    this.scopeTypes = options.scopeTypes;\n    this.scopeLindex = options.scopeLindex;\n    this.parser = options.parser;\n    this.resolved = options.resolved;\n    this.cachedParsers = options.cachedParsers;\n  }\n  return _createClass(ScopeManager, [{\n    key: \"loopOver\",\n    value: function loopOver(tag, functor, inverted, meta) {\n      return this.loopOverValue(this.getValue(tag, meta), functor, inverted);\n    }\n  }, {\n    key: \"functorIfInverted\",\n    value: function functorIfInverted(inverted, functor, value, i, length) {\n      if (inverted) {\n        functor(value, i, length);\n      }\n      return inverted;\n    }\n  }, {\n    key: \"isValueFalsy\",\n    value: function isValueFalsy(value, type) {\n      return value == null || !value || type === \"[object Array]\" && value.length === 0;\n    }\n  }, {\n    key: \"loopOverValue\",\n    value: function loopOverValue(value, functor, inverted) {\n      if (this.root.finishedResolving) {\n        inverted = false;\n      }\n      var type = Object.prototype.toString.call(value);\n      if (this.isValueFalsy(value, type)) {\n        this.scopeType = false;\n        return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);\n      }\n      if (type === \"[object Array]\") {\n        this.scopeType = \"array\";\n        for (var i = 0; i < value.length; i++) {\n          this.functorIfInverted(!inverted, functor, value[i], i, value.length);\n        }\n        return true;\n      }\n      if (type === \"[object Object]\") {\n        this.scopeType = \"object\";\n        return this.functorIfInverted(!inverted, functor, value, 0, 1);\n      }\n      return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(tag, meta) {\n      var result = _getValue.call(this, tag, meta, this.scopeList.length - 1);\n      if (typeof result === \"function\") {\n        return result(this.scopeList[this.scopeList.length - 1], this);\n      }\n      return result;\n    }\n  }, {\n    key: \"getValueAsync\",\n    value: function getValueAsync(tag, meta) {\n      var _this3 = this;\n      return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1).then(function (result) {\n        if (typeof result === \"function\") {\n          return result(_this3.scopeList[_this3.scopeList.length - 1], _this3);\n        }\n        return result;\n      });\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(meta, num) {\n      return {\n        num: num,\n        meta: meta,\n        scopeList: this.scopeList,\n        resolved: this.resolved,\n        scopePath: this.scopePath,\n        scopeTypes: this.scopeTypes,\n        scopePathItem: this.scopePathItem,\n        scopePathLength: this.scopePathLength\n      };\n    }\n  }, {\n    key: \"createSubScopeManager\",\n    value: function createSubScopeManager(scope, tag, i, part, length) {\n      return new ScopeManager({\n        root: this.root,\n        resolveOffset: this.resolveOffset,\n        resolved: this.resolved,\n        parser: this.parser,\n        cachedParsers: this.cachedParsers,\n        scopeTypes: concatArrays([this.scopeTypes, [this.scopeType]]),\n        scopeList: concatArrays([this.scopeList, [scope]]),\n        scopePath: concatArrays([this.scopePath, [tag]]),\n        scopePathItem: concatArrays([this.scopePathItem, [i]]),\n        scopePathLength: concatArrays([this.scopePathLength, [length]]),\n        scopeLindex: concatArrays([this.scopeLindex, [part.lIndex]])\n      });\n    }\n  }]);\n}();\nmodule.exports = function (options) {\n  options.scopePath = [];\n  options.scopePathItem = [];\n  options.scopePathLength = [];\n  options.scopeTypes = [];\n  options.scopeLindex = [];\n  options.scopeList = [options.tags];\n  return new ScopeManager(options);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9zY29wZS1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBWTtBQUNwQztBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrRUFBa0UsU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvc2NvcGUtbWFuYWdlci5qcz82ODJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIiksXG4gIGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3IgPSBfcmVxdWlyZS5nZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLFxuICBsYXN0ID0gX3JlcXVpcmUyLmxhc3Q7XG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBjb25jYXRBcnJheXMgPSBfcmVxdWlyZTMuY29uY2F0QXJyYXlzO1xuZnVuY3Rpb24gZmluZChsaXN0LCBmbikge1xuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gIHZhciB2YWx1ZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICBpZiAoZm4uY2FsbCh0aGlzLCB2YWx1ZSwgaSwgbGlzdCkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIF9nZXRWYWx1ZSh0YWcsIG1ldGEsIG51bSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlTGlzdFtudW1dO1xuICBpZiAodGhpcy5yb290LmZpbmlzaGVkUmVzb2x2aW5nKSB7XG4gICAgdmFyIHcgPSB0aGlzLnJlc29sdmVkO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIGxJbmRleCA9IF90aGlzLnNjb3BlTGluZGV4W2ldO1xuICAgICAgdyA9IGZpbmQodywgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHIubEluZGV4ID09PSBsSW5kZXg7XG4gICAgICB9KTtcbiAgICAgIHcgPSB3LnZhbHVlW190aGlzLnNjb3BlUGF0aEl0ZW1baV1dO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IHRoaXMucmVzb2x2ZU9mZnNldCwgbGVuID0gdGhpcy5zY29wZVBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuICAgIHJldHVybiBmaW5kKHcsIGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gbWV0YS5wYXJ0LmxJbmRleCA9PT0gci5sSW5kZXg7XG4gICAgfSkudmFsdWU7XG4gIH1cbiAgLy8gc2VhcmNoIGluIHRoZSBzY29wZXMgKGluIHJldmVyc2Ugb3JkZXIpIGFuZCBrZWVwIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlXG4gIHZhciByZXN1bHQ7XG4gIHZhciBwYXJzZXI7XG4gIGlmICghdGhpcy5jYWNoZWRQYXJzZXJzIHx8ICFtZXRhLnBhcnQpIHtcbiAgICBwYXJzZXIgPSB0aGlzLnBhcnNlcih0YWcsIHtcbiAgICAgIHRhZzogbWV0YS5wYXJ0LFxuICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XSkge1xuICAgIHBhcnNlciA9IHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0gPSB0aGlzLnBhcnNlcih0YWcsIHtcbiAgICAgIHRhZzogbWV0YS5wYXJ0LFxuICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aFxuICAgIH0pO1xuICB9XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gcGFyc2VyLmdldChzY29wZSwgdGhpcy5nZXRDb250ZXh0KG1ldGEsIG51bSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgdGFnOiB0YWcsXG4gICAgICBzY29wZTogc2NvcGUsXG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBvZmZzZXQ6IG1ldGEucGFydC5vZmZzZXRcbiAgICB9KTtcbiAgfVxuICBpZiAocmVzdWx0ID09IG51bGwgJiYgbnVtID4gMCkge1xuICAgIHJldHVybiBfZ2V0VmFsdWUuY2FsbCh0aGlzLCB0YWcsIG1ldGEsIG51bSAtIDEpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZ2V0VmFsdWVBc3luYyh0YWcsIG1ldGEsIG51bSkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcbiAgdmFyIHNjb3BlID0gdGhpcy5zY29wZUxpc3RbbnVtXTtcbiAgLy8gc2VhcmNoIGluIHRoZSBzY29wZXMgKGluIHJldmVyc2Ugb3JkZXIpIGFuZCBrZWVwIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlXG4gIHZhciBwYXJzZXI7XG4gIGlmICghdGhpcy5jYWNoZWRQYXJzZXJzIHx8ICFtZXRhLnBhcnQpIHtcbiAgICBwYXJzZXIgPSB0aGlzLnBhcnNlcih0YWcsIHtcbiAgICAgIHRhZzogbWV0YS5wYXJ0LFxuICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XSkge1xuICAgIHBhcnNlciA9IHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0gPSB0aGlzLnBhcnNlcih0YWcsIHtcbiAgICAgIHRhZzogbWV0YS5wYXJ0LFxuICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VyLmdldChzY29wZSwgX3RoaXMyLmdldENvbnRleHQobWV0YSwgbnVtKSk7XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdGhyb3cgZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcih7XG4gICAgICB0YWc6IHRhZyxcbiAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIG9mZnNldDogbWV0YS5wYXJ0Lm9mZnNldFxuICAgIH0pO1xuICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgbnVtID4gMCkge1xuICAgICAgcmV0dXJuIF9nZXRWYWx1ZUFzeW5jLmNhbGwoX3RoaXMyLCB0YWcsIG1ldGEsIG51bSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cbnZhciBTY29wZU1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY29wZU1hbmFnZXIob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY29wZU1hbmFnZXIpO1xuICAgIHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdCB8fCB0aGlzO1xuICAgIHRoaXMucmVzb2x2ZU9mZnNldCA9IG9wdGlvbnMucmVzb2x2ZU9mZnNldCB8fCAwO1xuICAgIHRoaXMuc2NvcGVQYXRoID0gb3B0aW9ucy5zY29wZVBhdGg7XG4gICAgdGhpcy5zY29wZVBhdGhJdGVtID0gb3B0aW9ucy5zY29wZVBhdGhJdGVtO1xuICAgIHRoaXMuc2NvcGVQYXRoTGVuZ3RoID0gb3B0aW9ucy5zY29wZVBhdGhMZW5ndGg7XG4gICAgdGhpcy5zY29wZUxpc3QgPSBvcHRpb25zLnNjb3BlTGlzdDtcbiAgICB0aGlzLnNjb3BlVHlwZSA9IFwiXCI7XG4gICAgdGhpcy5zY29wZVR5cGVzID0gb3B0aW9ucy5zY29wZVR5cGVzO1xuICAgIHRoaXMuc2NvcGVMaW5kZXggPSBvcHRpb25zLnNjb3BlTGluZGV4O1xuICAgIHRoaXMucGFyc2VyID0gb3B0aW9ucy5wYXJzZXI7XG4gICAgdGhpcy5yZXNvbHZlZCA9IG9wdGlvbnMucmVzb2x2ZWQ7XG4gICAgdGhpcy5jYWNoZWRQYXJzZXJzID0gb3B0aW9ucy5jYWNoZWRQYXJzZXJzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoU2NvcGVNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJsb29wT3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb29wT3Zlcih0YWcsIGZ1bmN0b3IsIGludmVydGVkLCBtZXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb29wT3ZlclZhbHVlKHRoaXMuZ2V0VmFsdWUodGFnLCBtZXRhKSwgZnVuY3RvciwgaW52ZXJ0ZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmdW5jdG9ySWZJbnZlcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmdW5jdG9ySWZJbnZlcnRlZChpbnZlcnRlZCwgZnVuY3RvciwgdmFsdWUsIGksIGxlbmd0aCkge1xuICAgICAgaWYgKGludmVydGVkKSB7XG4gICAgICAgIGZ1bmN0b3IodmFsdWUsIGksIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW52ZXJ0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsdWVGYWxzeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbHVlRmFsc3kodmFsdWUsIHR5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8ICF2YWx1ZSB8fCB0eXBlID09PSBcIltvYmplY3QgQXJyYXldXCIgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb29wT3ZlclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvb3BPdmVyVmFsdWUodmFsdWUsIGZ1bmN0b3IsIGludmVydGVkKSB7XG4gICAgICBpZiAodGhpcy5yb290LmZpbmlzaGVkUmVzb2x2aW5nKSB7XG4gICAgICAgIGludmVydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAodGhpcy5pc1ZhbHVlRmFsc3kodmFsdWUsIHR5cGUpKSB7XG4gICAgICAgIHRoaXMuc2NvcGVUeXBlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0b3JJZkludmVydGVkKGludmVydGVkLCBmdW5jdG9yLCBsYXN0KHRoaXMuc2NvcGVMaXN0KSwgMCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIHRoaXMuc2NvcGVUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5mdW5jdG9ySWZJbnZlcnRlZCghaW52ZXJ0ZWQsIGZ1bmN0b3IsIHZhbHVlW2ldLCBpLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgdGhpcy5zY29wZVR5cGUgPSBcIm9iamVjdFwiO1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdG9ySWZJbnZlcnRlZCghaW52ZXJ0ZWQsIGZ1bmN0b3IsIHZhbHVlLCAwLCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZ1bmN0b3JJZkludmVydGVkKCFpbnZlcnRlZCwgZnVuY3RvciwgbGFzdCh0aGlzLnNjb3BlTGlzdCksIDAsIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSh0YWcsIG1ldGEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBfZ2V0VmFsdWUuY2FsbCh0aGlzLCB0YWcsIG1ldGEsIHRoaXMuc2NvcGVMaXN0Lmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMuc2NvcGVMaXN0W3RoaXMuc2NvcGVMaXN0Lmxlbmd0aCAtIDFdLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlQXN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVBc3luYyh0YWcsIG1ldGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgcmV0dXJuIF9nZXRWYWx1ZUFzeW5jLmNhbGwodGhpcywgdGFnLCBtZXRhLCB0aGlzLnNjb3BlTGlzdC5sZW5ndGggLSAxKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQoX3RoaXMzLnNjb3BlTGlzdFtfdGhpczMuc2NvcGVMaXN0Lmxlbmd0aCAtIDFdLCBfdGhpczMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZXh0KG1ldGEsIG51bSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbnVtOiBudW0sXG4gICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgIHNjb3BlTGlzdDogdGhpcy5zY29wZUxpc3QsXG4gICAgICAgIHJlc29sdmVkOiB0aGlzLnJlc29sdmVkLFxuICAgICAgICBzY29wZVBhdGg6IHRoaXMuc2NvcGVQYXRoLFxuICAgICAgICBzY29wZVR5cGVzOiB0aGlzLnNjb3BlVHlwZXMsXG4gICAgICAgIHNjb3BlUGF0aEl0ZW06IHRoaXMuc2NvcGVQYXRoSXRlbSxcbiAgICAgICAgc2NvcGVQYXRoTGVuZ3RoOiB0aGlzLnNjb3BlUGF0aExlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlU3ViU2NvcGVNYW5hZ2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVN1YlNjb3BlTWFuYWdlcihzY29wZSwgdGFnLCBpLCBwYXJ0LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgU2NvcGVNYW5hZ2VyKHtcbiAgICAgICAgcm9vdDogdGhpcy5yb290LFxuICAgICAgICByZXNvbHZlT2Zmc2V0OiB0aGlzLnJlc29sdmVPZmZzZXQsXG4gICAgICAgIHJlc29sdmVkOiB0aGlzLnJlc29sdmVkLFxuICAgICAgICBwYXJzZXI6IHRoaXMucGFyc2VyLFxuICAgICAgICBjYWNoZWRQYXJzZXJzOiB0aGlzLmNhY2hlZFBhcnNlcnMsXG4gICAgICAgIHNjb3BlVHlwZXM6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZVR5cGVzLCBbdGhpcy5zY29wZVR5cGVdXSksXG4gICAgICAgIHNjb3BlTGlzdDogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlTGlzdCwgW3Njb3BlXV0pLFxuICAgICAgICBzY29wZVBhdGg6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZVBhdGgsIFt0YWddXSksXG4gICAgICAgIHNjb3BlUGF0aEl0ZW06IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZVBhdGhJdGVtLCBbaV1dKSxcbiAgICAgICAgc2NvcGVQYXRoTGVuZ3RoOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVQYXRoTGVuZ3RoLCBbbGVuZ3RoXV0pLFxuICAgICAgICBzY29wZUxpbmRleDogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlTGluZGV4LCBbcGFydC5sSW5kZXhdXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zLnNjb3BlUGF0aCA9IFtdO1xuICBvcHRpb25zLnNjb3BlUGF0aEl0ZW0gPSBbXTtcbiAgb3B0aW9ucy5zY29wZVBhdGhMZW5ndGggPSBbXTtcbiAgb3B0aW9ucy5zY29wZVR5cGVzID0gW107XG4gIG9wdGlvbnMuc2NvcGVMaW5kZXggPSBbXTtcbiAgb3B0aW9ucy5zY29wZUxpc3QgPSBbb3B0aW9ucy50YWdzXTtcbiAgcmV0dXJuIG5ldyBTY29wZU1hbmFnZXIob3B0aW9ucyk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/scope-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/traits.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/traits.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  getRightOrNull = _require.getRightOrNull,\n  getRight = _require.getRight,\n  getLeft = _require.getLeft,\n  getLeftOrNull = _require.getLeftOrNull,\n  chunkBy = _require.chunkBy,\n  isTagStart = _require.isTagStart,\n  isTagEnd = _require.isTagEnd,\n  isContent = _require.isContent,\n  last = _require.last,\n  first = _require.first;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"),\n  XTTemplateError = _require2.XTTemplateError,\n  throwExpandNotFound = _require2.throwExpandNotFound,\n  getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\nfunction lastTagIsOpenTag(tags, tag) {\n  if (tags.length === 0) {\n    return false;\n  }\n  var innerLastTag = last(tags).substr(1);\n  return innerLastTag.indexOf(tag) === 0;\n}\nfunction getListXmlElements(parts) {\n  /*\n   * Gets the list of closing and opening tags between two texts. It doesn't take\n   * into account tags that are opened then closed. Those that are closed then\n   * opened are kept\n   *\n   * Example input :\n   *\n   * [\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"table1\",\n   * \t\t...\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data1\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"position\": \"end\",\n   * \t\t\"text\": true,\n   * \t\t\"value\": \"</w:t>\",\n   * \t\t\"tag\": \"w:t\",\n   * \t\t\"lIndex\": 112\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:p>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"content\",\n   * \t\t\"value\": \"<w:tcPr><w:tcW w:w=\"2444\" w:type=\"dxa\"/><w:tcBorders><w:top w:val=\"nil\"/><w:left w:val=\"nil\"/><w:bottom w:val=\"nil\"/><w:right w:val=\"nil\"/></w:tcBorders><w:shd w:val=\"clear\" w:color=\"auto\" w:fill=\"FFFFFF\"/></w:tcPr>\",\n   * \t},\n   * \t...\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:t xml:space=\"preserve\">\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data4\",\n   * \t}\n   * ]\n   *\n   * Returns\n   *\n   * \t[\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:t>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:t>\",\n   * \t\t},\n   * \t]\n   */\n\n  var result = [];\n  for (var _i2 = 0; _i2 < parts.length; _i2++) {\n    var _parts$_i = parts[_i2],\n      position = _parts$_i.position,\n      value = _parts$_i.value,\n      tag = _parts$_i.tag;\n    // Stryker disable all : because removing this condition would also work but we want to make the API future proof\n    if (!tag) {\n      continue;\n    }\n    // Stryker restore all\n    if (position === \"end\") {\n      if (lastTagIsOpenTag(result, tag)) {\n        result.pop();\n      } else {\n        result.push(value);\n      }\n    } else if (position === \"start\") {\n      result.push(value);\n    }\n    // ignore position === \"selfclosing\"\n  }\n  return result;\n}\nfunction has(name, xmlElements) {\n  for (var _i4 = 0; _i4 < xmlElements.length; _i4++) {\n    var xmlElement = xmlElements[_i4];\n    if (xmlElement.indexOf(\"<\".concat(name)) === 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n  var xmlElements = getListXmlElements(postparsed.slice(pair[0].offset, pair[1].offset));\n  var _loop = function _loop() {\n      var _expandTags$_i = expandTags[_i6],\n        contains = _expandTags$_i.contains,\n        expand = _expandTags$_i.expand,\n        onlyTextInTag = _expandTags$_i.onlyTextInTag;\n      if (has(contains, xmlElements)) {\n        if (onlyTextInTag) {\n          var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n          var right = getRightOrNull(postparsed, contains, pair[1].offset);\n          if (left === null || right === null) {\n            return 0; // continue\n          }\n          var subparsed = postparsed.slice(left, right);\n          var chunks = chunkBy(subparsed, function (p) {\n            return isTagStart(contains, p) ? \"start\" : isTagEnd(contains, p) ? \"end\" : null;\n          });\n          var firstChunk = first(chunks);\n          var lastChunk = last(chunks);\n          var firstContent = firstChunk.filter(isContent);\n          var lastContent = lastChunk.filter(isContent);\n          if (firstContent.length !== 1 || lastContent.length !== 1) {\n            return 0; // continue\n          }\n        }\n        var structured = getStructuredTagPositions(xmlElements);\n        var openCount = 0;\n        for (var _i8 = 0; _i8 < structured.length; _i8++) {\n          var _structured$_i = structured[_i8],\n            tag = _structured$_i.tag,\n            position = _structured$_i.position;\n          if (tag === expand) {\n            if (position === \"start\") {\n              openCount++;\n            }\n            if (position === \"end\") {\n              openCount--;\n            }\n          }\n        }\n        if (openCount !== 0) {\n          // Tested by #regression-loop-with-field-and-nofield\n          return {\n            v: {\n              error: getLoopPositionProducesInvalidXMLError({\n                tag: first(pair).part.value,\n                offset: [first(pair).part.offset, last(pair).part.offset]\n              })\n            }\n          };\n        }\n        return {\n          v: {\n            value: expand\n          }\n        };\n      }\n    },\n    _ret;\n  for (var _i6 = 0; _i6 < expandTags.length; _i6++) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n    if (_ret) return _ret.v;\n  }\n  if (!checkStartEnd(xmlElements)) {\n    return {\n      error: getLoopPositionProducesInvalidXMLError({\n        tag: first(pair).part.value,\n        offset: [first(pair).part.offset, last(pair).part.offset]\n      })\n    };\n  }\n  return {};\n}\nfunction getStructuredTagPositions(xmlElements) {\n  var result = [];\n  for (var _i0 = 0; _i0 < xmlElements.length; _i0++) {\n    var el = xmlElements[_i0];\n    var tag = getTagName(el);\n    var position = /^\\s*<\\//.test(el) ? \"end\" : \"start\";\n    result.push({\n      tag: tag,\n      position: position\n    });\n  }\n  return result;\n}\nfunction getTagName(tag) {\n  return tag.replace(/^\\s*<\\/?([a-zA-Z:]+).*/, \"$1\");\n}\nfunction checkStartEnd(xmlElements) {\n  if (xmlElements.length % 2 === 1) {\n    return false;\n  }\n  for (var i = 0, len = xmlElements.length / 2; i < len; i++) {\n    var start = xmlElements[i];\n    var end = xmlElements[xmlElements.length - i - 1];\n    var tagNameStart = getTagName(start);\n    var tagNameEnd = getTagName(end);\n    if (tagNameStart !== tagNameEnd) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getExpandLimit(part, index, postparsed, options) {\n  var expandTo = part.expandTo || options.expandTo;\n  // Stryker disable all : because this condition can be removed in v4 (the only usage was the image module before version 3.12.3 of the image module\n  if (!expandTo) {\n    return;\n  }\n  // Stryker restore all\n  var right, left;\n  try {\n    left = getLeft(postparsed, expandTo, index);\n    right = getRight(postparsed, expandTo, index);\n  } catch (rootError) {\n    var errProps = _objectSpread({\n      part: part,\n      rootError: rootError,\n      postparsed: postparsed,\n      expandTo: expandTo,\n      index: index\n    }, options.error);\n    if (options.onError) {\n      var errorResult = options.onError(errProps);\n      if (errorResult === \"ignore\") {\n        return;\n      }\n    }\n    throwExpandNotFound(errProps);\n  }\n  return [left, right];\n}\nfunction expandOne(_ref, part, postparsed, options) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    left = _ref2[0],\n    right = _ref2[1];\n  var index = postparsed.indexOf(part);\n  var leftParts = postparsed.slice(left, index);\n  var rightParts = postparsed.slice(index + 1, right + 1);\n  var inner = options.getInner({\n    postparse: options.postparse,\n    index: index,\n    part: part,\n    leftParts: leftParts,\n    rightParts: rightParts,\n    left: left,\n    right: right,\n    postparsed: postparsed\n  });\n  if (!inner.length) {\n    inner.expanded = [leftParts, rightParts];\n    inner = [inner];\n  }\n  return {\n    left: left,\n    right: right,\n    inner: inner\n  };\n}\n\n/* eslint-disable-next-line complexity */\nfunction expandToOne(postparsed, options) {\n  var errors = [];\n  if (postparsed.errors) {\n    errors = postparsed.errors;\n    postparsed = postparsed.postparsed;\n  }\n  var limits = [];\n  for (var i = 0, len = postparsed.length; i < len; i++) {\n    var part = postparsed[i];\n    if (part.type === \"placeholder\" && part.module === options.moduleName &&\n    /*\n     * The part.subparsed check is used to fix this github issue :\n     * https://github.com/open-xml-templating/docxtemplater/issues/671\n     */\n    !part.subparsed && !part.expanded) {\n      try {\n        var limit = getExpandLimit(part, i, postparsed, options);\n        if (!limit) {\n          continue;\n        }\n        var _limit = _slicedToArray(limit, 2),\n          left = _limit[0],\n          right = _limit[1];\n        limits.push({\n          left: left,\n          right: right,\n          part: part,\n          i: i,\n          leftPart: postparsed[left],\n          rightPart: postparsed[right]\n        });\n      } catch (error) {\n        // The Error can only be a\n        errors.push(error);\n      }\n    }\n  }\n  limits.sort(function (l1, l2) {\n    if (l1.left === l2.left) {\n      return l2.part.lIndex < l1.part.lIndex ? 1 : -1;\n    }\n    return l2.left < l1.left ? 1 : -1;\n  });\n  var maxRight = -1;\n  var offset = 0;\n  for (var _i1 = 0, _len = limits.length; _i1 < _len; _i1++) {\n    var _postparsed;\n    var _limit2 = limits[_i1];\n    maxRight = Math.max(maxRight, _i1 > 0 ? limits[_i1 - 1].right : 0);\n    if (_limit2.left < maxRight) {\n      continue;\n    }\n    var result = void 0;\n    try {\n      result = expandOne([_limit2.left + offset, _limit2.right + offset], _limit2.part, postparsed, options);\n    } catch (error) {\n      if (options.onError) {\n        var errorResult = options.onError(_objectSpread({\n          part: _limit2.part,\n          rootError: error,\n          postparsed: postparsed,\n          expandOne: expandOne\n        }, options.errors));\n        if (errorResult === \"ignore\") {\n          continue;\n        }\n      }\n      if (error instanceof XTTemplateError) {\n        errors.push(error);\n      } else {\n        throw error;\n      }\n    }\n    if (!result) {\n      continue;\n    }\n    offset += result.inner.length - (result.right + 1 - result.left);\n    (_postparsed = postparsed).splice.apply(_postparsed, [result.left, result.right + 1 - result.left].concat(_toConsumableArray(result.inner)));\n  }\n  return {\n    postparsed: postparsed,\n    errors: errors\n  };\n}\nmodule.exports = {\n  expandToOne: expandToOne,\n  getExpandToDefault: getExpandToDefault\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy90cmFpdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5Qix5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLDBFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy90cmFpdHMuanM/MDRiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBnZXRSaWdodE9yTnVsbCA9IF9yZXF1aXJlLmdldFJpZ2h0T3JOdWxsLFxuICBnZXRSaWdodCA9IF9yZXF1aXJlLmdldFJpZ2h0LFxuICBnZXRMZWZ0ID0gX3JlcXVpcmUuZ2V0TGVmdCxcbiAgZ2V0TGVmdE9yTnVsbCA9IF9yZXF1aXJlLmdldExlZnRPck51bGwsXG4gIGNodW5rQnkgPSBfcmVxdWlyZS5jaHVua0J5LFxuICBpc1RhZ1N0YXJ0ID0gX3JlcXVpcmUuaXNUYWdTdGFydCxcbiAgaXNUYWdFbmQgPSBfcmVxdWlyZS5pc1RhZ0VuZCxcbiAgaXNDb250ZW50ID0gX3JlcXVpcmUuaXNDb250ZW50LFxuICBsYXN0ID0gX3JlcXVpcmUubGFzdCxcbiAgZmlyc3QgPSBfcmVxdWlyZS5maXJzdDtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIiksXG4gIFhUVGVtcGxhdGVFcnJvciA9IF9yZXF1aXJlMi5YVFRlbXBsYXRlRXJyb3IsXG4gIHRocm93RXhwYW5kTm90Rm91bmQgPSBfcmVxdWlyZTIudGhyb3dFeHBhbmROb3RGb3VuZCxcbiAgZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3IgPSBfcmVxdWlyZTIuZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3I7XG5mdW5jdGlvbiBsYXN0VGFnSXNPcGVuVGFnKHRhZ3MsIHRhZykge1xuICBpZiAodGFncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGlubmVyTGFzdFRhZyA9IGxhc3QodGFncykuc3Vic3RyKDEpO1xuICByZXR1cm4gaW5uZXJMYXN0VGFnLmluZGV4T2YodGFnKSA9PT0gMDtcbn1cbmZ1bmN0aW9uIGdldExpc3RYbWxFbGVtZW50cyhwYXJ0cykge1xuICAvKlxuICAgKiBHZXRzIHRoZSBsaXN0IG9mIGNsb3NpbmcgYW5kIG9wZW5pbmcgdGFncyBiZXR3ZWVuIHR3byB0ZXh0cy4gSXQgZG9lc24ndCB0YWtlXG4gICAqIGludG8gYWNjb3VudCB0YWdzIHRoYXQgYXJlIG9wZW5lZCB0aGVuIGNsb3NlZC4gVGhvc2UgdGhhdCBhcmUgY2xvc2VkIHRoZW5cbiAgICogb3BlbmVkIGFyZSBrZXB0XG4gICAqXG4gICAqIEV4YW1wbGUgaW5wdXQgOlxuICAgKlxuICAgKiBbXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCJ0YWJsZTFcIixcbiAgICogXHRcdC4uLlxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCJ0MWRhdGExXCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwicG9zaXRpb25cIjogXCJlbmRcIixcbiAgICogXHRcdFwidGV4dFwiOiB0cnVlLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjwvdzp0PlwiLFxuICAgKiBcdFx0XCJ0YWdcIjogXCJ3OnRcIixcbiAgICogXHRcdFwibEluZGV4XCI6IDExMlxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPC93OnI+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8L3c6cD5cIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjwvdzp0Yz5cIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjx3OnRjPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwiY29udGVudFwiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjx3OnRjUHI+PHc6dGNXIHc6dz1cIjI0NDRcIiB3OnR5cGU9XCJkeGFcIi8+PHc6dGNCb3JkZXJzPjx3OnRvcCB3OnZhbD1cIm5pbFwiLz48dzpsZWZ0IHc6dmFsPVwibmlsXCIvPjx3OmJvdHRvbSB3OnZhbD1cIm5pbFwiLz48dzpyaWdodCB3OnZhbD1cIm5pbFwiLz48L3c6dGNCb3JkZXJzPjx3OnNoZCB3OnZhbD1cImNsZWFyXCIgdzpjb2xvcj1cImF1dG9cIiB3OmZpbGw9XCJGRkZGRkZcIi8+PC93OnRjUHI+XCIsXG4gICAqIFx0fSxcbiAgICogXHQuLi5cbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8dzpyPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPHc6dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCJ0MWRhdGE0XCIsXG4gICAqIFx0fVxuICAgKiBdXG4gICAqXG4gICAqIFJldHVybnNcbiAgICpcbiAgICogXHRbXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPC93OnQ+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjwvdzpyPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8L3c6cD5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPC93OnRjPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8dzp0Yz5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPHc6cD5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPHc6cj5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPHc6dD5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XVxuICAgKi9cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhcnRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX3BhcnRzJF9pID0gcGFydHNbX2kyXSxcbiAgICAgIHBvc2l0aW9uID0gX3BhcnRzJF9pLnBvc2l0aW9uLFxuICAgICAgdmFsdWUgPSBfcGFydHMkX2kudmFsdWUsXG4gICAgICB0YWcgPSBfcGFydHMkX2kudGFnO1xuICAgIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHJlbW92aW5nIHRoaXMgY29uZGl0aW9uIHdvdWxkIGFsc28gd29yayBidXQgd2Ugd2FudCB0byBtYWtlIHRoZSBBUEkgZnV0dXJlIHByb29mXG4gICAgaWYgKCF0YWcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gICAgaWYgKHBvc2l0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICBpZiAobGFzdFRhZ0lzT3BlblRhZyhyZXN1bHQsIHRhZykpIHtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICAvLyBpZ25vcmUgcG9zaXRpb24gPT09IFwic2VsZmNsb3NpbmdcIlxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoYXMobmFtZSwgeG1sRWxlbWVudHMpIHtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgeG1sRWxlbWVudHMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciB4bWxFbGVtZW50ID0geG1sRWxlbWVudHNbX2k0XTtcbiAgICBpZiAoeG1sRWxlbWVudC5pbmRleE9mKFwiPFwiLmNvbmNhdChuYW1lKSkgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRUb0RlZmF1bHQocG9zdHBhcnNlZCwgcGFpciwgZXhwYW5kVGFncykge1xuICB2YXIgeG1sRWxlbWVudHMgPSBnZXRMaXN0WG1sRWxlbWVudHMocG9zdHBhcnNlZC5zbGljZShwYWlyWzBdLm9mZnNldCwgcGFpclsxXS5vZmZzZXQpKTtcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgX2V4cGFuZFRhZ3MkX2kgPSBleHBhbmRUYWdzW19pNl0sXG4gICAgICAgIGNvbnRhaW5zID0gX2V4cGFuZFRhZ3MkX2kuY29udGFpbnMsXG4gICAgICAgIGV4cGFuZCA9IF9leHBhbmRUYWdzJF9pLmV4cGFuZCxcbiAgICAgICAgb25seVRleHRJblRhZyA9IF9leHBhbmRUYWdzJF9pLm9ubHlUZXh0SW5UYWc7XG4gICAgICBpZiAoaGFzKGNvbnRhaW5zLCB4bWxFbGVtZW50cykpIHtcbiAgICAgICAgaWYgKG9ubHlUZXh0SW5UYWcpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IGdldExlZnRPck51bGwocG9zdHBhcnNlZCwgY29udGFpbnMsIHBhaXJbMF0ub2Zmc2V0KTtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBnZXRSaWdodE9yTnVsbChwb3N0cGFyc2VkLCBjb250YWlucywgcGFpclsxXS5vZmZzZXQpO1xuICAgICAgICAgIGlmIChsZWZ0ID09PSBudWxsIHx8IHJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN1YnBhcnNlZCA9IHBvc3RwYXJzZWQuc2xpY2UobGVmdCwgcmlnaHQpO1xuICAgICAgICAgIHZhciBjaHVua3MgPSBjaHVua0J5KHN1YnBhcnNlZCwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiBpc1RhZ1N0YXJ0KGNvbnRhaW5zLCBwKSA/IFwic3RhcnRcIiA6IGlzVGFnRW5kKGNvbnRhaW5zLCBwKSA/IFwiZW5kXCIgOiBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBmaXJzdENodW5rID0gZmlyc3QoY2h1bmtzKTtcbiAgICAgICAgICB2YXIgbGFzdENodW5rID0gbGFzdChjaHVua3MpO1xuICAgICAgICAgIHZhciBmaXJzdENvbnRlbnQgPSBmaXJzdENodW5rLmZpbHRlcihpc0NvbnRlbnQpO1xuICAgICAgICAgIHZhciBsYXN0Q29udGVudCA9IGxhc3RDaHVuay5maWx0ZXIoaXNDb250ZW50KTtcbiAgICAgICAgICBpZiAoZmlyc3RDb250ZW50Lmxlbmd0aCAhPT0gMSB8fCBsYXN0Q29udGVudC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RydWN0dXJlZCA9IGdldFN0cnVjdHVyZWRUYWdQb3NpdGlvbnMoeG1sRWxlbWVudHMpO1xuICAgICAgICB2YXIgb3BlbkNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgc3RydWN0dXJlZC5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICAgICAgdmFyIF9zdHJ1Y3R1cmVkJF9pID0gc3RydWN0dXJlZFtfaThdLFxuICAgICAgICAgICAgdGFnID0gX3N0cnVjdHVyZWQkX2kudGFnLFxuICAgICAgICAgICAgcG9zaXRpb24gPSBfc3RydWN0dXJlZCRfaS5wb3NpdGlvbjtcbiAgICAgICAgICBpZiAodGFnID09PSBleHBhbmQpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgIG9wZW5Db3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgIG9wZW5Db3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3BlbkNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgLy8gVGVzdGVkIGJ5ICNyZWdyZXNzaW9uLWxvb3Atd2l0aC1maWVsZC1hbmQtbm9maWVsZFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2OiB7XG4gICAgICAgICAgICAgIGVycm9yOiBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcih7XG4gICAgICAgICAgICAgICAgdGFnOiBmaXJzdChwYWlyKS5wYXJ0LnZhbHVlLFxuICAgICAgICAgICAgICAgIG9mZnNldDogW2ZpcnN0KHBhaXIpLnBhcnQub2Zmc2V0LCBsYXN0KHBhaXIpLnBhcnQub2Zmc2V0XVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2OiB7XG4gICAgICAgICAgICB2YWx1ZTogZXhwYW5kXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgX3JldDtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZXhwYW5kVGFncy5sZW5ndGg7IF9pNisrKSB7XG4gICAgX3JldCA9IF9sb29wKCk7XG4gICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgIGlmIChfcmV0KSByZXR1cm4gX3JldC52O1xuICB9XG4gIGlmICghY2hlY2tTdGFydEVuZCh4bWxFbGVtZW50cykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yKHtcbiAgICAgICAgdGFnOiBmaXJzdChwYWlyKS5wYXJ0LnZhbHVlLFxuICAgICAgICBvZmZzZXQ6IFtmaXJzdChwYWlyKS5wYXJ0Lm9mZnNldCwgbGFzdChwYWlyKS5wYXJ0Lm9mZnNldF1cbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBnZXRTdHJ1Y3R1cmVkVGFnUG9zaXRpb25zKHhtbEVsZW1lbnRzKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgX2kwID0gMDsgX2kwIDwgeG1sRWxlbWVudHMubGVuZ3RoOyBfaTArKykge1xuICAgIHZhciBlbCA9IHhtbEVsZW1lbnRzW19pMF07XG4gICAgdmFyIHRhZyA9IGdldFRhZ05hbWUoZWwpO1xuICAgIHZhciBwb3NpdGlvbiA9IC9eXFxzKjxcXC8vLnRlc3QoZWwpID8gXCJlbmRcIiA6IFwic3RhcnRcIjtcbiAgICByZXN1bHQucHVzaCh7XG4gICAgICB0YWc6IHRhZyxcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRUYWdOYW1lKHRhZykge1xuICByZXR1cm4gdGFnLnJlcGxhY2UoL15cXHMqPFxcLz8oW2EtekEtWjpdKykuKi8sIFwiJDFcIik7XG59XG5mdW5jdGlvbiBjaGVja1N0YXJ0RW5kKHhtbEVsZW1lbnRzKSB7XG4gIGlmICh4bWxFbGVtZW50cy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB4bWxFbGVtZW50cy5sZW5ndGggLyAyOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgc3RhcnQgPSB4bWxFbGVtZW50c1tpXTtcbiAgICB2YXIgZW5kID0geG1sRWxlbWVudHNbeG1sRWxlbWVudHMubGVuZ3RoIC0gaSAtIDFdO1xuICAgIHZhciB0YWdOYW1lU3RhcnQgPSBnZXRUYWdOYW1lKHN0YXJ0KTtcbiAgICB2YXIgdGFnTmFtZUVuZCA9IGdldFRhZ05hbWUoZW5kKTtcbiAgICBpZiAodGFnTmFtZVN0YXJ0ICE9PSB0YWdOYW1lRW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kTGltaXQocGFydCwgaW5kZXgsIHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgdmFyIGV4cGFuZFRvID0gcGFydC5leHBhbmRUbyB8fCBvcHRpb25zLmV4cGFuZFRvO1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGNvbmRpdGlvbiBjYW4gYmUgcmVtb3ZlZCBpbiB2NCAodGhlIG9ubHkgdXNhZ2Ugd2FzIHRoZSBpbWFnZSBtb2R1bGUgYmVmb3JlIHZlcnNpb24gMy4xMi4zIG9mIHRoZSBpbWFnZSBtb2R1bGVcbiAgaWYgKCFleHBhbmRUbykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gIHZhciByaWdodCwgbGVmdDtcbiAgdHJ5IHtcbiAgICBsZWZ0ID0gZ2V0TGVmdChwb3N0cGFyc2VkLCBleHBhbmRUbywgaW5kZXgpO1xuICAgIHJpZ2h0ID0gZ2V0UmlnaHQocG9zdHBhcnNlZCwgZXhwYW5kVG8sIGluZGV4KTtcbiAgfSBjYXRjaCAocm9vdEVycm9yKSB7XG4gICAgdmFyIGVyclByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgcm9vdEVycm9yOiByb290RXJyb3IsXG4gICAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgICAgZXhwYW5kVG86IGV4cGFuZFRvLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSwgb3B0aW9ucy5lcnJvcik7XG4gICAgaWYgKG9wdGlvbnMub25FcnJvcikge1xuICAgICAgdmFyIGVycm9yUmVzdWx0ID0gb3B0aW9ucy5vbkVycm9yKGVyclByb3BzKTtcbiAgICAgIGlmIChlcnJvclJlc3VsdCA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93RXhwYW5kTm90Rm91bmQoZXJyUHJvcHMpO1xuICB9XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdO1xufVxuZnVuY3Rpb24gZXhwYW5kT25lKF9yZWYsIHBhcnQsIHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgbGVmdCA9IF9yZWYyWzBdLFxuICAgIHJpZ2h0ID0gX3JlZjJbMV07XG4gIHZhciBpbmRleCA9IHBvc3RwYXJzZWQuaW5kZXhPZihwYXJ0KTtcbiAgdmFyIGxlZnRQYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UobGVmdCwgaW5kZXgpO1xuICB2YXIgcmlnaHRQYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UoaW5kZXggKyAxLCByaWdodCArIDEpO1xuICB2YXIgaW5uZXIgPSBvcHRpb25zLmdldElubmVyKHtcbiAgICBwb3N0cGFyc2U6IG9wdGlvbnMucG9zdHBhcnNlLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIGxlZnRQYXJ0czogbGVmdFBhcnRzLFxuICAgIHJpZ2h0UGFydHM6IHJpZ2h0UGFydHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZFxuICB9KTtcbiAgaWYgKCFpbm5lci5sZW5ndGgpIHtcbiAgICBpbm5lci5leHBhbmRlZCA9IFtsZWZ0UGFydHMsIHJpZ2h0UGFydHNdO1xuICAgIGlubmVyID0gW2lubmVyXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGlubmVyOiBpbm5lclxuICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSAqL1xuZnVuY3Rpb24gZXhwYW5kVG9PbmUocG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChwb3N0cGFyc2VkLmVycm9ycykge1xuICAgIGVycm9ycyA9IHBvc3RwYXJzZWQuZXJyb3JzO1xuICAgIHBvc3RwYXJzZWQgPSBwb3N0cGFyc2VkLnBvc3RwYXJzZWQ7XG4gIH1cbiAgdmFyIGxpbWl0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9zdHBhcnNlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcG9zdHBhcnNlZFtpXTtcbiAgICBpZiAocGFydC50eXBlID09PSBcInBsYWNlaG9sZGVyXCIgJiYgcGFydC5tb2R1bGUgPT09IG9wdGlvbnMubW9kdWxlTmFtZSAmJlxuICAgIC8qXG4gICAgICogVGhlIHBhcnQuc3VicGFyc2VkIGNoZWNrIGlzIHVzZWQgdG8gZml4IHRoaXMgZ2l0aHViIGlzc3VlIDpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi14bWwtdGVtcGxhdGluZy9kb2N4dGVtcGxhdGVyL2lzc3Vlcy82NzFcbiAgICAgKi9cbiAgICAhcGFydC5zdWJwYXJzZWQgJiYgIXBhcnQuZXhwYW5kZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBsaW1pdCA9IGdldEV4cGFuZExpbWl0KHBhcnQsIGksIHBvc3RwYXJzZWQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9saW1pdCA9IF9zbGljZWRUb0FycmF5KGxpbWl0LCAyKSxcbiAgICAgICAgICBsZWZ0ID0gX2xpbWl0WzBdLFxuICAgICAgICAgIHJpZ2h0ID0gX2xpbWl0WzFdO1xuICAgICAgICBsaW1pdHMucHVzaCh7XG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGxlZnRQYXJ0OiBwb3N0cGFyc2VkW2xlZnRdLFxuICAgICAgICAgIHJpZ2h0UGFydDogcG9zdHBhcnNlZFtyaWdodF1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUaGUgRXJyb3IgY2FuIG9ubHkgYmUgYVxuICAgICAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxpbWl0cy5zb3J0KGZ1bmN0aW9uIChsMSwgbDIpIHtcbiAgICBpZiAobDEubGVmdCA9PT0gbDIubGVmdCkge1xuICAgICAgcmV0dXJuIGwyLnBhcnQubEluZGV4IDwgbDEucGFydC5sSW5kZXggPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiBsMi5sZWZ0IDwgbDEubGVmdCA/IDEgOiAtMTtcbiAgfSk7XG4gIHZhciBtYXhSaWdodCA9IC0xO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgZm9yICh2YXIgX2kxID0gMCwgX2xlbiA9IGxpbWl0cy5sZW5ndGg7IF9pMSA8IF9sZW47IF9pMSsrKSB7XG4gICAgdmFyIF9wb3N0cGFyc2VkO1xuICAgIHZhciBfbGltaXQyID0gbGltaXRzW19pMV07XG4gICAgbWF4UmlnaHQgPSBNYXRoLm1heChtYXhSaWdodCwgX2kxID4gMCA/IGxpbWl0c1tfaTEgLSAxXS5yaWdodCA6IDApO1xuICAgIGlmIChfbGltaXQyLmxlZnQgPCBtYXhSaWdodCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGV4cGFuZE9uZShbX2xpbWl0Mi5sZWZ0ICsgb2Zmc2V0LCBfbGltaXQyLnJpZ2h0ICsgb2Zmc2V0XSwgX2xpbWl0Mi5wYXJ0LCBwb3N0cGFyc2VkLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMub25FcnJvcikge1xuICAgICAgICB2YXIgZXJyb3JSZXN1bHQgPSBvcHRpb25zLm9uRXJyb3IoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgcGFydDogX2xpbWl0Mi5wYXJ0LFxuICAgICAgICAgIHJvb3RFcnJvcjogZXJyb3IsXG4gICAgICAgICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZCxcbiAgICAgICAgICBleHBhbmRPbmU6IGV4cGFuZE9uZVxuICAgICAgICB9LCBvcHRpb25zLmVycm9ycykpO1xuICAgICAgICBpZiAoZXJyb3JSZXN1bHQgPT09IFwiaWdub3JlXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgWFRUZW1wbGF0ZUVycm9yKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG9mZnNldCArPSByZXN1bHQuaW5uZXIubGVuZ3RoIC0gKHJlc3VsdC5yaWdodCArIDEgLSByZXN1bHQubGVmdCk7XG4gICAgKF9wb3N0cGFyc2VkID0gcG9zdHBhcnNlZCkuc3BsaWNlLmFwcGx5KF9wb3N0cGFyc2VkLCBbcmVzdWx0LmxlZnQsIHJlc3VsdC5yaWdodCArIDEgLSByZXN1bHQubGVmdF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQuaW5uZXIpKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXhwYW5kVG9PbmU6IGV4cGFuZFRvT25lLFxuICBnZXRFeHBhbmRUb0RlZmF1bHQ6IGdldEV4cGFuZFRvRGVmYXVsdFxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/traits.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/utils.js":
/*!************************************************!*\
  !*** ./node_modules/docxtemplater/js/utils.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\nfunction last(a) {\n  return a[a.length - 1];\n}\nfunction first(a) {\n  return a[0];\n}\nmodule.exports = {\n  last: last,\n  first: first\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2tyYWJpLW91dGFnZS10cmFja2VyLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvdXRpbHMuanM/YmI4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gbGFzdChhKSB7XG4gIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBmaXJzdChhKSB7XG4gIHJldHVybiBhWzBdO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxhc3Q6IGxhc3QsXG4gIGZpcnN0OiBmaXJzdFxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/xml-matcher.js":
/*!******************************************************!*\
  !*** ./node_modules/docxtemplater/js/xml-matcher.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pregMatchAll = _require.pregMatchAll;\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\n  var res = {\n    content: content\n  };\n  var taj = tagsXmlArray.join(\"|\");\n  var regexp = new RegExp(\"(?:(<(?:\".concat(taj, \")[^>]*>)([^<>]*)</(?:\").concat(taj, \")>)|(<(?:\").concat(taj, \")[^>]*/>)\"), \"g\");\n  res.matches = pregMatchAll(regexp, res.content);\n  return res;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtbWF0Y2hlci5qcz9hOWIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHByZWdNYXRjaEFsbCA9IF9yZXF1aXJlLnByZWdNYXRjaEFsbDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG1sTWF0Y2hlcihjb250ZW50LCB0YWdzWG1sQXJyYXkpIHtcbiAgdmFyIHJlcyA9IHtcbiAgICBjb250ZW50OiBjb250ZW50XG4gIH07XG4gIHZhciB0YWogPSB0YWdzWG1sQXJyYXkuam9pbihcInxcIik7XG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiKD86KDwoPzpcIi5jb25jYXQodGFqLCBcIilbXj5dKj4pKFtePD5dKik8Lyg/OlwiKS5jb25jYXQodGFqLCBcIik+KXwoPCg/OlwiKS5jb25jYXQodGFqLCBcIilbXj5dKi8+KVwiKSwgXCJnXCIpO1xuICByZXMubWF0Y2hlcyA9IHByZWdNYXRjaEFsbChyZWdleHAsIHJlcy5jb250ZW50KTtcbiAgcmV0dXJuIHJlcztcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/xml-matcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/xml-templater.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/xml-templater.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray,\n  wordToUtf8 = _require.wordToUtf8,\n  convertSpaces = _require.convertSpaces;\nvar xmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(rsc)/./node_modules/docxtemplater/js/xml-matcher.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(rsc)/./node_modules/docxtemplater/js/lexer.js\");\nvar Parser = __webpack_require__(/*! ./parser.js */ \"(rsc)/./node_modules/docxtemplater/js/parser.js\");\nvar _render = __webpack_require__(/*! ./render.js */ \"(rsc)/./node_modules/docxtemplater/js/render.js\");\nvar postrender = __webpack_require__(/*! ./postrender.js */ \"(rsc)/./node_modules/docxtemplater/js/postrender.js\");\nvar resolve = __webpack_require__(/*! ./resolve.js */ \"(rsc)/./node_modules/docxtemplater/js/resolve.js\");\nvar joinUncorrupt = __webpack_require__(/*! ./join-uncorrupt.js */ \"(rsc)/./node_modules/docxtemplater/js/join-uncorrupt.js\");\nfunction _getFullText(content, tagsXmlArray) {\n  var matcher = xmlMatcher(content, tagsXmlArray);\n  var result = matcher.matches.map(function (match) {\n    return match.array[2];\n  });\n  return wordToUtf8(convertSpaces(result.join(\"\")));\n}\nmodule.exports = /*#__PURE__*/function () {\n  function XmlTemplater(content, options) {\n    _classCallCheck(this, XmlTemplater);\n    this.cachedParsers = {};\n    this.content = content;\n    for (var key in options) {\n      this[key] = options[key];\n    }\n    this.setModules({\n      inspect: {\n        filePath: options.filePath\n      }\n    });\n  }\n  return _createClass(XmlTemplater, [{\n    key: \"resolveTags\",\n    value: function resolveTags(tags) {\n      var _this = this;\n      this.tags = tags;\n      var options = this.getOptions();\n      var filePath = this.filePath;\n      options.scopeManager = this.scopeManager;\n      options.resolve = resolve;\n      var errors = [];\n      return Promise.all(this.modules.map(function (module) {\n        return Promise.resolve(module.preResolve(options))[\"catch\"](function (e) {\n          errors.push(e);\n        });\n      })).then(function () {\n        if (errors.length !== 0) {\n          throw errors;\n        }\n        return resolve(options).then(function (_ref) {\n          var resolved = _ref.resolved,\n            errors = _ref.errors;\n          errors = errors.map(function (error) {\n            var _error;\n            // If a string is thrown, convert it to a real Error\n            if (!(error instanceof Error)) {\n              error = new Error(error);\n            }\n            /*\n             * error properties might not be defined if some foreign error\n             * (unhandled error not thrown by docxtemplater willingly) is\n             * thrown.\n             */\n            (_error = error).properties || (_error.properties = {});\n            error.properties.file = filePath;\n            return error;\n          });\n          if (errors.length !== 0) {\n            throw errors;\n          }\n          return Promise.all(resolved).then(function (resolved) {\n            options.scopeManager.root.finishedResolving = true;\n            options.scopeManager.resolved = resolved;\n            _this.setModules({\n              inspect: {\n                resolved: resolved,\n                filePath: filePath\n              }\n            });\n            return resolved;\n          });\n        })[\"catch\"](function (error) {\n          _this.errorChecker(error);\n          throw error;\n        });\n      });\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText() {\n      return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      for (var _i2 = 0, _this$modules2 = this.modules; _i2 < _this$modules2.length; _i2++) {\n        var _module = _this$modules2[_i2];\n        _module.set(obj);\n      }\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse() {\n      this.allErrors = [];\n      this.xmllexed = Lexer.xmlparse(this.content, {\n        text: this.fileTypeConfig.tagsXmlTextArray,\n        other: this.fileTypeConfig.tagsXmlLexedArray\n      });\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          xmllexed: this.xmllexed\n        }\n      });\n      var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters, this.syntax, this.fileType),\n        lexed = _Lexer$parse.lexed,\n        lexerErrors = _Lexer$parse.errors;\n      pushArray(this.allErrors, lexerErrors);\n      this.lexed = lexed;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          lexed: this.lexed\n        }\n      });\n      var options = this.getOptions();\n      this.lexed = Parser.preparse(this.lexed, this.modules, options);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        noPostParse = _ref2.noPostParse;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath\n        }\n      });\n      var options = this.getOptions();\n      this.parsed = Parser.parse(this.lexed, this.modules, options);\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          parsed: this.parsed\n        }\n      });\n      if (noPostParse) {\n        return this;\n      }\n      // In v4, we could remove this \"this.postparse()\" so that users have to call this manually.\n      return this.postparse();\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse() {\n      var options = this.getOptions();\n      var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options),\n        postparsed = _Parser$postparse.postparsed,\n        postparsedErrors = _Parser$postparse.errors;\n      this.postparsed = postparsed;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          postparsed: this.postparsed\n        }\n      });\n      pushArray(this.allErrors, postparsedErrors);\n      this.errorChecker(this.allErrors);\n      return this;\n    }\n  }, {\n    key: \"errorChecker\",\n    value: function errorChecker(errors) {\n      for (var _i4 = 0, _errors2 = errors; _i4 < _errors2.length; _i4++) {\n        var error = _errors2[_i4];\n        /*\n         * error properties might not be defined if some foreign\n         * (unhandled error not thrown by docxtemplater willingly) is\n         * thrown.\n         */\n        error.properties || (error.properties = {});\n        error.properties.file = this.filePath;\n      }\n      for (var _i6 = 0, _this$modules4 = this.modules; _i6 < _this$modules4.length; _i6++) {\n        var _module2 = _this$modules4[_i6];\n        errors = _module2.errorsTransformer(errors);\n      }\n    }\n  }, {\n    key: \"baseNullGetter\",\n    value: function baseNullGetter(part, sm) {\n      var value = null;\n      for (var _i8 = 0, _this$modules6 = this.modules; _i8 < _this$modules6.length; _i8++) {\n        var _module3 = _this$modules6[_i8];\n        if (value != null) {\n          continue;\n        }\n        value = _module3.nullGetter(part, sm, this);\n      }\n      if (value != null) {\n        return value;\n      }\n      return this.nullGetter(part, sm);\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return {\n        compiled: this.postparsed,\n        cachedParsers: this.cachedParsers,\n        tags: this.tags,\n        modules: this.modules,\n        parser: this.parser,\n        contentType: this.contentType,\n        relsType: this.relsType,\n        baseNullGetter: this.baseNullGetter.bind(this),\n        filePath: this.filePath,\n        fileTypeConfig: this.fileTypeConfig,\n        fileType: this.fileType,\n        linebreaks: this.linebreaks,\n        stripInvalidXMLChars: this.stripInvalidXMLChars\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(to) {\n      this.filePath = to;\n      var options = this.getOptions();\n      options.resolved = this.scopeManager.resolved;\n      options.scopeManager = this.scopeManager;\n      options.render = _render;\n      options.joinUncorrupt = joinUncorrupt;\n      var _render2 = _render(options),\n        errors = _render2.errors,\n        parts = _render2.parts;\n      if (errors.length > 0) {\n        this.allErrors = errors;\n        this.errorChecker(errors);\n        return this;\n      }\n      this.content = postrender(parts, options);\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          content: this.content\n        }\n      });\n      return this;\n    }\n  }]);\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtdGVtcGxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFrQjtBQUMzQyxZQUFZLG1CQUFPLENBQUMsa0VBQVk7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG9FQUFhO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBYTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLHNFQUFjO0FBQ3BDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdURBQXVELDZCQUE2QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSx1REFBdUQsNkJBQTZCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw2QkFBNkI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va3JhYmktb3V0YWdlLXRyYWNrZXIvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtdGVtcGxhdGVyLmpzPzY5NTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUucHVzaEFycmF5LFxuICB3b3JkVG9VdGY4ID0gX3JlcXVpcmUud29yZFRvVXRmOCxcbiAgY29udmVydFNwYWNlcyA9IF9yZXF1aXJlLmNvbnZlcnRTcGFjZXM7XG52YXIgeG1sTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3htbC1tYXRjaGVyLmpzXCIpO1xudmFyIExleGVyID0gcmVxdWlyZShcIi4vbGV4ZXIuanNcIik7XG52YXIgUGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2VyLmpzXCIpO1xudmFyIF9yZW5kZXIgPSByZXF1aXJlKFwiLi9yZW5kZXIuanNcIik7XG52YXIgcG9zdHJlbmRlciA9IHJlcXVpcmUoXCIuL3Bvc3RyZW5kZXIuanNcIik7XG52YXIgcmVzb2x2ZSA9IHJlcXVpcmUoXCIuL3Jlc29sdmUuanNcIik7XG52YXIgam9pblVuY29ycnVwdCA9IHJlcXVpcmUoXCIuL2pvaW4tdW5jb3JydXB0LmpzXCIpO1xuZnVuY3Rpb24gX2dldEZ1bGxUZXh0KGNvbnRlbnQsIHRhZ3NYbWxBcnJheSkge1xuICB2YXIgbWF0Y2hlciA9IHhtbE1hdGNoZXIoY29udGVudCwgdGFnc1htbEFycmF5KTtcbiAgdmFyIHJlc3VsdCA9IG1hdGNoZXIubWF0Y2hlcy5tYXAoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIG1hdGNoLmFycmF5WzJdO1xuICB9KTtcbiAgcmV0dXJuIHdvcmRUb1V0ZjgoY29udmVydFNwYWNlcyhyZXN1bHQuam9pbihcIlwiKSkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYbWxUZW1wbGF0ZXIoY29udGVudCwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYbWxUZW1wbGF0ZXIpO1xuICAgIHRoaXMuY2FjaGVkUGFyc2VycyA9IHt9O1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG4gICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgZmlsZVBhdGg6IG9wdGlvbnMuZmlsZVBhdGhcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFhtbFRlbXBsYXRlciwgW3tcbiAgICBrZXk6IFwicmVzb2x2ZVRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZVRhZ3ModGFncykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdmFyIGZpbGVQYXRoID0gdGhpcy5maWxlUGF0aDtcbiAgICAgIG9wdGlvbnMuc2NvcGVNYW5hZ2VyID0gdGhpcy5zY29wZU1hbmFnZXI7XG4gICAgICBvcHRpb25zLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMubW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1vZHVsZS5wcmVSZXNvbHZlKG9wdGlvbnMpKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IGVycm9ycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIHJlc29sdmVkID0gX3JlZi5yZXNvbHZlZCxcbiAgICAgICAgICAgIGVycm9ycyA9IF9yZWYuZXJyb3JzO1xuICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgX2Vycm9yO1xuICAgICAgICAgICAgLy8gSWYgYSBzdHJpbmcgaXMgdGhyb3duLCBjb252ZXJ0IGl0IHRvIGEgcmVhbCBFcnJvclxuICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGVycm9yIHByb3BlcnRpZXMgbWlnaHQgbm90IGJlIGRlZmluZWQgaWYgc29tZSBmb3JlaWduIGVycm9yXG4gICAgICAgICAgICAgKiAodW5oYW5kbGVkIGVycm9yIG5vdCB0aHJvd24gYnkgZG9jeHRlbXBsYXRlciB3aWxsaW5nbHkpIGlzXG4gICAgICAgICAgICAgKiB0aHJvd24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIChfZXJyb3IgPSBlcnJvcikucHJvcGVydGllcyB8fCAoX2Vycm9yLnByb3BlcnRpZXMgPSB7fSk7XG4gICAgICAgICAgICBlcnJvci5wcm9wZXJ0aWVzLmZpbGUgPSBmaWxlUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzb2x2ZWQpLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNjb3BlTWFuYWdlci5yb290LmZpbmlzaGVkUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdGlvbnMuc2NvcGVNYW5hZ2VyLnJlc29sdmVkID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBfdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkOiByZXNvbHZlZCxcbiAgICAgICAgICAgICAgICBmaWxlUGF0aDogZmlsZVBhdGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgX3RoaXMuZXJyb3JDaGVja2VyKGVycm9yKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbFRleHQoKSB7XG4gICAgICByZXR1cm4gX2dldEZ1bGxUZXh0KHRoaXMuY29udGVudCwgdGhpcy5maWxlVHlwZUNvbmZpZy50YWdzWG1sVGV4dEFycmF5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TW9kdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNb2R1bGVzKG9iaikge1xuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3RoaXMkbW9kdWxlczIgPSB0aGlzLm1vZHVsZXM7IF9pMiA8IF90aGlzJG1vZHVsZXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGUgPSBfdGhpcyRtb2R1bGVzMltfaTJdO1xuICAgICAgICBfbW9kdWxlLnNldChvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJzZSgpIHtcbiAgICAgIHRoaXMuYWxsRXJyb3JzID0gW107XG4gICAgICB0aGlzLnhtbGxleGVkID0gTGV4ZXIueG1scGFyc2UodGhpcy5jb250ZW50LCB7XG4gICAgICAgIHRleHQ6IHRoaXMuZmlsZVR5cGVDb25maWcudGFnc1htbFRleHRBcnJheSxcbiAgICAgICAgb3RoZXI6IHRoaXMuZmlsZVR5cGVDb25maWcudGFnc1htbExleGVkQXJyYXlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIHhtbGxleGVkOiB0aGlzLnhtbGxleGVkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIF9MZXhlciRwYXJzZSA9IExleGVyLnBhcnNlKHRoaXMueG1sbGV4ZWQsIHRoaXMuZGVsaW1pdGVycywgdGhpcy5zeW50YXgsIHRoaXMuZmlsZVR5cGUpLFxuICAgICAgICBsZXhlZCA9IF9MZXhlciRwYXJzZS5sZXhlZCxcbiAgICAgICAgbGV4ZXJFcnJvcnMgPSBfTGV4ZXIkcGFyc2UuZXJyb3JzO1xuICAgICAgcHVzaEFycmF5KHRoaXMuYWxsRXJyb3JzLCBsZXhlckVycm9ycyk7XG4gICAgICB0aGlzLmxleGVkID0gbGV4ZWQ7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgbGV4ZWQ6IHRoaXMubGV4ZWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdGhpcy5sZXhlZCA9IFBhcnNlci5wcmVwYXJzZSh0aGlzLmxleGVkLCB0aGlzLm1vZHVsZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIG5vUG9zdFBhcnNlID0gX3JlZjIubm9Qb3N0UGFyc2U7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGhcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdGhpcy5wYXJzZWQgPSBQYXJzZXIucGFyc2UodGhpcy5sZXhlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICBwYXJzZWQ6IHRoaXMucGFyc2VkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG5vUG9zdFBhcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gSW4gdjQsIHdlIGNvdWxkIHJlbW92ZSB0aGlzIFwidGhpcy5wb3N0cGFyc2UoKVwiIHNvIHRoYXQgdXNlcnMgaGF2ZSB0byBjYWxsIHRoaXMgbWFudWFsbHkuXG4gICAgICByZXR1cm4gdGhpcy5wb3N0cGFyc2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdHBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RwYXJzZSgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICB2YXIgX1BhcnNlciRwb3N0cGFyc2UgPSBQYXJzZXIucG9zdHBhcnNlKHRoaXMucGFyc2VkLCB0aGlzLm1vZHVsZXMsIG9wdGlvbnMpLFxuICAgICAgICBwb3N0cGFyc2VkID0gX1BhcnNlciRwb3N0cGFyc2UucG9zdHBhcnNlZCxcbiAgICAgICAgcG9zdHBhcnNlZEVycm9ycyA9IF9QYXJzZXIkcG9zdHBhcnNlLmVycm9ycztcbiAgICAgIHRoaXMucG9zdHBhcnNlZCA9IHBvc3RwYXJzZWQ7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgcG9zdHBhcnNlZDogdGhpcy5wb3N0cGFyc2VkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcHVzaEFycmF5KHRoaXMuYWxsRXJyb3JzLCBwb3N0cGFyc2VkRXJyb3JzKTtcbiAgICAgIHRoaXMuZXJyb3JDaGVja2VyKHRoaXMuYWxsRXJyb3JzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcnJvckNoZWNrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3JDaGVja2VyKGVycm9ycykge1xuICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX2Vycm9yczIgPSBlcnJvcnM7IF9pNCA8IF9lcnJvcnMyLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gX2Vycm9yczJbX2k0XTtcbiAgICAgICAgLypcbiAgICAgICAgICogZXJyb3IgcHJvcGVydGllcyBtaWdodCBub3QgYmUgZGVmaW5lZCBpZiBzb21lIGZvcmVpZ25cbiAgICAgICAgICogKHVuaGFuZGxlZCBlcnJvciBub3QgdGhyb3duIGJ5IGRvY3h0ZW1wbGF0ZXIgd2lsbGluZ2x5KSBpc1xuICAgICAgICAgKiB0aHJvd24uXG4gICAgICAgICAqL1xuICAgICAgICBlcnJvci5wcm9wZXJ0aWVzIHx8IChlcnJvci5wcm9wZXJ0aWVzID0ge30pO1xuICAgICAgICBlcnJvci5wcm9wZXJ0aWVzLmZpbGUgPSB0aGlzLmZpbGVQYXRoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2k2ID0gMCwgX3RoaXMkbW9kdWxlczQgPSB0aGlzLm1vZHVsZXM7IF9pNiA8IF90aGlzJG1vZHVsZXM0Lmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGUyID0gX3RoaXMkbW9kdWxlczRbX2k2XTtcbiAgICAgICAgZXJyb3JzID0gX21vZHVsZTIuZXJyb3JzVHJhbnNmb3JtZXIoZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmFzZU51bGxHZXR0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFzZU51bGxHZXR0ZXIocGFydCwgc20pIHtcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICBmb3IgKHZhciBfaTggPSAwLCBfdGhpcyRtb2R1bGVzNiA9IHRoaXMubW9kdWxlczsgX2k4IDwgX3RoaXMkbW9kdWxlczYubGVuZ3RoOyBfaTgrKykge1xuICAgICAgICB2YXIgX21vZHVsZTMgPSBfdGhpcyRtb2R1bGVzNltfaThdO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gX21vZHVsZTMubnVsbEdldHRlcihwYXJ0LCBzbSwgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5udWxsR2V0dGVyKHBhcnQsIHNtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGlsZWQ6IHRoaXMucG9zdHBhcnNlZCxcbiAgICAgICAgY2FjaGVkUGFyc2VyczogdGhpcy5jYWNoZWRQYXJzZXJzLFxuICAgICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICAgIG1vZHVsZXM6IHRoaXMubW9kdWxlcyxcbiAgICAgICAgcGFyc2VyOiB0aGlzLnBhcnNlcixcbiAgICAgICAgY29udGVudFR5cGU6IHRoaXMuY29udGVudFR5cGUsXG4gICAgICAgIHJlbHNUeXBlOiB0aGlzLnJlbHNUeXBlLFxuICAgICAgICBiYXNlTnVsbEdldHRlcjogdGhpcy5iYXNlTnVsbEdldHRlci5iaW5kKHRoaXMpLFxuICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgZmlsZVR5cGVDb25maWc6IHRoaXMuZmlsZVR5cGVDb25maWcsXG4gICAgICAgIGZpbGVUeXBlOiB0aGlzLmZpbGVUeXBlLFxuICAgICAgICBsaW5lYnJlYWtzOiB0aGlzLmxpbmVicmVha3MsXG4gICAgICAgIHN0cmlwSW52YWxpZFhNTENoYXJzOiB0aGlzLnN0cmlwSW52YWxpZFhNTENoYXJzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHRvKSB7XG4gICAgICB0aGlzLmZpbGVQYXRoID0gdG87XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgb3B0aW9ucy5yZXNvbHZlZCA9IHRoaXMuc2NvcGVNYW5hZ2VyLnJlc29sdmVkO1xuICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIgPSB0aGlzLnNjb3BlTWFuYWdlcjtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gX3JlbmRlcjtcbiAgICAgIG9wdGlvbnMuam9pblVuY29ycnVwdCA9IGpvaW5VbmNvcnJ1cHQ7XG4gICAgICB2YXIgX3JlbmRlcjIgPSBfcmVuZGVyKG9wdGlvbnMpLFxuICAgICAgICBlcnJvcnMgPSBfcmVuZGVyMi5lcnJvcnMsXG4gICAgICAgIHBhcnRzID0gX3JlbmRlcjIucGFydHM7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMuZXJyb3JDaGVja2VyKGVycm9ycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZW50ID0gcG9zdHJlbmRlcihwYXJ0cywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG59KCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/xml-templater.js\n");

/***/ })

};
;